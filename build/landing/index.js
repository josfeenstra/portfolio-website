(()=>{"use strict";eval('\n;// CONCATENATED MODULE: ./src/data/int-matrix.ts\n// generic all-pupose matrix of ints\r\nclass int_matrix_IntMatrix {\r\n    constructor(height, width, data = []) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this.data = new Uint16Array(this._width * this._height);\r\n        if (data == [] || data.length == 0)\r\n            this.fill(0);\r\n        else\r\n            this.setData(data);\r\n    }\r\n    static fromList(list, width) {\r\n        let height = list.length / width;\r\n        let array = new int_matrix_IntMatrix(height, width);\r\n        for (let i = 0; i < list.length; i++) {\r\n            array.data[i] = list[i];\r\n        }\r\n        return array;\r\n    }\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this._height; i++) {\r\n            strings.push("|");\r\n            for (var j = 0; j < this._width; j++) {\r\n                let str = this.get(i, j).toFixed(2);\r\n                str = str.padStart(WIDTH, " ");\r\n                strings.push(str);\r\n                if (j < this._width - 2) {\r\n                    strings.push("  ");\r\n                }\r\n            }\r\n            strings.push("  |\\n");\r\n        }\r\n        console.log(strings.join(""));\r\n    }\r\n    clone() {\r\n        let clone = new int_matrix_IntMatrix(this._height, this._width);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this._height * this._width)\r\n            throw "data.length does not match width * height " + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for \'how many of x?\' they usually mean this.\r\n        return this._height;\r\n    }\r\n    getDimensions() {\r\n        return [this._height, this._width];\r\n    }\r\n    inRange(i, j) {\r\n        return !(i < 0 || i > this._height - 1 || j < 0 || j > this._width - 1);\r\n    }\r\n    fill(value) {\r\n        let size = this._height * this._width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this._width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this._width)\r\n            throw "values per entry is larger than this._width. This will spill over.";\r\n        for (let i = 0; i < this._height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    get(i, j) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn("out of range!");\r\n            return 0;\r\n        }\r\n        return this.data[i * this._width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw "column is out of bounds for Array"\r\n        let data = new Uint16Array(this._width);\r\n        for (let j = 0; j < this._width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw "column is out of bounds for Array"\r\n        let data = new Uint16Array(this._height);\r\n        for (let i = 0; i < this._height; i++) {\r\n            let index = i * this._width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn("out of range!");\r\n            return;\r\n        }\r\n        this.data[i * this._width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw "dimention of floatarray is not " + row.length;\r\n        for (let j = 0; j < this._width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    takeRows(indices) {\r\n        // create a new array from a couple of rows\r\n        console.log(this._height, this._width);\r\n        const count = indices.length;\r\n        let array = new int_matrix_IntMatrix(count, this._width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    forEachRow(callbackfn) {\r\n        for (let i = 0; i < this._height; i++) {\r\n            let row = this.getRow(i);\r\n            callbackfn(row, i);\r\n            this.setRow(i, row);\r\n        }\r\n        return this;\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/const.ts\n// name:    const.ts\r\n// author:  Jos Feenstra\r\n// purpose: Certain math constances\r\n// todo:    These are somewhat like the settings of the entire application. This could be expanded upon (json\'s, in-app functionalitiy)\r\nclass const_Const {\r\n    static IsRouglyZero(value) {\r\n        return Math.abs(value) < this.TOLERANCE;\r\n    }\r\n}\r\nconst_Const.TOLERANCE = 0.0001; // tolerance used for determining if 1 value is the same as some other value, relatively speaking\r\nconst_Const.TOL_SQUARED = Math.pow(const_Const.TOLERANCE, 2);\r\nconst_Const.MAX_U16 = 65536;\r\n// ----- Line Render Settings -----\r\nconst_Const.PLANE_RENDER_LINECOUNT = 9;\r\nconst_Const.PLANE_RENDER_LINEDISTANCE = 0.3;\r\nconst_Const.CIRCLE_SEGMENTS = 100;\r\n\n;// CONCATENATED MODULE: ./src/math/math.ts\n// purpose: simple operations with only numbers\r\nclass GeonMath {\r\n    // make sure \'value\' is more than \'lower\', and less than \'upper\'\r\n    static clamp(value, lower, upper) {\r\n        return Math.min(Math.max(value, lower), upper);\r\n    }\r\n    static fade(t) {\r\n        // Fade function as defined by Ken Perlin.  This eases coordinate values\r\n        // so that they will ease towards integral values.  This ends up smoothing\r\n        // the final output.\r\n        return t * t * t * (t * (t * 6 - 15) + 10); // 6t^5 - 15t^4 + 10t^3\r\n    }\r\n    static lerp(a, b, x) {\r\n        return a + x * (b - a);\r\n    }\r\n    static radToDeg(r) {\r\n        return (r * 180) / Math.PI;\r\n    }\r\n    static degToRad(d) {\r\n        return (d * Math.PI) / 180;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/data/float-matrix.ts\n// generic all-pupose matrix of floats\r\nclass float_matrix_FloatMatrix {\r\n    constructor(height, width, data = []) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this.data = new Float32Array(this._width * this._height);\r\n        if (data == [] || data.length == 0)\r\n            this.fill(0);\r\n        else\r\n            this.setData(data);\r\n    }\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this._height; i++) {\r\n            strings.push("|");\r\n            for (var j = 0; j < this._width; j++) {\r\n                let str = this.get(i, j).toFixed(2);\r\n                str = str.padStart(WIDTH, " ");\r\n                strings.push(str);\r\n                if (j < this._width - 2) {\r\n                    strings.push("  ");\r\n                }\r\n            }\r\n            strings.push("  |\\n");\r\n        }\r\n        console.log(strings.join(""));\r\n    }\r\n    clone() {\r\n        let clone = new float_matrix_FloatMatrix(this._height, this._width);\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            clone.data[i] = this.data[i];\r\n        }\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this._height * this._width)\r\n            throw "data.length does not match width * height " + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for \'how many of x?\' they usually mean this.\r\n        return this._height;\r\n    }\r\n    getDimensions() {\r\n        return [this._height, this._width];\r\n    }\r\n    fill(value) {\r\n        let size = this._height * this._width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this._width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this._width)\r\n            throw "values per entry is larger than this._width. This will spill over.";\r\n        for (let i = 0; i < this._height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    get(i, j) {\r\n        return this.data[i * this._width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw "column is out of bounds for FloatArray"\r\n        let data = new Float32Array(this._width);\r\n        for (let j = 0; j < this._width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw "column is out of bounds for FloatArray"\r\n        let data = new Float32Array(this._height);\r\n        for (let i = 0; i < this._height; i++) {\r\n            let index = i * this._width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        this.data[i * this._width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw "dimention of floatarray is not " + row.length;\r\n        for (let j = 0; j < this._width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    takeRows(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = new float_matrix_FloatMatrix(count, this._width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    // create a new floatmatrix, processed by iterating\r\n    mapWith(other, callback) {\r\n        let result = this.clone();\r\n        let width = Math.min(this._width, other._height);\r\n        let height = Math.min(this._height, other._height);\r\n        for (var i = 0; i < height; i++) {\r\n            for (var j = 0; j < width; j++) {\r\n                result.set(i, j, callback(this.get(i, j), other.get(i, j)));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // generalized multiplication\r\n    multiply(b) {\r\n        let a = this;\r\n        if (b._width !== a._height) {\r\n            throw new Error("Columns in A should be the same as the number of rows in B");\r\n        }\r\n        var product = new float_matrix_FloatMatrix(a._height, b._width);\r\n        for (var i = 0; i < product._height; i++) {\r\n            for (var j = 0; j < b._width; j++) {\r\n                for (var k = 0; k < a._width; k++) {\r\n                    product.set(i, j, product.get(i, j) + a.get(i, k) * b.get(k, j));\r\n                }\r\n            }\r\n        }\r\n        return product;\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        let height = native.length;\r\n        let width = native[0].length;\r\n        let matrix = new float_matrix_FloatMatrix(height, width);\r\n        for (var i = 0; i < native.length; i++) {\r\n            for (var j = 0; j < native[0].length; j++) {\r\n                matrix.set(i, j, native[i][j]);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    toNative() {\r\n        let native = [];\r\n        for (var i = 0; i < this._height; i++) {\r\n            native[i] = [];\r\n            for (var j = 0; j < this._width; j++) {\r\n                native[i][j] = this.get(i, j);\r\n            }\r\n        }\r\n        return native;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/matrix.ts\n// matrix\r\n// author: Jos Feenstra\r\n// TODO: FIX MATRIX4 !!!\r\n// NOTE:\r\n\r\n\r\n// 3x3 matrix of floats used for 2d math\r\n// inspired by Gregg Tavares.\r\nclass Matrix3 extends (/* unused pure expression or super */ null && (FloatMatrix)) {\r\n    constructor(data = []) {\r\n        super(3, 3, data);\r\n    }\r\n    static newIdentity() {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);\r\n    }\r\n    static newProjection(width, height) {\r\n        // Note: This matrix flips the Y axis so 0 is at the top.\r\n        return new Matrix3([2 / width, 0, 0, 0, -2 / height, 0, -1, 1, 1]);\r\n    }\r\n    static newTranslation(dx, dy) {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, dx, dy, 1]);\r\n    }\r\n    // angle in radians\r\n    static newRotation(r) {\r\n        var c = Math.cos(r);\r\n        var s = Math.sin(r);\r\n        return new Matrix3([c, -s, 0, s, c, 0, 0, 0, 1]);\r\n    }\r\n    static newScalar(sx, sy) {\r\n        return new Matrix3([sx, 0, 0, 0, sy, 0, 0, 0, 1]);\r\n    }\r\n    toMat4() {\r\n        let d = this.data;\r\n        return new matrix_Matrix4([\r\n            d[0],\r\n            d[1],\r\n            0,\r\n            d[2],\r\n            d[3],\r\n            d[4],\r\n            0,\r\n            d[5],\r\n            0,\r\n            0,\r\n            1,\r\n            0,\r\n            d[6],\r\n            d[7],\r\n            0,\r\n            d[8],\r\n        ]);\r\n    }\r\n    project(width, height) {\r\n        return this.multiply(Matrix3.newProjection(width, height));\r\n    }\r\n    translateN(dx, dy) {\r\n        return this.multiply(Matrix3.newTranslation(dx, dy));\r\n    }\r\n    translate(v) {\r\n        return this.multiply(Matrix3.newTranslation(v.x, v.y));\r\n    }\r\n    rotate(r) {\r\n        return this.multiply(Matrix3.newRotation(r));\r\n    }\r\n    scale(sx, sy) {\r\n        return this.multiply(Matrix3.newScalar(sx, sy));\r\n    }\r\n    // multiply two m3\'s\r\n    multiply(other) {\r\n        let a = this.data;\r\n        let b = other.data;\r\n        var a00 = a[0 * 3 + 0];\r\n        var a01 = a[0 * 3 + 1];\r\n        var a02 = a[0 * 3 + 2];\r\n        var a10 = a[1 * 3 + 0];\r\n        var a11 = a[1 * 3 + 1];\r\n        var a12 = a[1 * 3 + 2];\r\n        var a20 = a[2 * 3 + 0];\r\n        var a21 = a[2 * 3 + 1];\r\n        var a22 = a[2 * 3 + 2];\r\n        var b00 = b[0 * 3 + 0];\r\n        var b01 = b[0 * 3 + 1];\r\n        var b02 = b[0 * 3 + 2];\r\n        var b10 = b[1 * 3 + 0];\r\n        var b11 = b[1 * 3 + 1];\r\n        var b12 = b[1 * 3 + 2];\r\n        var b20 = b[2 * 3 + 0];\r\n        var b21 = b[2 * 3 + 1];\r\n        var b22 = b[2 * 3 + 2];\r\n        return new Matrix3([\r\n            b00 * a00 + b01 * a10 + b02 * a20,\r\n            b00 * a01 + b01 * a11 + b02 * a21,\r\n            b00 * a02 + b01 * a12 + b02 * a22,\r\n            b10 * a00 + b11 * a10 + b12 * a20,\r\n            b10 * a01 + b11 * a11 + b12 * a21,\r\n            b10 * a02 + b11 * a12 + b12 * a22,\r\n            b20 * a00 + b21 * a10 + b22 * a20,\r\n            b20 * a01 + b21 * a11 + b22 * a21,\r\n            b20 * a02 + b21 * a12 + b22 * a22,\r\n        ]);\r\n    }\r\n    // transform a vector. RECYCLE IT\r\n    transformVector(v) {\r\n        let m = this.data;\r\n        let v0 = v.x;\r\n        let v1 = v.y;\r\n        let d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];\r\n        v.x = (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d;\r\n        v.y = (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d;\r\n        return v;\r\n    }\r\n    // return the inverse of this matrix\r\n    inverse() {\r\n        // ive got no idea what is happening here,\r\n        // but apparantly, this is how you inverse a 3x3 matrix.\r\n        let m = this.data;\r\n        var t00 = m[1 * 3 + 1] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 1];\r\n        var t10 = m[0 * 3 + 1] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 1];\r\n        var t20 = m[0 * 3 + 1] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 1];\r\n        // discriminant\r\n        var d = 1.0 / (m[0 * 3 + 0] * t00 - m[1 * 3 + 0] * t10 + m[2 * 3 + 0] * t20);\r\n        this.setData([\r\n            d * t00,\r\n            -d * t10,\r\n            d * t20,\r\n            -d * (m[1 * 3 + 0] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 0]),\r\n            d * (m[1 * 3 + 0] * m[2 * 3 + 1] - m[1 * 3 + 1] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[2 * 3 + 1] - m[0 * 3 + 1] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[1 * 3 + 1] - m[0 * 3 + 1] * m[1 * 3 + 0]),\r\n        ]);\r\n        return this;\r\n    }\r\n}\r\n// 4x4 matrix of floats used for 3d math\r\n// inspired by Gregg Tavares.\r\nclass matrix_Matrix4 extends float_matrix_FloatMatrix {\r\n    constructor(data = []) {\r\n        super(4, 4, data);\r\n    }\r\n    static new(data) {\r\n        return new matrix_Matrix4(data);\r\n    }\r\n    static newIdentity() {\r\n        return new matrix_Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newCopy(other) {\r\n        let result = new matrix_Matrix4();\r\n        for (let i = 0; i < 16; i++) {\r\n            result.data[i] = other.data[i];\r\n        }\r\n        return result;\r\n    }\r\n    clone() {\r\n        return matrix_Matrix4.newCopy(this);\r\n    }\r\n    multiplied(other) {\r\n        // NOTE: i swapped a and b, this makes more sense to me, but i could be wrong about it...\r\n        const a = other.data;\r\n        const b = this.data;\r\n        var b00 = b[0 * 4 + 0];\r\n        var b01 = b[0 * 4 + 1];\r\n        var b02 = b[0 * 4 + 2];\r\n        var b03 = b[0 * 4 + 3];\r\n        var b10 = b[1 * 4 + 0];\r\n        var b11 = b[1 * 4 + 1];\r\n        var b12 = b[1 * 4 + 2];\r\n        var b13 = b[1 * 4 + 3];\r\n        var b20 = b[2 * 4 + 0];\r\n        var b21 = b[2 * 4 + 1];\r\n        var b22 = b[2 * 4 + 2];\r\n        var b23 = b[2 * 4 + 3];\r\n        var b30 = b[3 * 4 + 0];\r\n        var b31 = b[3 * 4 + 1];\r\n        var b32 = b[3 * 4 + 2];\r\n        var b33 = b[3 * 4 + 3];\r\n        var a00 = a[0 * 4 + 0];\r\n        var a01 = a[0 * 4 + 1];\r\n        var a02 = a[0 * 4 + 2];\r\n        var a03 = a[0 * 4 + 3];\r\n        var a10 = a[1 * 4 + 0];\r\n        var a11 = a[1 * 4 + 1];\r\n        var a12 = a[1 * 4 + 2];\r\n        var a13 = a[1 * 4 + 3];\r\n        var a20 = a[2 * 4 + 0];\r\n        var a21 = a[2 * 4 + 1];\r\n        var a22 = a[2 * 4 + 2];\r\n        var a23 = a[2 * 4 + 3];\r\n        var a30 = a[3 * 4 + 0];\r\n        var a31 = a[3 * 4 + 1];\r\n        var a32 = a[3 * 4 + 2];\r\n        var a33 = a[3 * 4 + 3];\r\n        return new matrix_Matrix4([\r\n            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n            b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n            b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n            b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n        ]);\r\n    }\r\n    multiply(other) {\r\n        this.data = this.multiplied(other).data;\r\n        return this;\r\n    }\r\n    transpose() {\r\n        let matrix = new matrix_Matrix4();\r\n        let res = matrix.data;\r\n        let old = this.data;\r\n        res[0] = old[0];\r\n        res[1] = old[4];\r\n        res[2] = old[8];\r\n        res[3] = old[12];\r\n        res[4] = old[1];\r\n        res[5] = old[5];\r\n        res[6] = old[9];\r\n        res[7] = old[13];\r\n        res[8] = old[2];\r\n        res[9] = old[6];\r\n        res[10] = old[10];\r\n        res[11] = old[14];\r\n        res[12] = old[3];\r\n        res[13] = old[7];\r\n        res[14] = old[11];\r\n        res[15] = old[15];\r\n        return matrix;\r\n    }\r\n    static newLookAt(cameraPosition, target, up) {\r\n        let matrix = new matrix_Matrix4();\r\n        let data = matrix.data;\r\n        let zAxis = cameraPosition.clone().sub(target).normalize();\r\n        let xAxis = up.clone().cross(up).normalize();\r\n        let yAxis = zAxis.clone().cross(xAxis).normalize();\r\n        data[0] = xAxis.x;\r\n        data[1] = xAxis.y;\r\n        data[2] = xAxis.z;\r\n        data[3] = 0;\r\n        data[4] = yAxis.x;\r\n        data[5] = yAxis.y;\r\n        data[6] = yAxis.z;\r\n        data[7] = 0;\r\n        data[8] = zAxis.x;\r\n        data[9] = zAxis.y;\r\n        data[10] = zAxis.z;\r\n        data[11] = 0;\r\n        data[12] = cameraPosition.x;\r\n        data[13] = cameraPosition.y;\r\n        data[14] = cameraPosition.z;\r\n        data[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\r\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\r\n     * arguments define a frustum extending in the negative z direction.  The given\r\n     * angle is the vertical angle of the frustum, and the horizontal angle is\r\n     * determined to produce the given aspect ratio.  The arguments near and far are\r\n     * the distances to the near and far clipping planes.  Note that near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\r\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n     * from -1 to 1 in the z dimension.\r\n     * @param {number} fieldOfViewInRadians field of view in y axis.\r\n     * @param {number} aspect aspect of viewport (width / height)\r\n     * @param {number} near near Z clipping plane\r\n     * @param {number} far far Z clipping plane\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newPerspective(fov, aspect, near, far) {\r\n        let matrix = new matrix_Matrix4();\r\n        let data = matrix.data;\r\n        var f = Math.tan(Math.PI * 0.5 - 0.5 * fov);\r\n        var rangeInv = 1.0 / (near - far);\r\n        data[0] = f / aspect;\r\n        data[1] = 0;\r\n        data[2] = 0;\r\n        data[3] = 0;\r\n        data[4] = 0;\r\n        data[5] = f;\r\n        data[6] = 0;\r\n        data[7] = 0;\r\n        data[8] = 0;\r\n        data[9] = 0;\r\n        data[10] = (near + far) * rangeInv;\r\n        data[11] = -1;\r\n        data[12] = 0;\r\n        data[13] = 0;\r\n        data[14] = near * far * rangeInv * 2;\r\n        data[15] = 0;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 orthographic projection matrix given the coordinates of the\r\n     * planes defining the axis-aligned, box-shaped viewing volume.  The matrix\r\n     * generated sends that box to the unit box.  Note that although left and right\r\n     * are x coordinates and bottom and top are y coordinates, near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  We assume a unit box extending from -1 to 1 in the x and y\r\n     * dimensions and from -1 to 1 in the z dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newOrthographic(left, right, bottom, top, near, far) {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        dst[0] = 2 / (right - left);\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = 2 / (top - bottom);\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 2 / (near - far);\r\n        dst[11] = 0;\r\n        dst[12] = (left + right) / (left - right);\r\n        dst[13] = (bottom + top) / (bottom - top);\r\n        dst[14] = (near + far) / (near - far);\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\r\n     * top, bottom, near and far clipping planes. The arguments define a frustum\r\n     * extending in the negative z direction. The arguments near and far are the\r\n     * distances to the near and far clipping planes. Note that near and far are not\r\n     * z coordinates, but rather they are distances along the negative z-axis. The\r\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\r\n     * box extending from -1 to 1 in the x and y dimensions and from -1 to 1 in the z\r\n     * dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newFrustum(left, right, bottom, top, near, far) {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        dst[0] = (2 * near) / dx;\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = (2 * near) / dy;\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = (left + right) / dx;\r\n        dst[9] = (top + bottom) / dy;\r\n        dst[10] = -(far + near) / dz;\r\n        dst[11] = -1;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = (-2 * near * far) / dz;\r\n        dst[15] = 0;\r\n        return matrix;\r\n    }\r\n    static newTranslation(tx, ty, tz) {\r\n        return new matrix_Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);\r\n    }\r\n    static newXRotation(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        return new matrix_Matrix4([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newYRotation(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        return new matrix_Matrix4([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newZRotation(angleInRadians) {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        dst[0] = c;\r\n        dst[1] = s;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = -s;\r\n        dst[5] = c;\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 1;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Makes an rotation matrix around an arbitrary axis\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newAxisRotation(axis, angleInRadians) {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        let x = axis.x;\r\n        let y = axis.y;\r\n        let z = axis.z;\r\n        let n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let c = Math.cos(angleInRadians);\r\n        let s = Math.sin(angleInRadians);\r\n        let oneMinusCosine = 1 - c;\r\n        dst[0] = xx + (1 - xx) * c;\r\n        dst[1] = x * y * oneMinusCosine + z * s;\r\n        dst[2] = x * z * oneMinusCosine - y * s;\r\n        dst[3] = 0;\r\n        dst[4] = x * y * oneMinusCosine - z * s;\r\n        dst[5] = yy + (1 - yy) * c;\r\n        dst[6] = y * z * oneMinusCosine + x * s;\r\n        dst[7] = 0;\r\n        dst[8] = x * z * oneMinusCosine + y * s;\r\n        dst[9] = y * z * oneMinusCosine - x * s;\r\n        dst[10] = zz + (1 - zz) * c;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Multiply by an axis rotation matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    axisRotate(axis, angleInRadians) {\r\n        // This is the optimized version of\r\n        // return multiply(m, axisRotation(axis, angleInRadians), dst);\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        var xx = x * x;\r\n        var yy = y * y;\r\n        var zz = z * z;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        var oneMinusCosine = 1 - c;\r\n        var r00 = xx + (1 - xx) * c;\r\n        var r01 = x * y * oneMinusCosine + z * s;\r\n        var r02 = x * z * oneMinusCosine - y * s;\r\n        var r10 = x * y * oneMinusCosine - z * s;\r\n        var r11 = yy + (1 - yy) * c;\r\n        var r12 = y * z * oneMinusCosine + x * s;\r\n        var r20 = x * z * oneMinusCosine + y * s;\r\n        var r21 = y * z * oneMinusCosine - x * s;\r\n        var r22 = zz + (1 - zz) * c;\r\n        var m00 = m[0];\r\n        var m01 = m[1];\r\n        var m02 = m[2];\r\n        var m03 = m[3];\r\n        var m10 = m[4];\r\n        var m11 = m[5];\r\n        var m12 = m[6];\r\n        var m13 = m[7];\r\n        var m20 = m[8];\r\n        var m21 = m[9];\r\n        var m22 = m[10];\r\n        var m23 = m[11];\r\n        dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\r\n        dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\r\n        dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\r\n        dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\r\n        dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\r\n        dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\r\n        dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\r\n        dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\r\n        dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\r\n        dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\r\n        dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\r\n        dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    // make a scaling matrix\r\n    static newScaler(sx, sy, sz) {\r\n        return new matrix_Matrix4([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);\r\n    }\r\n    /**\r\n     * Multiply by a scaling matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {number} sx x scale.\r\n     * @param {number} sy y scale.\r\n     * @param {number} sz z scale.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    scale(sx, sy, sz) {\r\n        // This is the optimized version of\r\n        // return multiply(m, scaling(sx, sy, sz), dst);\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        dst[0] = sx * m[0 * 4 + 0];\r\n        dst[1] = sx * m[0 * 4 + 1];\r\n        dst[2] = sx * m[0 * 4 + 2];\r\n        dst[3] = sx * m[0 * 4 + 3];\r\n        dst[4] = sy * m[1 * 4 + 0];\r\n        dst[5] = sy * m[1 * 4 + 1];\r\n        dst[6] = sy * m[1 * 4 + 2];\r\n        dst[7] = sy * m[1 * 4 + 3];\r\n        dst[8] = sz * m[2 * 4 + 0];\r\n        dst[9] = sz * m[2 * 4 + 1];\r\n        dst[10] = sz * m[2 * 4 + 2];\r\n        dst[11] = sz * m[2 * 4 + 3];\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    /**\r\n     * creates a matrix from translation, quaternion, scale\r\n     * @param {Number[]} translation [x, y, z] translation\r\n     * @param {Number[]} quaternion [x, y, z, z] quaternion rotation\r\n     * @param {Number[]} scale [x, y, z] scale\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    newCompose(translation, quaternion, scale) {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        const x = quaternion.x;\r\n        const y = quaternion.y;\r\n        const z = quaternion.z;\r\n        const w = quaternion.w;\r\n        const x2 = x + x;\r\n        const y2 = y + y;\r\n        const z2 = z + z;\r\n        const xx = x * x2;\r\n        const xy = x * y2;\r\n        const xz = x * z2;\r\n        const yy = y * y2;\r\n        const yz = y * z2;\r\n        const zz = z * z2;\r\n        const wx = w * x2;\r\n        const wy = w * y2;\r\n        const wz = w * z2;\r\n        const sx = scale.x;\r\n        const sy = scale.y;\r\n        const sz = scale.z;\r\n        dst[0] = (1 - (yy + zz)) * sx;\r\n        dst[1] = (xy + wz) * sx;\r\n        dst[2] = (xz - wy) * sx;\r\n        dst[3] = 0;\r\n        dst[4] = (xy - wz) * sy;\r\n        dst[5] = (1 - (xx + zz)) * sy;\r\n        dst[6] = (yz + wx) * sy;\r\n        dst[7] = 0;\r\n        dst[8] = (xz + wy) * sz;\r\n        dst[9] = (yz - wx) * sz;\r\n        dst[10] = (1 - (xx + yy)) * sz;\r\n        dst[11] = 0;\r\n        dst[12] = translation.x;\r\n        dst[13] = translation.y;\r\n        dst[14] = translation.z;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    // quatFromRotationMatrix() {\r\n    //     // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n    //     // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n    //     const m11 = m[0];\r\n    //     const m12 = m[4];\r\n    //     const m13 = m[8];\r\n    //     const m21 = m[1];\r\n    //     const m22 = m[5];\r\n    //     const m23 = m[9];\r\n    //     const m31 = m[2];\r\n    //     const m32 = m[6];\r\n    //     const m33 = m[10];\r\n    //     const trace = m11 + m22 + m33;\r\n    //     if (trace > 0) {\r\n    //         const s = 0.5 / Math.sqrt(trace + 1);\r\n    //         dst[3] = 0.25 / s;\r\n    //         dst[0] = (m32 - m23) * s;\r\n    //         dst[1] = (m13 - m31) * s;\r\n    //         dst[2] = (m21 - m12) * s;\r\n    //     } else if (m11 > m22 && m11 > m33) {\r\n    //         const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\r\n    //         dst[3] = (m32 - m23) / s;\r\n    //         dst[0] = 0.25 * s;\r\n    //         dst[1] = (m12 + m21) / s;\r\n    //         dst[2] = (m13 + m31) / s;\r\n    //     } else if (m22 > m33) {\r\n    //         const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\r\n    //         dst[3] = (m13 - m31) / s;\r\n    //         dst[0] = (m12 + m21) / s;\r\n    //         dst[1] = 0.25 * s;\r\n    //         dst[2] = (m23 + m32) / s;\r\n    //     } else {\r\n    //         const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\r\n    //         dst[3] = (m21 - m12) / s;\r\n    //         dst[0] = (m13 + m31) / s;\r\n    //         dst[1] = (m23 + m32) / s;\r\n    //         dst[2] = 0.25 * s;\r\n    //     }\r\n    // }\r\n    // decompose(mat, translation, quaternion, scale) {\r\n    //     let sx = m4.length(mat.slice(0, 3));\r\n    //     const sy = m4.length(mat.slice(4, 7));\r\n    //     const sz = m4.length(mat.slice(8, 11));\r\n    //     // if determinate is negative, we need to invert one scale\r\n    //     const det = determinate(mat);\r\n    //     if (det < 0) {\r\n    //         sx = -sx;\r\n    //     }\r\n    //     translation[0] = mat[12];\r\n    //     translation[1] = mat[13];\r\n    //     translation[2] = mat[14];\r\n    //     // scale the rotation part\r\n    //     const matrix = m4.copy(mat);\r\n    //     const invSX = 1 / sx;\r\n    //     const invSY = 1 / sy;\r\n    //     const invSZ = 1 / sz;\r\n    //     matrix[0] *= invSX;\r\n    //     matrix[1] *= invSX;\r\n    //     matrix[2] *= invSX;\r\n    //     matrix[4] *= invSY;\r\n    //     matrix[5] *= invSY;\r\n    //     matrix[6] *= invSY;\r\n    //     matrix[8] *= invSZ;\r\n    //     matrix[9] *= invSZ;\r\n    //     matrix[10] *= invSZ;\r\n    //     quatFromRotationMatrix(matrix, quaternion);\r\n    //     scale[0] = sx;\r\n    //     scale[1] = sy;\r\n    //     scale[2] = sz;\r\n    // }\r\n    determinate() {\r\n        let m = this.data;\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0 = m22 * m33;\r\n        var tmp_1 = m32 * m23;\r\n        var tmp_2 = m12 * m33;\r\n        var tmp_3 = m32 * m13;\r\n        var tmp_4 = m12 * m23;\r\n        var tmp_5 = m22 * m13;\r\n        var tmp_6 = m02 * m33;\r\n        var tmp_7 = m32 * m03;\r\n        var tmp_8 = m02 * m23;\r\n        var tmp_9 = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        return 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    }\r\n    inverse() {\r\n        let matrix = new matrix_Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0 = m22 * m33;\r\n        var tmp_1 = m32 * m23;\r\n        var tmp_2 = m12 * m33;\r\n        var tmp_3 = m32 * m13;\r\n        var tmp_4 = m12 * m23;\r\n        var tmp_5 = m22 * m13;\r\n        var tmp_6 = m02 * m33;\r\n        var tmp_7 = m32 * m03;\r\n        var tmp_8 = m02 * m23;\r\n        var tmp_9 = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var tmp_12 = m20 * m31;\r\n        var tmp_13 = m30 * m21;\r\n        var tmp_14 = m10 * m31;\r\n        var tmp_15 = m30 * m11;\r\n        var tmp_16 = m10 * m21;\r\n        var tmp_17 = m20 * m11;\r\n        var tmp_18 = m00 * m31;\r\n        var tmp_19 = m30 * m01;\r\n        var tmp_20 = m00 * m21;\r\n        var tmp_21 = m20 * m01;\r\n        var tmp_22 = m00 * m11;\r\n        var tmp_23 = m10 * m01;\r\n        var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n        dst[0] = d * t0;\r\n        dst[1] = d * t1;\r\n        dst[2] = d * t2;\r\n        dst[3] = d * t3;\r\n        dst[4] =\r\n            d *\r\n                (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\r\n        dst[5] =\r\n            d *\r\n                (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\r\n        dst[6] =\r\n            d *\r\n                (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\r\n        dst[7] =\r\n            d *\r\n                (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\r\n        dst[8] =\r\n            d *\r\n                (tmp_12 * m13 +\r\n                    tmp_15 * m23 +\r\n                    tmp_16 * m33 -\r\n                    (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\r\n        dst[9] =\r\n            d *\r\n                (tmp_13 * m03 +\r\n                    tmp_18 * m23 +\r\n                    tmp_21 * m33 -\r\n                    (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\r\n        dst[10] =\r\n            d *\r\n                (tmp_14 * m03 +\r\n                    tmp_19 * m13 +\r\n                    tmp_22 * m33 -\r\n                    (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\r\n        dst[11] =\r\n            d *\r\n                (tmp_17 * m03 +\r\n                    tmp_20 * m13 +\r\n                    tmp_23 * m23 -\r\n                    (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\r\n        dst[12] =\r\n            d *\r\n                (tmp_14 * m22 +\r\n                    tmp_17 * m32 +\r\n                    tmp_13 * m12 -\r\n                    (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\r\n        dst[13] =\r\n            d *\r\n                (tmp_20 * m32 +\r\n                    tmp_12 * m02 +\r\n                    tmp_19 * m22 -\r\n                    (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\r\n        dst[14] =\r\n            d *\r\n                (tmp_18 * m12 +\r\n                    tmp_23 * m32 +\r\n                    tmp_15 * m02 -\r\n                    (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\r\n        dst[15] =\r\n            d *\r\n                (tmp_22 * m22 +\r\n                    tmp_16 * m02 +\r\n                    tmp_21 * m12 -\r\n                    (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\r\n        return matrix;\r\n    }\r\n    multiplyVector(v) {\r\n        let data = new Array(3);\r\n        for (var i = 0; i < 3; ++i) {\r\n            data[i] = 0.0;\r\n            for (var j = 0; j < 4; ++j) {\r\n                data[i] += v.item(j) * this.get(j, i);\r\n            }\r\n        }\r\n        return new vector_Vector3(data[0], data[1], data[2]);\r\n    }\r\n    multiplyVectors(other) {\r\n        // dumb way\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let vec = other.getVector(i);\r\n            vec = this.multiplyVector(vec);\r\n            other.setVector(i, vec);\r\n        }\r\n        return other;\r\n        // smart way\r\n        // let matrix = new Vector3Array(other.count());\r\n        // // for every row\r\n        // for (var r = 0; r < other.count(); r++) {\r\n        //     // for every item in row\r\n        //     for (var c = 0; c < 3; ++c) {\r\n        //         let item = 0.0;\r\n        //         for (var j = 0; j < 4; ++j) {\r\n        //             item += other.get(r, c) * this.get(j, c);\r\n        //         }\r\n        //         matrix.set(r, c, item);\r\n        //     }\r\n        // }\r\n        // other.data = matrix.data;\r\n        return other;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/util.ts\nclass Util {\r\n    static range(n) {\r\n        let array = [];\r\n        for (let i = 0; i < n; i++) {\r\n            array.push(i);\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/vector.ts\n// author: \tJos Feenstra\r\n// inspiration from Three.js\r\n// note: \trecycle the class as much as possble, building a new class is expensive,\r\n// \t\t\tespecially in javascript\r\n// todo: \tBIJ NADER INZIEN: dont go the copy route. rewrite this in a more functional way creating new classes is expensive, but we really need immutable vectors.\r\n// \t\t\tthese types of consistent vectors are only useful in niche cases, and complitate a lot of common cases.\r\n\r\n\r\n\r\n\r\nclass vector_Vector3 {\r\n    // #region constructors\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static new(x, y, z) {\r\n        return new vector_Vector3(x, y, z);\r\n    }\r\n    static calculateWheelOrder(vectors, ihat, jhat) {\r\n        // console.log("wheel order");\r\n        // console.log("hats", ihat, jhat)\r\n        let angles = [];\r\n        vectors.forEach((v) => {\r\n            angles.push(new vector_Vector2(v.dot(ihat), v.dot(jhat)).angle());\r\n        });\r\n        // console.log("angles", angles);\r\n        let ids = Util.range(vectors.length);\r\n        ids.sort((a, b) => {\r\n            return angles[a] - angles[b];\r\n        });\r\n        return ids;\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new vector_Vector3(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha, v1.z + (v2.z - v1.z) * alpha);\r\n    }\r\n    static fromArray(a) {\r\n        return new vector_Vector3(a[0], a[1], a[2]);\r\n    }\r\n    static fromRandom() {\r\n        return new vector_Vector3(Math.random(), Math.random(), Math.random());\r\n    }\r\n    static fromSphere(radius, theta, phi) {\r\n        const sinPhiRadius = Math.sin(phi) * radius;\r\n        return this.constructor(sinPhiRadius * Math.sin(theta), Math.cos(phi) * radius, sinPhiRadius * Math.cos(theta));\r\n    }\r\n    static fromCylinder(radius, theta, height) {\r\n        return this.constructor(radius * Math.sin(theta), height, radius * Math.cos(theta));\r\n    }\r\n    static fromLerpWeights(p1, p2, tP1, tP2, t) {\r\n        if (Math.abs(t - tP1) < 0.00001)\r\n            return p1;\r\n        if (Math.abs(t - tP2) < 0.00001)\r\n            return p2;\r\n        if (Math.abs(tP1 - tP2) < 0.00001)\r\n            return p1;\r\n        let mu = (t - tP1) / (tP2 - tP1);\r\n        return new vector_Vector3(p1.x + mu * (p2.x - p1.x), p1.y + mu * (p2.y - p1.y), p1.z + mu * (p2.z - p1.z));\r\n    }\r\n    // #endregion\r\n    // #region defaults\r\n    static zero() {\r\n        return new vector_Vector3(0, 0, 0);\r\n    }\r\n    static unitX() {\r\n        return new vector_Vector3(1, 0, 0);\r\n    }\r\n    static unitY() {\r\n        return new vector_Vector3(0, 1, 0);\r\n    }\r\n    static unitZ() {\r\n        return new vector_Vector3(0, 0, 1);\r\n    }\r\n    // #endregion\r\n    // #region basics\r\n    toArray() {\r\n        return new Float32Array([this.x, this.y, this.z]);\r\n    }\r\n    set(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y && v.z === this.z;\r\n    }\r\n    toString() {\r\n        return `Vector3(${this.x}, ${this.y}, ${this.z})`;\r\n    }\r\n    toVector2() {\r\n        return new vector_Vector2(this.x, this.y);\r\n    }\r\n    clone() {\r\n        return new vector_Vector3(this.x, this.y, this.z);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    }\r\n    to2D() {\r\n        return new vector_Vector2(this.x, this.y);\r\n    }\r\n    // #endregion\r\n    // #region math like vector2\r\n    largestValue() {\r\n        return Math.max(this.x, this.y, this.z);\r\n    }\r\n    added(v) {\r\n        return new vector_Vector3(this.x + v.x, this.y + v.y, this.z + v.z);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new vector_Vector3(this.x - v.x, this.y - v.y, this.z - v.z);\r\n    }\r\n    sub(v) {\r\n        (this.x -= v.x), (this.y -= v.y), (this.z -= v.z);\r\n        return this;\r\n    }\r\n    item(i) {\r\n        switch (i) {\r\n            case 0:\r\n                return this.x;\r\n            case 1:\r\n                return this.y;\r\n            case 2:\r\n                return this.z;\r\n            case 3:\r\n                return 1;\r\n            default:\r\n                throw "nope";\r\n        }\r\n    }\r\n    scaled(v) {\r\n        return new vector_Vector3(this.x * v, this.y * v, this.z * v);\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        this.z *= v;\r\n        return this;\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z;\r\n        return this;\r\n    }\r\n    multiplied(v) {\r\n        return new vector_Vector3(this.x * v.x, this.y * v.y, this.z * v.z);\r\n    }\r\n    divVector(v) {\r\n        return new vector_Vector3(this.x / v.x, this.y / v.y, this.z / v.z);\r\n    }\r\n    divided(value) {\r\n        return new vector_Vector3(this.x / value, this.y / value, this.z / value);\r\n    }\r\n    div(value) {\r\n        (this.x /= value), (this.y /= value), (this.z /= value);\r\n        return this;\r\n    }\r\n    minimumed(other) {\r\n        return new vector_Vector3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));\r\n    }\r\n    maximumed(other) {\r\n        return new vector_Vector3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));\r\n    }\r\n    clamped(min, max) {\r\n        return new vector_Vector3(Math.max(min.x, Math.min(max.x, this.x)), Math.max(min.y, Math.min(max.y, this.y)), Math.max(min.z, Math.min(max.z, this.z)));\r\n    }\r\n    clampScalared(min, max) {\r\n        return new vector_Vector3(GeonMath.clamp(this.x, min, max), GeonMath.clamp(this.y, min, max), GeonMath.clamp(this.z, min, max));\r\n    }\r\n    clampLengthed(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floored() {\r\n        return new vector_Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\r\n    }\r\n    ceiled() {\r\n        return new vector_Vector3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));\r\n    }\r\n    rounded() {\r\n        return new vector_Vector3(Math.round(this.x), Math.round(this.y), Math.round(this.z));\r\n    }\r\n    roundedToZero() {\r\n        return new vector_Vector3(this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z));\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        return this;\r\n    }\r\n    negated() {\r\n        return new vector_Vector3(-this.x, -this.y, -this.z);\r\n    }\r\n    angle(other, normal) {\r\n        let thisProjected = this.subbed(normal.scaled(this.dot(normal)));\r\n        let otherProjected = other.subbed(normal.scaled(other.dot(normal)));\r\n        console.log(thisProjected);\r\n        console.log(otherProjected);\r\n        return 0;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    }\r\n    cross(other) {\r\n        const ax = this.x, ay = this.y, az = this.z;\r\n        const bx = other.x, by = other.y, bz = other.z;\r\n        return new vector_Vector3(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);\r\n    }\r\n    getLengthSquared() {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.getLengthSquared());\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.divided(this.length() || 1);\r\n    }\r\n    isNormal() {\r\n        return Math.abs(this.length() - 1) < const_Const.TOLERANCE;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n        return dx * dx + dy * dy + dz * dz;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        return new vector_Vector3((other.x - this.x) * alpha, (other.y - this.y) * alpha, (other.z - this.z) * alpha);\r\n    }\r\n    // #endregion\r\n    // #region math specific\r\n    projectOnVector(other) {\r\n        // use dot product to project this vector on the other vector\r\n        const denominator = other.getLengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n    projectedOnPlane(normal) {\r\n        // project a vector\r\n        _vector.copy(this).projectOnVector(normal);\r\n        return this.minimumed(_vector);\r\n    }\r\n    mirrored(normal) {\r\n        // mirror incident vector off plane orthogonal to normal\r\n        // normal is assumed to have unit length\r\n        return this.minimumed(_vector.copy(normal).scale(2 * this.dot(normal)));\r\n    }\r\n    rotated(axis, angle) {\r\n        let mat = matrix_Matrix4.newAxisRotation(axis, angle);\r\n        return mat.multiplyVector(this);\r\n    }\r\n}\r\nconst _vector = new vector_Vector3(0, 0, 0);\r\nclass vector_Vector2 {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // --- factories & other statics\r\n    static fromArray(a) {\r\n        return new vector_Vector2(a[0], a[1]);\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new vector_Vector2(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha);\r\n    }\r\n    static fromRandom() {\r\n        return new vector_Vector2(Math.random(), Math.random());\r\n    }\r\n    static fromRandomAngle() {\r\n        let alpha = Math.random() * Math.PI * 2;\r\n        return new vector_Vector2(Math.cos(alpha), Math.sin(alpha));\r\n    }\r\n    // static from2Pt(from: Vector2, to: Vector2) : Vector2 {\r\n    // \treturn new Vector2(\r\n    // \t\tfrom.x - to.x,\r\n    // \t\tfrom.y - to.y\r\n    // \t)\r\n    // }\r\n    static fromCircle(center, radius, theta) {\r\n        return new vector_Vector2(center.x + radius * Math.sin(theta), center.y + radius * Math.cos(theta));\r\n    }\r\n    static fromCopy(other) {\r\n        return this.zero().copy(other);\r\n    }\r\n    static zero() {\r\n        return new vector_Vector2(0, 0);\r\n    }\r\n    static NaN() {\r\n        return new vector_Vector2(NaN, NaN);\r\n    }\r\n    static fromCircumcenter(a, b, c) {\r\n        const asum = a.squareSum();\r\n        const bsum = b.squareSum();\r\n        const csum = c.squareSum();\r\n        // sort of cross product\r\n        let d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\r\n        // if this triangle has no circumcenter?\r\n        if (d < 0.000001)\r\n            return vector_Vector2.NaN();\r\n        let x = (asum * (b.y - c.y) + bsum * (c.y - a.y) + csum * (a.y - b.y)) / d;\r\n        let y = (asum * (c.x - b.x) + bsum * (a.x - c.x) + csum * (b.x - a.x)) / d;\r\n        return new vector_Vector2(x, y);\r\n    }\r\n    static getSign(a, b, c) {\r\n        // test half plane relationship\r\n        // <0 : point on first half\r\n        // 0  : points collinear\r\n        // >0 : point on second half\r\n        return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n    }\r\n    // --- basics\r\n    to3D() {\r\n        return new vector_Vector3(this.x, this.y, 0);\r\n    }\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    roughlyEquals(v, tol) {\r\n        return Math.abs(this.x - v.x) < tol && Math.abs(this.y - v.y) < tol;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y;\r\n    }\r\n    toString() {\r\n        return `Vector2(${this.x}, ${this.y})`;\r\n    }\r\n    clone() {\r\n        return new vector_Vector2(this.x, this.y);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    }\r\n    // --- math\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        return this;\r\n    }\r\n    added(v) {\r\n        return new vector_Vector2(this.x + v.x, this.y + v.y);\r\n    }\r\n    addn(arg0, arg1) {\r\n        this.x += arg0;\r\n        this.y += arg1;\r\n        return this;\r\n    }\r\n    sub(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new vector_Vector2(this.x - v.x, this.y - v.y);\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        return this;\r\n    }\r\n    scaled(v) {\r\n        return new vector_Vector2(this.x * v, this.y * v);\r\n    }\r\n    divVector(v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    }\r\n    div(v) {\r\n        this.x /= v;\r\n        this.y /= v;\r\n        return this;\r\n    }\r\n    dived(v) {\r\n        return new vector_Vector2(this.x / v, this.y / v);\r\n    }\r\n    minimum(other) {\r\n        this.x = Math.min(this.x, other.x);\r\n        this.y = Math.min(this.y, other.y);\r\n        return this;\r\n    }\r\n    maximum(other) {\r\n        this.x = Math.max(this.x, other.x);\r\n        this.y = Math.max(this.y, other.y);\r\n        return this;\r\n    }\r\n    clamp(min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        return this;\r\n    }\r\n    clampScalar(minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        return this;\r\n    }\r\n    clampLength(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floor() {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        return this;\r\n    }\r\n    ceil() {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        return this;\r\n    }\r\n    round() {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    }\r\n    roundToZero() {\r\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\r\n        return this;\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    }\r\n    cross(v) {\r\n        return this.x * v.y - this.y * v.x; // ????\r\n    }\r\n    squareSum() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.lengthSquared());\r\n    }\r\n    lengthSquared() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.dived(this.length() || 1);\r\n    }\r\n    angle() {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n        const angle = Math.atan2(-this.y, -this.x) + Math.PI;\r\n        return angle;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        let dx = this.x - v.x;\r\n        let dy = this.y - v.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        return new vector_Vector2(this.x + (other.x - this.x) * alpha, this.y + (other.y - this.y) * alpha);\r\n    }\r\n    // calculate the \'triangle sign\' of three points. Can be used to determine clockwise & counter clockwise\r\n    sign(b, c) {\r\n        return (this.x - c.x) * (b.y - c.y) - (b.x - c.x) * (this.y - c.y);\r\n    }\r\n    // use dot product to project this vector on the other vector\r\n    projectOnVector(other) {\r\n        const denominator = other.lengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/data/vector-array.ts\n// name:    array.ts\r\n// author:  Jos Feenstra\r\n// purpose: Small wrapper around Float32Array / FloatMatrix to add interoperability with Vector2 & Vector3,\r\n//          while remaining a datastructure thats easy to pass over to webgl\r\n//\r\n// NOTE:    all these small wrappers might not be good pratice, but I\r\n//          like to extract simple logic like this to not clutter the code too much\r\n\r\n\r\nclass vector_array_Vector2Array extends float_matrix_FloatMatrix {\r\n    constructor(count) {\r\n        super(count, 2);\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let array = new vector_array_Vector2Array(length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            array.data[i * 2] = vecs[i].x;\r\n            array.data[i * 2 + 1] = vecs[i].y;\r\n        }\r\n        return array;\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let vec = this.getVector(i);\r\n            callbackfn(vec, i);\r\n            this.setVector(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    map(callbackfn) {\r\n        let clone = this.clone();\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let vec = this.getVector(i);\r\n            let result = callbackfn(vec, i);\r\n            if (result instanceof vector_Vector2) {\r\n                clone.setVector(i, result);\r\n            }\r\n            else {\r\n                clone.setVector(i, vec);\r\n            }\r\n        }\r\n        return clone;\r\n    }\r\n    setVector(i, vec) {\r\n        this.data[i * this._width + 0] = vec.x;\r\n        this.data[i * this._width + 1] = vec.y;\r\n    }\r\n    getVector(i) {\r\n        return new vector_Vector2(this.data[i * this._width + 0], this.data[i * this._width + 1]);\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this._height; i++) {\r\n            vecs.push(this.getVector(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    to3D() {\r\n        let array = new vector_array_Vector3Array(this.count());\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let row = this.getRow(i);\r\n            array.setRow(i, [row[0], row[1], 0]);\r\n        }\r\n        return array;\r\n    }\r\n    clone() {\r\n        let clone = new vector_array_Vector2Array(this._height);\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            clone.data[i] = this.data[i];\r\n        }\r\n        return clone;\r\n    }\r\n}\r\nclass vector_array_Vector3Array extends float_matrix_FloatMatrix {\r\n    constructor(count) {\r\n        super(count, 3);\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let array = new vector_array_Vector3Array(length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            array.data[i * 3] = vecs[i].x;\r\n            array.data[i * 3 + 1] = vecs[i].y;\r\n            array.data[i * 3 + 2] = vecs[i].z;\r\n        }\r\n        return array;\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        let height = native.length;\r\n        let matrix = new vector_array_Vector3Array(height);\r\n        for (var i = 0; i < native.length; i++) {\r\n            for (var j = 0; j < native[0].length; j++) {\r\n                matrix.set(i, j, native[i][j]);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    fillFromList(vecs) {\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            this.data[i * 3] = vecs[i].x;\r\n            this.data[i * 3 + 1] = vecs[i].y;\r\n            this.data[i * 3 + 2] = vecs[i].z;\r\n        }\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let vec = this.getVector(i);\r\n            vec = callbackfn(vec, i);\r\n            if (vec instanceof vector_Vector3) {\r\n                this.setVector(i, vec);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    take(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = new vector_array_Vector3Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setVector(i, this.getVector(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    map(callbackfn) {\r\n        let clone = this.clone();\r\n        for (let i = 0; i < this.count(); i++) {\r\n            let vec = this.getVector(i);\r\n            let result = callbackfn(vec, i);\r\n            if (result instanceof vector_Vector3) {\r\n                clone.setVector(i, result);\r\n            }\r\n            else {\r\n                clone.setVector(i, vec);\r\n            }\r\n        }\r\n        return clone;\r\n    }\r\n    mapWith(other, callback) {\r\n        return super.mapWith(other, callback);\r\n    }\r\n    setVector(i, vec) {\r\n        this.data[i * this._width + 0] = vec.x;\r\n        this.data[i * this._width + 1] = vec.y;\r\n        this.data[i * this._width + 2] = vec.z;\r\n    }\r\n    getVector(i) {\r\n        return new vector_Vector3(this.data[i * this._width + 0], this.data[i * this._width + 1], this.data[i * this._width + 2]);\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this._height; i++) {\r\n            vecs.push(this.getVector(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    transform(m) {\r\n        // THIS CAN BE SPEED UP: BOTH MATRIX 4 & VECTOR3ARRAY ARE JUST FLOAT-MATRICES\r\n        for (let i = 0; i < this._height; i++) {\r\n            let vec = this.getVector(i);\r\n            vec = m.multiplyVector(vec);\r\n            this.setVector(i, vec);\r\n        }\r\n        // this.data = m.MultiplyM(this).data;\r\n        return this;\r\n    }\r\n    to2D() {\r\n        let clone = new vector_array_Vector2Array(this._height);\r\n        for (let i = 0; i < this._height; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                clone.set(i, j, this.get(i, j));\r\n            }\r\n        }\r\n        return clone;\r\n    }\r\n    clone() {\r\n        let clone = new vector_array_Vector3Array(this._height);\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            clone.data[i] = this.data[i];\r\n        }\r\n        return clone;\r\n    }\r\n    mean() {\r\n        // the mean vector of a series of vectors\r\n        let sum = vector_Vector3.zero();\r\n        let count = this.count();\r\n        for (let i = 0; i < count; i++) {\r\n            sum.x += this.data[i * 3];\r\n            sum.y += this.data[i * 3 + 1];\r\n            sum.z += this.data[i * 3 + 2];\r\n        }\r\n        return sum.scale(1 / count);\r\n    }\r\n    average() {\r\n        return this.mean();\r\n    }\r\n    closestId(point) {\r\n        let lowScore = Infinity;\r\n        let id = -1;\r\n        this.forEach((v, i) => {\r\n            let disSquared = point.disToSquared(v);\r\n            if (disSquared < lowScore) {\r\n                lowScore = disSquared;\r\n                id = i;\r\n            }\r\n        });\r\n        return id;\r\n    }\r\n    closestIds(point, n) {\r\n        // O(m*n)... TODO implement quicksort\r\n        let ids = [];\r\n        for (let i = 0; i < n; i++) {\r\n            let lowScore = Infinity;\r\n            let id = -1;\r\n            this.forEach((v, i) => {\r\n                if (ids.includes(id))\r\n                    return;\r\n                let disSquared = point.disToSquared(v);\r\n                if (disSquared < lowScore) {\r\n                    lowScore = disSquared;\r\n                    id = i;\r\n                }\r\n            });\r\n            ids.push(id);\r\n        }\r\n        return ids;\r\n    }\r\n}\r\n// TODO : to FloatMatrix\r\nfunction vector_array_getGeneralFloatMatrix(vectors) {\r\n    if (vectors instanceof vector_array_Vector2Array) {\r\n        return vectors;\r\n    }\r\n    else if (vectors instanceof vector_array_Vector3Array) {\r\n        return vectors;\r\n    }\r\n    else if (vectors[0] instanceof vector_Vector2) {\r\n        return vector_array_Vector2Array.fromList(vectors);\r\n    }\r\n    else {\r\n        return vector_array_Vector3Array.fromList(vectors);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/mesh/render-mesh.ts\n// Name: render-mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n// a mesh representation with the sole purpose of to be renderer.\r\n// - fixed length attributes\r\n// - can represent:\r\n//   - pointcloud (links = null)\r\n//   - graph (links.width = 2)\r\n//   - triangles (links.width = 3)\r\n//   - quads (links.width = 4. will need to be converted to triangles)\r\n\r\n\r\n\r\nvar MeshType;\r\n(function (MeshType) {\r\n    MeshType[MeshType["Invalid"] = 0] = "Invalid";\r\n    MeshType[MeshType["Points"] = 1] = "Points";\r\n    MeshType[MeshType["Lines"] = 2] = "Lines";\r\n    MeshType[MeshType["Triangles"] = 3] = "Triangles";\r\n    MeshType[MeshType["Quads"] = 4] = "Quads";\r\n})(MeshType || (MeshType = {}));\r\nvar render_mesh_NormalKind;\r\n(function (NormalKind) {\r\n    NormalKind[NormalKind["None"] = 0] = "None";\r\n    NormalKind[NormalKind["Vertex"] = 1] = "Vertex";\r\n    NormalKind[NormalKind["Face"] = 2] = "Face";\r\n    NormalKind[NormalKind["MultiVertex"] = 3] = "MultiVertex";\r\n})(render_mesh_NormalKind || (render_mesh_NormalKind = {}));\r\nclass render_mesh_Renderable {\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        this._normKind = render_mesh_NormalKind.None;\r\n        // render speed\r\n        // shader\r\n        this.color = [1, 1, 1, 1];\r\n        this.linecolor = [1, 1, 1, 1];\r\n        let perFaceCount = 3;\r\n        this.mesh = mesh_Mesh.newEmpty(vertCount, faceCount, perFaceCount);\r\n        this.norms = new vector_array_Vector3Array(normCount);\r\n        this.uvs = new vector_array_Vector2Array(uvCount);\r\n        this.ambi = new Float32Array(vertCount);\r\n        this.texture = texture;\r\n        this.position = matrix_Matrix4.newIdentity();\r\n    }\r\n    static new(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        return new render_mesh_Renderable(vertCount, normCount, uvCount, faceCount, texture);\r\n    }\r\n    static fromMesh(mesh) {\r\n        let r = new render_mesh_Renderable(mesh.verts.count(), 0, 0, mesh.links.count());\r\n        r.mesh.verts.data = mesh.verts.data;\r\n        r.mesh.links.data = mesh.links.data;\r\n        return r;\r\n    }\r\n    static fromData(verts, norms, uvs, faces) {\r\n        // NOTE : this type of parsing makes my life easy, but is dangerous. This is why i created the\r\n        // Array class.\r\n        let r = new render_mesh_Renderable(verts.length / 3, norms.length / 3, uvs.length / 2, faces.length / 3);\r\n        r.mesh.verts.fillWith(verts);\r\n        r.mesh.links.fillWith(faces);\r\n        r.norms.fillWith(norms);\r\n        r.uvs.fillWith(uvs);\r\n        return r;\r\n    }\r\n    static fromGraph(graph) {\r\n        let mesh = graph.toMesh();\r\n        let r = render_mesh_Renderable.fromMesh(mesh);\r\n        r.norms = vector_array_Vector3Array.fromList(graph.allNorms());\r\n        r._normKind = render_mesh_NormalKind.Vertex; // fix this!!\r\n        return r;\r\n    }\r\n    // geometry trait\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.mesh.verts.count(); i++) {\r\n            let v = this.mesh.verts.getVector(i);\r\n            let n = this.norms.getVector(i);\r\n            this.mesh.verts.setVector(i, matrix.multiplyVector(v));\r\n            this.norms.setVector(i, matrix.multiplyVector(n)); // TODO, EXTRACT ONLY ROTATION PART FROM THE MATRIX\r\n        }\r\n    }\r\n    // getters & selectors\r\n    // VERY POORLY OPTIMIZED\r\n    getAdjacentFaces(v) {\r\n        let faces = [];\r\n        let count = this.mesh.links.count();\r\n        for (let i = 0; i < count; i++) {\r\n            if (this.mesh.links.getRow(i).includes(v)) {\r\n                faces.push(i);\r\n            }\r\n        }\r\n        return faces;\r\n    }\r\n    getFaceVertices(f) {\r\n        return this.mesh.getLinkVerts(f);\r\n    }\r\n    getType() {\r\n        return this.mesh.getType();\r\n    }\r\n    getNormalType() {\r\n        return this._normKind;\r\n    }\r\n    // setters\r\n    setTexture(texture) {\r\n        this.texture = texture;\r\n        // recalculate things if needed\r\n    }\r\n    setUvs(uvs) {\r\n        if (uvs instanceof Float32Array) {\r\n            this.uvs.data = uvs;\r\n        }\r\n        else {\r\n            this.uvs = uvs;\r\n        }\r\n        // recalculate if needed\r\n    }\r\n    // convert\r\n    exportToObj(path) {\r\n        throw "todo";\r\n    }\r\n    // ------ normals ------\r\n    // set 1 normal per face\r\n    calculateFaceNormals() {\r\n        if (this.getType() != MeshType.Triangles) {\r\n            console.error("can only calculate normals from triangular meshes");\r\n            this.norms = new vector_array_Vector3Array(0);\r\n            return;\r\n        }\r\n        let norms = this.mesh.calculateFaceNormals();\r\n        this.norms = vector_array_Vector3Array.fromList(norms);\r\n        this._normKind = render_mesh_NormalKind.Face;\r\n    }\r\n    calculateVertexNormals() {\r\n        let norms = this.mesh.calculateVertexNormals();\r\n        this.norms = vector_array_Vector3Array.fromList(norms);\r\n        this._normKind = render_mesh_NormalKind.Vertex;\r\n    }\r\n    calculateMultiVertexNormals() {\r\n        // set type\r\n        this._normKind = render_mesh_NormalKind.MultiVertex;\r\n        // calculate\r\n        this.calculateFaceNormals();\r\n        let vertNormals = new vector_array_Vector3Array(this.mesh.verts.count());\r\n        this.mesh.verts.forEach((v, i) => {\r\n            let adjFaces = this.getAdjacentFaces(i);\r\n            vertNormals.setVector(i, this.norms.take(adjFaces).average());\r\n        });\r\n        this.norms = vertNormals;\r\n    }\r\n}\r\n// ================ Obj ===================\r\nfunction meshFromObj(text) {\r\n    // This is not a full .obj parser.\r\n    // see http://paulbourke.net/dataformats/obj/\r\n    // INDEXES ORIGINALLY REFER TO LINES, so -1 is needed\r\n    // run through all lines, and temporarely store\r\n    // all data in raw number lists, since we dont know how\r\n    // many vertices or faces well get.\r\n    let verts = []; // 3 long float\r\n    let norms = []; // 3 long float\r\n    let uvs = []; // 2 long float\r\n    let faces = []; // 9 long ints, u16\'s should suffice.\r\n    // note : this is very inefficient, but it\'ll have to do for now...\r\n    const keywordRE = /(\\w*)(?: )*(.*)/;\r\n    const lines = text.split("\\n");\r\n    for (let i = 0; i < lines.length; ++i) {\r\n        const line = lines[i].trim();\r\n        // filter out comments\r\n        if (line === "" || line.startsWith("#")) {\r\n            continue;\r\n        }\r\n        const m = keywordRE.exec(line);\r\n        if (!m) {\r\n            continue;\r\n        }\r\n        const [, keyword, unparsedArgs] = m;\r\n        const parts = line.split(/\\s+/).slice(1);\r\n        switch (keyword) {\r\n            case "v":\r\n                for (const part of parts) {\r\n                    verts.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case "vn":\r\n                for (const part of parts) {\r\n                    norms.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case "vt":\r\n                for (const part of parts) {\r\n                    uvs.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case "f":\r\n                for (const value of ProcessObjFace(parts)) {\r\n                    faces.push(value);\r\n                }\r\n                break;\r\n            default:\r\n                console.warn("unhandled keyword:", keyword); // eslint-disable-line no-console\r\n                continue;\r\n        }\r\n    }\r\n    // console.log("number of vertices: " + verts.length / 3);\r\n    // console.log("number of faces: " + faces.length / 3);\r\n    // console.log("number of uvs: " + uvs.length / 2);\r\n    // console.log("number of norms: " + norms.length / 3);\r\n    let mesh = render_mesh_Renderable.fromData(verts, norms, uvs, faces);\r\n    return mesh;\r\n}\r\n// NOTE: for now, uv and normals are completely ignored!!!\r\n// we assume the indices are the same als the vertices!!!\r\n// verbose way of processing one single vertex/normal/uv combination in a face.\r\nfunction ProcessObjFaceVertex(part) {\r\n    // make sure data always has length: 3\r\n    let data = [];\r\n    // cut string apart and process it\r\n    let subparts = part.split("/");\r\n    if (subparts.length == 1) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(0);\r\n        // data.push(0);\r\n    }\r\n    else if (subparts.length == 3) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(parseInt(subparts[1])-1);\r\n        // data.push(parseInt(subparts[2])-1);\r\n    }\r\n    else {\r\n        throw "invalid face found when processing";\r\n    }\r\n    return data;\r\n}\r\n// process a face entry in an obj file\r\nfunction ProcessObjFace(parts) {\r\n    let data = [];\r\n    if (parts.length == 4) {\r\n        // i dont want to deal with quads for now, create 2 faces from a quad\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        let d = ProcessObjFaceVertex(parts[3]);\r\n        data.push(...a, ...b, ...c, ...a, ...c, ...d);\r\n    }\r\n    else if (parts.length == 3) {\r\n        // as normal\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        data.push(...a, ...b, ...c);\r\n    }\r\n    // data always has length 9 or 18\r\n    return data;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/statistics.ts\n// name:    statistics.ts\r\n// author:  Jos Feenstra\r\n// purpose: functionality and documentation of variance,\r\n//          covariance, eigen vectors, least squares, and other\r\n//          statistical operations.\r\n// source:  been a while since I did this,\r\n//          https://datascienceplus.com/understanding-the-covariance-matrix/\r\n//          https://wiki.pathmind.com/eigenvector\r\n//          used to make sure the basics are correct :).\r\n// notes:   Whats the difference between a Principal Component and an Eigen vector?\r\n//          "Because eigenvectors trace the principal lines of force, and the axes of greatest variance and covariance illustrate where the data is most susceptible to change."\r\n\r\nclass Stat {\r\n    // calculate sum\r\n    static sum(x) {\r\n        let sum = 0;\r\n        for (let i = 0; i < x.length; i++) {\r\n            sum += x[i];\r\n        }\r\n        return sum;\r\n    }\r\n    // calculate average\r\n    static mean(x) {\r\n        return this.sum(x) / x.length;\r\n    }\r\n    // calculate variance\r\n    static variance(x) {\r\n        //^2x = (1/n1) * ni=1 (x[i]  xAvr)^2\r\n        let n = x.length;\r\n        let avr = this.mean(x);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += Math.pow((x[i] - avr), 2);\r\n        }\r\n        return sum / (n - 1);\r\n    }\r\n    // calculate the standard deviation\r\n    static deviation(x) {\r\n        return Math.pow(this.variance(x), 0.5);\r\n    }\r\n    // calculate covariance\r\n    static covariance(x, y) {\r\n        if (x.length != y.length)\r\n            throw "this is not how covariance works...";\r\n        let n = x.length;\r\n        let xAvr = this.mean(x);\r\n        let yAvr = this.mean(y);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += (x[i] - xAvr) * (y[i] - yAvr);\r\n        }\r\n        return sum / (n - 1); // losing one degree of freedom\r\n    }\r\n    // calculate variance / covariance matrix\r\n    static cov(matrix) {\r\n        let size = matrix._width;\r\n        let cov = new float_matrix_FloatMatrix(size, size);\r\n        let columns = Array(size);\r\n        for (let i = 0; i < size; i++) {\r\n            columns[i] = matrix.getColumn(i);\r\n        }\r\n        // matrix is symmertical, so only run through one half\r\n        for (let i = 0; i < size; i++) {\r\n            for (let j = i; j < size; j++) {\r\n                let value = this.covariance(columns[i], columns[j]);\r\n                cov.set(i, j, value);\r\n                cov.set(j, i, value);\r\n            }\r\n        }\r\n        return cov;\r\n    }\r\n    static eig(A) {\r\n        let results = this.svd(A);\r\n        return [results[1], results[2]];\r\n    }\r\n    /**\r\n     * Single Value Decomposition.\r\n     * Can be used for Eigen Value Decomposition\r\n     * from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970).\r\n     * Taken from numeric.js. not yet cleaned & optimized.\r\n     * https://en.wikipedia.org/wiki/Singular_value_decomposition\r\n     * @param  {FloatMatrix} A matrix to decompose, such as a covariance matrix\r\n     * @returns [U, , V]\r\n     * U -> during EVD, these are the eigen vectors of A transposed, if im not mistaken\r\n     *  -> during EVD, this are the eigen values\r\n     * V -> during EVD, the columns are eigen vectors\r\n     */\r\n    static svd(A) {\r\n        var prec = Math.pow(2, -52); // assumes double prec\r\n        var tolerance = 1e-64 / prec;\r\n        var itmax = 50;\r\n        var c = 0;\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var l = 0;\r\n        var u = A.clone().toNative();\r\n        var m = u.length;\r\n        var n = u[0].length;\r\n        if (m < n)\r\n            throw "Need more rows than columns";\r\n        var e = new Array(n);\r\n        var q = new Array(n);\r\n        for (i = 0; i < n; i++)\r\n            e[i] = q[i] = 0.0;\r\n        var v = rep([n, n], 0);\r\n        function pythag(a, b) {\r\n            a = Math.abs(a);\r\n            b = Math.abs(b);\r\n            if (a > b)\r\n                return a * Math.sqrt(1.0 + (b * b) / a / a);\r\n            else if (b == 0.0)\r\n                return a;\r\n            return b * Math.sqrt(1.0 + (a * a) / b / b);\r\n        }\r\n        //rep function, [JF] : dont know what this does exactly...\r\n        function rep(s, v, k = 0) {\r\n            let n = s[k];\r\n            let ret = Array(n);\r\n            let i;\r\n            if (k === s.length - 1) {\r\n                for (i = n - 2; i >= 0; i -= 2) {\r\n                    ret[i + 1] = v;\r\n                    ret[i] = v;\r\n                }\r\n                if (i === -1) {\r\n                    ret[0] = v;\r\n                }\r\n                return ret;\r\n            }\r\n            for (i = n - 1; i >= 0; i--) {\r\n                ret[i] = rep(s, v, k + 1);\r\n            }\r\n            return ret;\r\n        }\r\n        //Householder\'s reduction to bidiagonal form\r\n        var f = 0.0;\r\n        var g = 0.0;\r\n        var h = 0.0;\r\n        var x = 0.0;\r\n        var y = 0.0;\r\n        var z = 0.0;\r\n        var s = 0.0;\r\n        for (i = 0; i < n; i++) {\r\n            e[i] = g;\r\n            s = 0.0;\r\n            l = i + 1;\r\n            for (j = i; j < m; j++)\r\n                s += u[j][i] * u[j][i];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i] = f - g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = i; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n            }\r\n            q[i] = g;\r\n            s = 0.0;\r\n            for (j = l; j < n; j++)\r\n                s = s + u[i][j] * u[i][j];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i + 1];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i + 1] = f - g;\r\n                for (j = l; j < n; j++)\r\n                    e[j] = u[i][j] / h;\r\n                for (j = l; j < m; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[j][k] * u[i][k];\r\n                    for (k = l; k < n; k++)\r\n                        u[j][k] += s * e[k];\r\n                }\r\n            }\r\n            y = Math.abs(q[i]) + Math.abs(e[i]);\r\n            if (y > x)\r\n                x = y;\r\n        }\r\n        // accumulation of right hand gtransformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            if (g != 0.0) {\r\n                h = g * u[i][i + 1];\r\n                for (j = l; j < n; j++)\r\n                    v[j][i] = u[i][j] / h;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[i][k] * v[k][j];\r\n                    for (k = l; k < n; k++)\r\n                        v[k][j] += s * v[k][i];\r\n                }\r\n            }\r\n            for (j = l; j < n; j++) {\r\n                v[i][j] = 0;\r\n                v[j][i] = 0;\r\n            }\r\n            v[i][i] = 1;\r\n            g = e[i];\r\n            l = i;\r\n        }\r\n        // accumulation of left hand transformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            l = i + 1;\r\n            g = q[i];\r\n            for (j = l; j < n; j++)\r\n                u[i][j] = 0;\r\n            if (g != 0.0) {\r\n                h = u[i][i] * g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = u[j][i] / g;\r\n            }\r\n            else\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = 0;\r\n            u[i][i] += 1;\r\n        }\r\n        // diagonalization of the bidiagonal form\r\n        prec = prec * x;\r\n        for (k = n - 1; k != -1; k += -1) {\r\n            for (var iteration = 0; iteration < itmax; iteration++) {\r\n                // test f splitting\r\n                var test_convergence = false;\r\n                for (l = k; l != -1; l += -1) {\r\n                    if (Math.abs(e[l]) <= prec) {\r\n                        test_convergence = true;\r\n                        break;\r\n                    }\r\n                    if (Math.abs(q[l - 1]) <= prec)\r\n                        break;\r\n                }\r\n                if (!test_convergence) {\r\n                    // cancellation of e[l] if l>0\r\n                    c = 0.0;\r\n                    s = 1.0;\r\n                    var l1 = l - 1;\r\n                    for (i = l; i < k + 1; i++) {\r\n                        f = s * e[i];\r\n                        e[i] = c * e[i];\r\n                        if (Math.abs(f) <= prec)\r\n                            break;\r\n                        g = q[i];\r\n                        h = pythag(f, g);\r\n                        q[i] = h;\r\n                        c = g / h;\r\n                        s = -f / h;\r\n                        for (j = 0; j < m; j++) {\r\n                            y = u[j][l1];\r\n                            z = u[j][i];\r\n                            u[j][l1] = y * c + z * s;\r\n                            u[j][i] = -y * s + z * c;\r\n                        }\r\n                    }\r\n                }\r\n                // test f convergence\r\n                z = q[k];\r\n                if (l == k) {\r\n                    //convergence\r\n                    if (z < 0.0) {\r\n                        //q[k] is made non-negative\r\n                        q[k] = -z;\r\n                        for (j = 0; j < n; j++)\r\n                            v[j][k] = -v[j][k];\r\n                    }\r\n                    break; //break out of iteration loop and move on to next k value\r\n                }\r\n                if (iteration >= itmax - 1)\r\n                    throw "Error: no convergence.";\r\n                // shift from bottom 2x2 minor\r\n                x = q[l];\r\n                y = q[k - 1];\r\n                g = e[k - 1];\r\n                h = e[k];\r\n                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\r\n                g = pythag(f, 1.0);\r\n                if (f < 0.0)\r\n                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\r\n                else\r\n                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\r\n                // next QR transformation\r\n                c = 1.0;\r\n                s = 1.0;\r\n                for (i = l + 1; i < k + 1; i++) {\r\n                    g = e[i];\r\n                    y = q[i];\r\n                    h = s * g;\r\n                    g = c * g;\r\n                    z = pythag(f, h);\r\n                    e[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = x * c + g * s;\r\n                    g = -x * s + g * c;\r\n                    h = y * s;\r\n                    y = y * c;\r\n                    for (j = 0; j < n; j++) {\r\n                        x = v[j][i - 1];\r\n                        z = v[j][i];\r\n                        v[j][i - 1] = x * c + z * s;\r\n                        v[j][i] = -x * s + z * c;\r\n                    }\r\n                    z = pythag(f, h);\r\n                    q[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = c * g + s * y;\r\n                    x = -s * g + c * y;\r\n                    for (j = 0; j < m; j++) {\r\n                        y = u[j][i - 1];\r\n                        z = u[j][i];\r\n                        u[j][i - 1] = y * c + z * s;\r\n                        u[j][i] = -y * s + z * c;\r\n                    }\r\n                }\r\n                e[l] = 0.0;\r\n                e[k] = f;\r\n                q[k] = x;\r\n            }\r\n        }\r\n        for (i = 0; i < q.length; i++)\r\n            if (q[i] < prec)\r\n                q[i] = 0;\r\n        //sort eigenvalues\r\n        var temp;\r\n        for (i = 0; i < n; i++) {\r\n            for (j = i - 1; j >= 0; j--) {\r\n                if (q[j] < q[i]) {\r\n                    c = q[j];\r\n                    q[j] = q[i];\r\n                    q[i] = c;\r\n                    for (k = 0; k < u.length; k++) {\r\n                        temp = u[k][i];\r\n                        u[k][i] = u[k][j];\r\n                        u[k][j] = temp;\r\n                    }\r\n                    for (k = 0; k < v.length; k++) {\r\n                        temp = v[k][i];\r\n                        v[k][i] = v[k][j];\r\n                        v[k][j] = temp;\r\n                    }\r\n                    i = j;\r\n                }\r\n            }\r\n        }\r\n        return [float_matrix_FloatMatrix.fromNative(u), new Float32Array(q), float_matrix_FloatMatrix.fromNative(v)];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/plane.ts\n// name:    plane.ts\r\n// author:  Jos Feenstra\r\n// purpose: definition of a 3d plane.\r\n// todo:    turn Center, Ihat, Jhat, Khat construction to an actual matrix\r\n\r\n\r\n\r\n\r\nclass plane_Plane {\r\n    // _inverse!: Matrix4; // NOTE: currently im not caching this. Might be needed.\r\n    // NOTE : d is not really needed anymore...\r\n    constructor(m) {\r\n        this._matrix = m;\r\n    }\r\n    static fromPN(center, normal) {\r\n        let cross = normal.cross(vector_Vector3.unitX());\r\n        if (cross.length() < const_Const.TOLERANCE) {\r\n            cross = normal.cross(vector_Vector3.unitY());\r\n        }\r\n        let ihat = cross.normalize();\r\n        let jhat = normal.cross(ihat).normalize();\r\n        let mat = plane_Plane.planeMatrixFromVecs(center, ihat, jhat, normal);\r\n        return new plane_Plane(mat);\r\n    }\r\n    static fromPVV(a, v1, v2) {\r\n        // TODO check if we still need this -1 thing\r\n        let khat = v1.clone().cross(v2).normalize(); //.scale(-1);\r\n        let center = a.clone();\r\n        let ihat = v1.normalize();\r\n        let jhat = v1.clone().cross(khat);\r\n        let mat = plane_Plane.planeMatrixFromVecs(center, ihat, jhat, khat);\r\n        return new plane_Plane(mat);\r\n    }\r\n    static from3pt(a, b, c) {\r\n        let v1 = b.clone().sub(a);\r\n        let v2 = c.clone().sub(a);\r\n        return this.fromPVV(a, v1, v2);\r\n    }\r\n    static WorldXY() {\r\n        return plane_Plane.from3pt(vector_Vector3.zero(), vector_Vector3.unitX(), vector_Vector3.unitY());\r\n    }\r\n    static WorldYZ() {\r\n        return plane_Plane.from3pt(vector_Vector3.zero(), vector_Vector3.unitY(), vector_Vector3.unitZ());\r\n    }\r\n    static WorldXZ() {\r\n        return plane_Plane.from3pt(vector_Vector3.zero(), vector_Vector3.unitX(), vector_Vector3.unitZ());\r\n    }\r\n    static fromLeastSquares(pts) {\r\n        let mean = pts.mean();\r\n        let cov = Stat.cov(pts);\r\n        let [eigValues, eigVectors] = Stat.eig(cov);\r\n        console.log(eigValues);\r\n        let biggestEigenVector = vector_Vector3.fromArray(eigVectors.getColumn(0));\r\n        let secondBiggestEigenVector = vector_Vector3.fromArray(eigVectors.getColumn(1));\r\n        return plane_Plane.fromPVV(mean, biggestEigenVector, secondBiggestEigenVector);\r\n    }\r\n    static fromXYLeastSquares(pts) {\r\n        // quite specific, but this was needed.\r\n        let mean = pts.mean();\r\n        return plane_Plane.WorldXY().transform(matrix_Matrix4.newTranslation(mean.x, mean.y, mean.z));\r\n    }\r\n    static planeMatrixFromVecs(c, i, j, k) {\r\n        return new matrix_Matrix4([i.x, i.y, i.z, 0, j.x, j.y, j.z, 0, k.x, k.y, k.z, 0, c.x, c.y, c.z, 1]);\r\n    }\r\n    get ihat() {\r\n        return vector_Vector3.fromArray(this._matrix.getRow(0));\r\n    }\r\n    get jhat() {\r\n        return vector_Vector3.fromArray(this._matrix.getRow(1));\r\n    }\r\n    get khat() {\r\n        return vector_Vector3.fromArray(this._matrix.getRow(2));\r\n    }\r\n    get center() {\r\n        return vector_Vector3.fromArray(this._matrix.getRow(3));\r\n    }\r\n    get matrix() {\r\n        return this._matrix.clone();\r\n    }\r\n    get normal() {\r\n        return this.khat;\r\n    }\r\n    get d() {\r\n        return this.closestPoint(vector_Vector3.zero())[1];\r\n    }\r\n    set ihat(v) {\r\n        this._matrix.setRow(0, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set jhat(v) {\r\n        this._matrix.setRow(1, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set khat(v) {\r\n        this._matrix.setRow(2, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set center(v) {\r\n        this._matrix.setRow(3, [v.x, v.y, v.z, 1]);\r\n    }\r\n    set matrix(m) {\r\n        this._matrix = m;\r\n    }\r\n    get inverse() {\r\n        // TODO CACHE INVERSE MATRIX\r\n        return this._matrix.inverse();\r\n    }\r\n    setPosition(vec) {\r\n        this.center = vec;\r\n    }\r\n    setNormal(vec) {\r\n        this.khat = vec;\r\n    }\r\n    clone() {\r\n        return new plane_Plane(this._matrix.clone());\r\n    }\r\n    transform(m) {\r\n        this._matrix = this._matrix.multiply(m);\r\n        return this;\r\n    }\r\n    moveTo(origin) {\r\n        this.center = origin;\r\n        return this;\r\n    }\r\n    // NOTE: pulling is inefficient since i do not cache the inverse.\r\n    pullToPlane(p) {\r\n        return this.inverse.multiplyVector(p);\r\n    }\r\n    pushToWorld(p) {\r\n        return this.matrix.multiplyVector(p);\r\n    }\r\n    closestPoint(p) {\r\n        let pulled = this.pullToPlane(p);\r\n        let distance = pulled.z;\r\n        pulled.z = 0;\r\n        let vec = this.pushToWorld(pulled);\r\n        return [vec, distance];\r\n    }\r\n    rotateVector(v, radians) {\r\n        let pulled = this.pullToPlane(v);\r\n        let rotation = matrix_Matrix4.newAxisRotation(this.normal, radians);\r\n        pulled = rotation.multiplyVector(pulled);\r\n        return this.pushToWorld(pulled);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/data/hash-table.ts\n// note: this wont always work, but it does in most cases\r\n// todo: implement proper hashtable\r\nclass hash_table_HashTable {\r\n    constructor() {\r\n        this.data = new Map();\r\n    }\r\n    stringify(key) {\r\n        return key.toString();\r\n    }\r\n    set(key, value) {\r\n        return this.data.set(this.stringify(key), value);\r\n    }\r\n    has(key) {\r\n        return this.data.has(this.stringify(key));\r\n    }\r\n    get(key) {\r\n        return this.data.get(this.stringify(key));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/mesh/graph.ts\n// name: graph.ts\r\n// author:  Jos Feenstra\r\n// purpose: HalfEdge Mesh in 3D.\r\n// This does mean that the order around a vertex is not staight forward, and must be handled using normals.\r\n// TODO\r\n// - graph clean\r\n// - graph delete vert\r\n// - to line renderable\r\n// - keep track of faces, for quick meshification\r\n//   - THIS WILL SPEED UP \'GET ALL FACES THREMENDOUSLY, WHICH WILL SPEED UP SUBDIVISONS\'\r\n// - remove ambiguity of halfedges & edges\r\n//   - fix the fact that we \'dont\' realllly use halfedges, we consistently use pairs of two.\r\n//   - aka, twins are implicit: 0 -> 1 & 1 -> 0 OR 21 -> 20 & 20 -> 21\r\n\r\n\r\n\r\n\r\n\r\n\r\n// FACES MUST BE CONVEX, OR BUGS MIGHT OCCUR!!!!\r\n// interface Face {\r\n//    edge: EdgeIndex,\r\n// }\r\n// NOTE: create an interface which hides the Edge, Vert & Face interfaces.\r\n// NOTE: half edge is implied\r\nclass Graph {\r\n    constructor() {\r\n        this.verts = [];\r\n        this.edges = [];\r\n    }\r\n    static new() {\r\n        return new Graph();\r\n    }\r\n    static fromMesh(mesh) {\r\n        let graph = Graph.new();\r\n        let normals = mesh.calculateVertexNormals();\r\n        mesh.verts.forEach((v, i) => {\r\n            graph.addVert(v, normals[i]);\r\n        });\r\n        let type = mesh.getType();\r\n        if (type == MeshType.Invalid || type == MeshType.Points) {\r\n            return graph;\r\n        }\r\n        let map = new hash_table_HashTable();\r\n        let width = mesh.links._width;\r\n        mesh.links.forEachRow((row, i) => {\r\n            // go through pairs\r\n            // NOTE: this can be done way easier by creating 1 half edge per pair\r\n            for (let i = 0; i < width; i++) {\r\n                let iNext = (i + 1) % width;\r\n                let a = row[i];\r\n                let b = row[iNext];\r\n                // console.log(a, b);\r\n                if (a == -1 || b == -1)\r\n                    continue;\r\n                graph.addEdgeIfNew(a, b);\r\n                // let normal = normals[a].add(normals[b]).normalize();\r\n                // if (map.has([a, b])) {\r\n                //     console.log("GOT IT ALREADY")\r\n                //     continue;\r\n                // }\r\n                // graph.addEdgeWithCustomNormal(a, b, normal);\r\n                // map.set([b, a], true);\r\n                // graph.addEdge(a, b);\r\n            }\r\n        });\r\n        return graph;\r\n    }\r\n    // geometry trait\r\n    clone() {\r\n        throw new Error("not yet implemented...");\r\n    }\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            v.pos = matrix.multiplyVector(v.pos);\r\n        }\r\n    }\r\n    // UTILITY\r\n    print() {\r\n        console.log("graph");\r\n        console.log("--------");\r\n        console.log(`${this.verts.length} verts: `);\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            console.log(`v(${i}) | edge: ${v.edge}, data: ${v.pos.toString()} normal: ${v.normal.toString()}`);\r\n        }\r\n        console.log("--------");\r\n        console.log(`${this.edges.length} edges:  `);\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n            console.log(`e(${i}) | vert: ${e.vert}, twin: ${e.twin}, next: ${e.next}, dead ${e.dead}`);\r\n        }\r\n        console.log("--------");\r\n    }\r\n    // CONVERTERS\r\n    toMesh() {\r\n        return mesh_Mesh.fromGraph(this);\r\n    }\r\n    toLines() {\r\n        return mesh_Mesh.newLines(this.allVertPositions(), this.allUniqueEdgeVerts());\r\n    }\r\n    toRenderable() {\r\n        return render_mesh_Renderable.fromGraph(this);\r\n    }\r\n    // public getters\r\n    allNorms() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.normal);\r\n        });\r\n        return data;\r\n    }\r\n    allVertPositions() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.pos);\r\n        });\r\n        return data;\r\n    }\r\n    allUniqueEdges() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(i1);\r\n        }\r\n        return edges;\r\n    }\r\n    allUniqueEdgeVerts() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(a.vert, b.vert);\r\n        }\r\n        return edges;\r\n    }\r\n    allEdgeVerts() {\r\n        let data = [];\r\n        // let edges = new Map<number, number>()\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead)\r\n                return;\r\n            let a = e.vert;\r\n            let b = this.getEdge(e.twin).vert;\r\n            if (a < b) {\r\n                data.push(a);\r\n                data.push(b);\r\n            }\r\n        });\r\n        return data;\r\n    }\r\n    allVertLoops() {\r\n        throw "TODO";\r\n    }\r\n    allVertLoopsAsInts() {\r\n        // TODO speed this up\r\n        let loops = [];\r\n        let unvisited = new Set();\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead) {\r\n                return;\r\n            }\r\n            unvisited.add(i);\r\n        });\r\n        let i = 0;\r\n        const limit = this.edges.length; // we will never visit an edge twice if all is according to plan\r\n        while (unvisited.size > 0) {\r\n            let loop = [];\r\n            let ei = unvisited.entries().next().value[0];\r\n            let start = ei;\r\n            do {\r\n                if (i > limit) {\r\n                    // this.print();\r\n                    throw "topology is corrupt!";\r\n                }\r\n                i += 1;\r\n                let e = this.getEdge(ei);\r\n                unvisited.delete(ei);\r\n                loop.push(e.vert);\r\n                ei = e.next;\r\n            } while (ei != start);\r\n            loops.push(loop);\r\n        }\r\n        return loops;\r\n    }\r\n    getLoop(ei) {\r\n        let loop = [];\r\n        let i = 0;\r\n        const limit = this.edges.length;\r\n        let start = ei;\r\n        do {\r\n            if (i > limit) {\r\n                // this.print();\r\n                throw "topology is corrupt!";\r\n            }\r\n            i += 1;\r\n            let e = this.getEdge(ei);\r\n            loop.push(ei);\r\n            ei = e.next;\r\n        } while (ei != start);\r\n        return loop;\r\n    }\r\n    getVertexPos(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw "out of range";\r\n        }\r\n        return this.verts[vi].pos;\r\n    }\r\n    getVertexNormal(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw "out of range";\r\n        }\r\n        return this.verts[vi].normal;\r\n    }\r\n    getVertexCount() {\r\n        return this.verts.length;\r\n    }\r\n    getHalfEdgeCount() {\r\n        return this.edges.length;\r\n    }\r\n    changeVertex(vi, pos, norm) {\r\n        let v = this.verts[vi];\r\n        v.pos = pos;\r\n        v.normal = norm;\r\n    }\r\n    getVert(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw "out of range";\r\n        }\r\n        return this.verts[vi];\r\n    }\r\n    getEdge(ei) {\r\n        if (ei < 0 || ei >= this.edges.length) {\r\n            console.error("out of range");\r\n        }\r\n        return this.edges[ei];\r\n    }\r\n    getEdgeIndexBetween(ai, bi) {\r\n        let res = this.getEdgeBetween(ai, bi);\r\n        if (res)\r\n            return this.getEdgeIndex(res);\r\n        return undefined;\r\n    }\r\n    getEdgeBetween(ai, bi) {\r\n        let edges = this.getVertEdgeFan(ai);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            if (this.getEdge(edges[i].twin).vert == bi) {\r\n                return edges[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    getVertEdgeFan(vi) {\r\n        // get all edges connected to this vertex.\r\n        // NOTE: all are outgoing (e.vert == vi)\r\n        // console.log("getting fan");\r\n        let fan = [];\r\n        let v = this.verts[vi];\r\n        let ei = v.edge;\r\n        let start = ei;\r\n        if (ei == -1) {\r\n            return fan;\r\n        }\r\n        let count = 0;\r\n        while (true) {\r\n            if (count > this.verts.length) {\r\n                this.print();\r\n                console.log("fan: ", fan);\r\n                throw "nope";\r\n            }\r\n            count += 1;\r\n            // console.log("step", count, "ei", ei);\r\n            let e = this.getEdge(ei);\r\n            let e_twin = this.getEdgeTwin(ei);\r\n            fan.push(e);\r\n            ei = e_twin.next;\r\n            if (ei == start) {\r\n                break;\r\n            }\r\n        }\r\n        // console.log("returning fan: ", fan);\r\n        return fan;\r\n    }\r\n    getLoopsAdjacentToEdge(ei) {\r\n        let loops = [];\r\n        loops.push(this.getLoop(ei));\r\n        loops.push(this.getLoop(this.getEdge(ei).twin));\r\n        return loops;\r\n    }\r\n    getVertNeighbors(vi) {\r\n        let ids = [];\r\n        this.getVertEdgeFan(vi).forEach((e) => {\r\n            ids.push(this.getEdge(e.twin).vert);\r\n        });\r\n        return ids;\r\n    }\r\n    getEdgeIndex(e) {\r\n        return this.getEdge(e.twin).twin;\r\n    }\r\n    getEdgeTwin(ei) {\r\n        return this.edges[this.edges[ei].twin];\r\n    }\r\n    hasEdge(a, b) {\r\n        let nbs = this.getVertNeighbors(a);\r\n        return nbs.includes(b);\r\n    }\r\n    addVert(vector, normal) {\r\n        this.verts.push({ pos: vector, edge: -1, normal: normal, dead: false });\r\n        return this.verts.length - 1;\r\n    }\r\n    removeVert(a) {\r\n        throw "TODO FIGURE OUT NULL & REMOVAL";\r\n    }\r\n    addEdgeIfNew(a, b) {\r\n        if (!this.hasEdge(a, b)) {\r\n            // console.log("not there!");\r\n            this.addEdge(a, b);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    addEdge(vi_1, vi_2) {\r\n        //             ei1\r\n        // / vi1 \\  ---------\x3e / vi2 \\\r\n        // \\     / <---------  \\     /\r\n        //             ei2\r\n        let ei_1 = this.edges.length;\r\n        let ei_2 = ei_1 + 1;\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_2,\r\n            vert: vi_1,\r\n            dead: false,\r\n        });\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_1,\r\n            vert: vi_2,\r\n            dead: false,\r\n        });\r\n        // make sure the \'next\' things are fixed, and more\r\n        this.addEdgeToDisk(vi_1, ei_1);\r\n        this.addEdgeToDisk(vi_2, ei_2);\r\n    }\r\n    deleteEdgeByIndex(id) {\r\n        // flag it as \'to be removed\'\r\n        this.deleteEdge(this.getEdge(id));\r\n    }\r\n    deleteEdge(edge) {\r\n        // flag it as \'to be removed\'\r\n        let twin = this.getEdge(edge.twin);\r\n        edge.dead = true;\r\n        twin.dead = true;\r\n        // remove all pointers\r\n        this.deleteEdgeFromDisk(edge);\r\n        this.deleteEdgeFromDisk(twin);\r\n    }\r\n    // SETTERS\r\n    getDiskPositions(ei) {\r\n        // returns edgeIndex before, edgeIndex after\r\n        let e = this.getEdge(ei);\r\n        let v = this.getVert(e.vert);\r\n        let twin = this.getEdgeTwin(ei);\r\n        let v_twin = this.verts[twin.vert];\r\n        let myVector = v.pos.subbed(v_twin.pos);\r\n        // get all vectors\r\n        let vectors = [];\r\n        vectors.push(myVector);\r\n        // get more vectors by getting all edges currently connected to vertex v\r\n        // if this Edge is already within the fan, filter it out, so this assessment can be correctly made\r\n        let edgesPotentiallyWithExistingEdge = this.getVertEdgeFan(e.vert);\r\n        let edges = [];\r\n        for (let i = 0; i < edgesPotentiallyWithExistingEdge.length; i++) {\r\n            let edge = edgesPotentiallyWithExistingEdge[i];\r\n            if (this.getEdgeIndex(edge) == ei) {\r\n                // console.log("edge is in the fan!");\r\n            }\r\n            else {\r\n                edges.push(edge);\r\n            }\r\n        }\r\n        if (edges.length == 0) {\r\n            return [ei, ei];\r\n        }\r\n        if (edges.length == 1) {\r\n            let e = edges[0];\r\n            return [this.getEdgeIndex(e), this.getEdgeIndex(e)];\r\n        }\r\n        // console.log("edges", edges);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            let edge = edges[i];\r\n            let twin = this.getEdge(edge.twin);\r\n            let neighbor = this.verts[twin.vert];\r\n            let neighborVector = v.pos.subbed(neighbor.pos);\r\n            vectors.push(neighborVector);\r\n        }\r\n        // console.log("all vectors: ", vectors);\r\n        // order them by \'wheel\'\r\n        let plane = plane_Plane.fromPN(v.pos, v.normal);\r\n        let ihat = plane.ihat;\r\n        let jhat = plane.jhat;\r\n        let order = vector_Vector3.calculateWheelOrder(vectors, ihat, jhat);\r\n        // console.log("order", order);\r\n        // find index 0 in the ordering. that is the position of this new edge. get the edges before and after this edge\r\n        let i_before = -1;\r\n        let i_after = -1;\r\n        for (let a = 0; a < order.length; a++) {\r\n            let b = (a + 1) % order.length;\r\n            let c = (a + 2) % order.length;\r\n            if (order[b] == 0) {\r\n                i_before = order[a];\r\n                i_after = order[c];\r\n                break;\r\n            }\r\n        }\r\n        // pick. NOTE: IF CCW / CC OF GRAPH NEEDS TO BE CHANGED, CHANGE THIS ORDER, BUT USE WITH CAUTION\r\n        // minus one, since we have 1 vector more than the edge list\r\n        let e_before = edges[i_after - 1];\r\n        let e_after = edges[i_before - 1];\r\n        return [this.getEdgeIndex(e_before), this.getEdgeIndex(e_after)];\r\n    }\r\n    addEdgeToDisk(vi, ei) {\r\n        let v = this.getVert(vi);\r\n        let twin = this.getEdgeTwin(ei);\r\n        if (v.edge == -1) {\r\n            // set two pointers:\r\n            v.edge = ei; // I am the vertex\'s first edge\r\n            twin.next = ei; // that means my twin points back to me\r\n        }\r\n        else {\r\n            let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n            let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n            // set two pointers:\r\n            this.getEdge(e_before.twin).next = ei;\r\n            twin.next = this.getEdgeIndex(e_after);\r\n        }\r\n    }\r\n    deleteEdgeFromDisk(edge) {\r\n        let ei = this.getEdgeIndex(edge);\r\n        // console.log("deleting...", ei);\r\n        let vert = this.getVert(edge.vert);\r\n        // console.log("deleting from disk...");\r\n        let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n        if (ei_before == ei) {\r\n            vert.edge = -1;\r\n            return;\r\n        }\r\n        // let flower = this.getVertEdgeFan(edge.vert);\r\n        // flower.forEach((e) => {console.log(this.getEdgeIndex(e))});\r\n        let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n        // set one pointer\r\n        // console.log("this is edge", ei);\r\n        // // console.log("before is", ei_before);\r\n        // console.log("after is", ei_after);\r\n        // console.log("before.twin.next is", this.getEdge(e_before.twin).next);\r\n        // console.log("after.twin.next is", this.getEdge(e_after.twin).next);\r\n        this.getEdge(e_before.twin).next = ei_after;\r\n        if (vert.edge == ei) {\r\n            vert.edge = ei_after;\r\n        }\r\n    }\r\n    // MISC\r\n    splitEdge(ai, bi, alpha) {\r\n        // get the edge\r\n        let edge = this.getEdgeBetween(ai, bi);\r\n        if (!edge)\r\n            throw new Error(`No Edge found between ${ai} and ${bi}`);\r\n        let twin = this.getEdge(edge.twin);\r\n        let a = this.getVert(ai);\r\n        let b = this.getVert(bi);\r\n        let v = vector_Vector3.fromLerp(a.pos, b.pos, alpha);\r\n        let n = vector_Vector3.fromLerp(a.normal, b.normal, alpha);\r\n        let ci = this.addVert(v, n);\r\n        let c = this.getVert(ci);\r\n        // change the edges\r\n        // if (ai == 0) {\r\n        // }\r\n        this.deleteEdge(edge);\r\n        this.addEdge(ai, ci);\r\n        this.addEdge(ci, bi);\r\n        return ci;\r\n    }\r\n    subdivide() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new hash_table_HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        let middlePoints = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            middlePoints[i] = vci;\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get all middle points\r\n            let middlePoints = new Array(face.length);\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                middlePoints[j] = deadEdgeMap.get([via, vib]);\r\n            }\r\n            // console.log(middlePoints);\r\n            // connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                this.addEdge(middlePoints[j], middlePoints[jNext]);\r\n            }\r\n        }\r\n    }\r\n    subdivideQuad() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new hash_table_HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get center point\r\n            let pos = vector_Vector3.zero();\r\n            for (let j = 0; j < face.length; j++) {\r\n                pos.add(this.getVertexPos(face[j]));\r\n            }\r\n            pos.scale(1 / face.length);\r\n            let norm = calcPlanarFaceNormal(face.map((v) => this.getVertexPos(v)));\r\n            let si = this.addVert(pos, norm);\r\n            // per middle point, connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                let c = deadEdgeMap.get([via, vib]);\r\n                this.addEdge(si, c);\r\n            }\r\n        }\r\n    }\r\n    forEveryEdgeVerts(callback) {\r\n        let edges = this.allUniqueEdgeVerts();\r\n        let edgeCount = edges.length / 2;\r\n        for (let i = 0; i < edgeCount; i++) {\r\n            let a = this.getVert(edges[i * 2]);\r\n            let b = this.getVert(edges[i * 2 + 1]);\r\n            callback(a.pos, b.pos);\r\n        }\r\n    }\r\n}\r\nfunction calcPlanarFaceNormal(face) {\r\n    // ASSUMES : FACE = PLANAR & FACE = NOT SLIVER POLYGON (AREA > 0)\r\n    let count = face.length;\r\n    if (count < 3) {\r\n        throw "cannot get face planar with 2 or less edges";\r\n    }\r\n    // get the normal of a planar face\r\n    let normal = vector_Vector3.zero();\r\n    // two edges could be parallel, but there will be two edges in the face that are different.\r\n    let ihat = face[1].subbed(face[0]);\r\n    let jhat = face[2].subbed(face[1]);\r\n    for (let i = 1; i < count; i++) {\r\n        if (Math.abs(ihat.dot(jhat)) > const_Const.TOLERANCE) {\r\n            return ihat.cross(jhat);\r\n        }\r\n        else {\r\n            // try again with next pair of\r\n            let i2 = (i + 1) % count;\r\n            let i3 = (i + 2) % count;\r\n            jhat = face[i3].subbed(face[i2]);\r\n        }\r\n    }\r\n    throw "get planar face failed...";\r\n}\r\n\n;// CONCATENATED MODULE: ./src/mesh/mesh.ts\n// mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n// a very pure idea of a mesh : Vertices + links between vertices.\r\n// Could be anything with these properties: lines, triangle-mesh, quads\r\n// idea: should normals be part of the Mesh?\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass mesh_Mesh {\r\n    // CONSTRUCTORS\r\n    constructor(verts, links) {\r\n        this.verts = verts;\r\n        this.links = links;\r\n    }\r\n    clone() {\r\n        return new mesh_Mesh(this.verts.clone(), this.links.clone());\r\n    }\r\n    static new(verts, links) {\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static fromLists(verts, faces) {\r\n        return new mesh_Mesh(vector_array_Vector3Array.fromList(verts), int_matrix_IntMatrix.fromList(faces, 3));\r\n    }\r\n    static newEmpty(vertCount, linkCount, perLinkCount) {\r\n        return new mesh_Mesh(new vector_array_Vector3Array(vertCount), new int_matrix_IntMatrix(linkCount, perLinkCount));\r\n    }\r\n    static newLines(positions, edges) {\r\n        let verts = vector_array_Vector3Array.fromList(positions);\r\n        let links = int_matrix_IntMatrix.fromList(edges, 2);\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static zero() {\r\n        return new mesh_Mesh(new vector_array_Vector3Array(0), new int_matrix_IntMatrix(0, 0));\r\n    }\r\n    static fromJoin(meshes) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let vertCount = 0;\r\n        let faceCount = 0;\r\n        for (let mesh of meshes) {\r\n            vertCount += mesh.verts.count();\r\n            faceCount += mesh.links.count();\r\n        }\r\n        let verts = new vector_array_Vector3Array(vertCount);\r\n        let links = new int_matrix_IntMatrix(faceCount, 3);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let mesh of meshes) {\r\n            for (let i = 0; i < mesh.verts.count(); i++) {\r\n                verts.setVector(accVerts + i, mesh.verts.getVector(i));\r\n            }\r\n            for (let i = 0; i < mesh.links.count(); i++) {\r\n                let face = mesh.links.getRow(i);\r\n                for (let j = 0; j < face.length; j++) {\r\n                    face[j] = face[j] + accVerts;\r\n                }\r\n                links.setRow(accFaces + i, face);\r\n            }\r\n            accVerts += mesh.verts.count();\r\n            accFaces += mesh.links.count();\r\n        }\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static fromRect(rect) {\r\n        let verts = rect.getCorners();\r\n        // we cant handle quads yet\r\n        let faces = [];\r\n        faces.push(...quadToTri(cubeFaces[0]));\r\n        let rend = new render_mesh_Renderable(4, 0, 0, 2);\r\n        rend.mesh.verts.fillFromList(verts);\r\n        rend.mesh.links.setData(faces);\r\n        // console.log(mesh.verts);\r\n        // console.log(mesh.links);\r\n        rend.setUvs(new Float32Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]));\r\n        return rend;\r\n    }\r\n    static newQuad(corners) {\r\n        let faces = [...quadToTri(cubeFaces[0])];\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static newOct(corners) {\r\n        let faces = [];\r\n        for (let face of cubeFaces) {\r\n            faces.push(...quadToTri(face));\r\n        }\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = cube.getCorners();\r\n        return mesh_Mesh.newOct(verts);\r\n    }\r\n    static newIcosahedron(scale = 1) {\r\n        let graph = new Graph();\r\n        let a = scale;\r\n        let phi = (1 + Math.pow(5, 0.5)) / 2;\r\n        let b = a * phi;\r\n        let addVert = (v) => {\r\n            graph.addVert(v, v);\r\n        };\r\n        addVert(new vector_Vector3(-a, -b, 0));\r\n        addVert(new vector_Vector3(a, -b, 0));\r\n        addVert(new vector_Vector3(-a, b, 0));\r\n        addVert(new vector_Vector3(a, b, 0));\r\n        addVert(new vector_Vector3(0, -a, -b));\r\n        addVert(new vector_Vector3(0, a, -b));\r\n        addVert(new vector_Vector3(0, -a, b));\r\n        addVert(new vector_Vector3(0, a, b));\r\n        addVert(new vector_Vector3(-b, 0, -a));\r\n        addVert(new vector_Vector3(-b, 0, a));\r\n        addVert(new vector_Vector3(b, 0, -a));\r\n        addVert(new vector_Vector3(b, 0, a));\r\n        // build edges\r\n        let addEdge = (a, b) => {\r\n            graph.addEdge(a, b);\r\n        };\r\n        for (let i = 0; i < 12; i += 4) {\r\n            addEdge(i + 0, i + 1);\r\n            addEdge(i + 2, i + 3);\r\n            let inext = (i + 4) % 12;\r\n            addEdge(i + 0, inext + 2);\r\n            addEdge(i + 0, inext + 0);\r\n            addEdge(i + 1, inext + 2);\r\n            addEdge(i + 1, inext + 0);\r\n            addEdge(i + 2, inext + 3);\r\n            addEdge(i + 2, inext + 1);\r\n            addEdge(i + 3, inext + 3);\r\n            addEdge(i + 3, inext + 1);\r\n        }\r\n        return this.fromGraph(graph);\r\n    }\r\n    static newSphere(center, radius, numRings, numPerRing) {\r\n        // verts\r\n        let vertCount = numRings * numPerRing + 2;\r\n        let verts = new vector_array_Vector3Array(vertCount);\r\n        let setVert = function (i, vector) {\r\n            verts.setVector(i, vector.scale(radius).add(center));\r\n        };\r\n        setVert(0, new vector_Vector3(0, 0, 1));\r\n        for (let ring = 0; ring < numRings; ring++) {\r\n            for (let perRing = 0; perRing < numPerRing; perRing++) {\r\n                let alpha = (Math.PI * (ring + 1)) / (numRings + 1);\r\n                let beta = (2 * Math.PI * perRing) / numPerRing;\r\n                let x = Math.sin(alpha) * Math.cos(beta);\r\n                let y = Math.sin(alpha) * Math.sin(beta);\r\n                let z = Math.cos(alpha);\r\n                let index = 1 + ring * numPerRing + perRing;\r\n                setVert(index, new vector_Vector3(x, y, z));\r\n            }\r\n        }\r\n        setVert(vertCount - 1, new vector_Vector3(0, 0, -1));\r\n        // faces\r\n        let faceCount = numPerRing * numRings * 2;\r\n        let links = new int_matrix_IntMatrix(faceCount, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // faces top\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            setFace(i, [0, i + 1, ((i + 1) % numPerRing) + 1]);\r\n        }\r\n        // faces middle\r\n        // we are at this cursor\r\n        // console.log("faces", faceCount);\r\n        for (let ring = 0; ring < numRings - 1; ring++) {\r\n            let vertCursor = numPerRing * ring + 1;\r\n            let vertCursorBelow = vertCursor + numPerRing;\r\n            for (let perRing = 0; perRing < numPerRing; perRing++) {\r\n                let a = vertCursor + perRing;\r\n                let b = vertCursor + ((perRing + 1) % numPerRing);\r\n                let c = vertCursorBelow + perRing;\r\n                let d = vertCursorBelow + ((perRing + 1) % numPerRing);\r\n                let iFace = numPerRing + numPerRing * ring * 2 + perRing * 2;\r\n                // console.log(iFace);\r\n                setFace(iFace, [a, c, b]);\r\n                setFace(iFace + 1, [c, d, b]);\r\n            }\r\n        }\r\n        // faces bottom\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let iNext = (i + 1) % numPerRing;\r\n            let last = vertCount - 1;\r\n            let iFace = faceCount - numPerRing + i;\r\n            let zero = vertCount - numPerRing - 1;\r\n            let vertI = zero + i;\r\n            let vertINext = zero + iNext;\r\n            // console.log(iFace);\r\n            // console.log("face", last, vertINext, vertI);\r\n            setFace(iFace, [last, vertINext, vertI]);\r\n        }\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static newCylinder(from, to, radius, numPerRing) {\r\n        let normal = to.subbed(from);\r\n        let numVerts = numPerRing * 2 + 2;\r\n        let numFaces = (numVerts - 2) * 2;\r\n        let verts = new vector_array_Vector3Array(numVerts);\r\n        // some dumb stuff\r\n        let setVert = function (i, vector) {\r\n            verts.setVector(i, vector);\r\n        };\r\n        // planes to represent top & bottom\r\n        let planeFrom = plane_Plane.fromPN(from, normal);\r\n        // console.log(planeFrom);\r\n        let planeTo = plane_Plane.fromPN(to, normal);\r\n        // console.log(planeFrom);\r\n        // verts \'from ring\r\n        setVert(0, from);\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let v = new vector_Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius);\r\n            v = planeFrom.matrix.multiplyVector(v);\r\n            setVert(i + 1, v);\r\n        }\r\n        // verts \'to\' ring\r\n        let numVertsHalf = numVerts / 2;\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let v = new vector_Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius);\r\n            v = planeTo.matrix.multiplyVector(v);\r\n            setVert(numVertsHalf + i, v);\r\n        }\r\n        setVert(numVerts - 1, to);\r\n        // start making links\r\n        let links = new int_matrix_IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set faces\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let a = 0;\r\n            let b = 1 + i;\r\n            let c = 1 + ((i + 1) % numPerRing);\r\n            let d = numVerts - 1;\r\n            let e = numVertsHalf + i;\r\n            let f = numVertsHalf + ((i + 1) % numPerRing);\r\n            setFace(i * 4, [a, c, b]);\r\n            setFace(i * 4 + 1, [b, c, e]);\r\n            setFace(i * 4 + 2, [c, f, e]);\r\n            setFace(i * 4 + 3, [d, e, f]);\r\n        }\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static newCone(center, radius, height, numPerRing) {\r\n        let numVerts = numPerRing + 2;\r\n        let numFaces = numPerRing * 2;\r\n        let verts = new vector_array_Vector3Array(numVerts);\r\n        let setVert = function (i, vector) {\r\n            verts.setVector(i, vector.add(center));\r\n        };\r\n        let links = new int_matrix_IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set verts\r\n        setVert(0, new vector_Vector3(0, 0, 0));\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            setVert(i + 1, new vector_Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius));\r\n        }\r\n        setVert(numVerts - 1, new vector_Vector3(0, 0, height));\r\n        // set faces\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let a = 0;\r\n            let b = numVerts - 1;\r\n            let c = 1 + i;\r\n            let d = 1 + ((i + 1) % numPerRing);\r\n            setFace(i * 2, [a, d, c]);\r\n            setFace(i * 2 + 1, [c, d, b]);\r\n        }\r\n        return new mesh_Mesh(verts, links);\r\n    }\r\n    static fromGraph(graph) {\r\n        // NOTE : doesnt really work if the loops are not of size 3.\r\n        let verts = vector_array_Vector3Array.fromList(graph.allVertPositions());\r\n        let loops = graph.allVertLoopsAsInts();\r\n        let links = new int_matrix_IntMatrix(loops.length, 3);\r\n        loops.forEach((loop, i) => {\r\n            if (loop.length == 3) {\r\n                links.setRow(i, loop);\r\n            }\r\n            else {\r\n                console.log("cant convert loop");\r\n            }\r\n        });\r\n        return mesh_Mesh.new(verts, links);\r\n    }\r\n    // CONVERTERS\r\n    toLines() {\r\n        const getLines = (num) => {\r\n            let count = this.links.count() * num;\r\n            let lines = new int_matrix_IntMatrix(count, 2);\r\n            for (let i = 0; i < this.links.count(); i++) {\r\n                for (let j = 0; j < num; j++) {\r\n                    let jnext = (j + 1) % num;\r\n                    let iLines = i * num + j;\r\n                    lines.set(iLines, 0, this.links.get(i, j));\r\n                    lines.set(iLines, 1, this.links.get(i, jnext));\r\n                }\r\n            }\r\n            return lines;\r\n        };\r\n        let type = this.getType();\r\n        if (type == MeshType.Lines) {\r\n            return this.clone();\r\n        }\r\n        else if (type == MeshType.Triangles) {\r\n            let lines = getLines(3);\r\n            return mesh_Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else if (type == MeshType.Quads) {\r\n            let lines = getLines(4);\r\n            return mesh_Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else {\r\n            console.warn("cannot convert to lines");\r\n            return mesh_Mesh.newEmpty(0, 0, 0);\r\n        }\r\n    }\r\n    toRenderable() {\r\n        return render_mesh_Renderable.fromMesh(this);\r\n    }\r\n    toGraph() {\r\n        return Graph.fromMesh(this);\r\n    }\r\n    // GETTERS\r\n    getType() {\r\n        if (this.links._width == MeshType.Points) {\r\n            return MeshType.Points;\r\n        }\r\n        else if (this.links._width == MeshType.Lines) {\r\n            return MeshType.Lines;\r\n        }\r\n        else if (this.links._width == MeshType.Triangles) {\r\n            return MeshType.Triangles;\r\n        }\r\n        else if (this.links._width == MeshType.Quads) {\r\n            return MeshType.Quads;\r\n        }\r\n        else {\r\n            return MeshType.Invalid;\r\n        }\r\n    }\r\n    getLinkVerts(f) {\r\n        let verts = new vector_array_Vector3Array(this.links._width);\r\n        this.links.getRow(f).forEach((v, i) => {\r\n            verts.setVector(i, this.verts.getVector(v));\r\n        });\r\n        return verts;\r\n    }\r\n    // MISC\r\n    calculateFaceNormals() {\r\n        let norms = [];\r\n        if (this.getType() != MeshType.Triangles) {\r\n            console.error("can only calculate normals from triangular meshes");\r\n            return norms;\r\n        }\r\n        let faceCount = this.links.count();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let verts = this.getLinkVerts(i).toList();\r\n            let normal = verts[1].subbed(verts[0]).cross(verts[2].subbed(verts[0])).normalize();\r\n            norms.push(normal);\r\n        }\r\n        return norms;\r\n    }\r\n    calculateVertexNormals() {\r\n        let faceCount = this.links.count();\r\n        let faceNormals = this.calculateFaceNormals();\r\n        // stack all face normals per vertex\r\n        let array = new vector_array_Vector3Array(this.verts.count());\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let normal = faceNormals[i];\r\n            this.links.getRow(i).forEach((vertexIndex) => {\r\n                let v = array.getVector(vertexIndex);\r\n                array.setVector(vertexIndex, v.add(normal));\r\n            });\r\n        }\r\n        // normalize all\r\n        let normals = array.toList();\r\n        for (let i = 0; i < normals.length; i++) {\r\n            normals[i].normalize();\r\n        }\r\n        return normals;\r\n    }\r\n}\r\n// ================ Help ==================\r\n// 0 ------- 1\r\n// | \\     / |\r\n// |  4---5  |\r\n// |  |   |  |\r\n// |  6---7  |\r\n// | /     \\ |\r\n// 2 ------- 3\r\nconst cubeFaces = [\r\n    [0, 1, 3, 2],\r\n    [4, 0, 2, 6],\r\n    [1, 0, 4, 5],\r\n    [1, 5, 7, 3],\r\n    [2, 3, 7, 6],\r\n    [5, 4, 6, 7],\r\n];\r\nfunction quadToTri(abcd) {\r\n    return [abcd[0], abcd[2], abcd[1], abcd[0], abcd[3], abcd[2]];\r\n}\r\n\n;// CONCATENATED MODULE: ./src/algorithms/marching-cubes.ts\n// name:    marching-cubes.ts\r\n// author:  Jos Feenstra\r\n// purpose: a marching cubes implementation useful for converting scalar discrete fields to contours\r\n\r\n\r\n// based upon:\r\n// http://paulbourke.net/geometry/polygonise/\r\n// Polygonising a scalar field\r\n// Also known as: "3D Contouring", "Marching Cubes", "Surface Reconstruction"\r\n// Written by Paul Bourke\r\n// May 1994\r\n//\r\n//\r\n// The cube model used:\r\n//\r\n//     (4) ------ 4 ------ (5)\r\n//     /|                  /|\r\n//    7 |                 5 |\r\n//   /  |                /  |\r\n// (7) ------ 6 ------ (6)  |\r\n//  |   8               |   9\r\n//  |   |               |   |\r\n//  |   |               |   |\r\n//  |  (0) ------ 0 ------ (1)\r\n//  11 /               10  /\r\n//  | 3                 | 1\r\n//  |/                  |/\r\n// (3) ------ 2 ------ (2)\r\n/*\r\n    Given a grid cell and an isolevel, calculate the triangular\r\n    facets required to represent the isosurface through the cell.\r\n    Return the number of triangular facets, the array "triangles"\r\n    will be loaded up with the vertices at most 5 triangular facets.\r\n     0 will be returned if the grid cell is either totally above\r\n    of totally below the isolevel.\r\n */\r\n// typedef struct {\r\n//     XYZ p[3];\r\n//  } TRIANGLE;\r\n//  typedef struct {\r\n//     XYZ p[8];\r\n//     double val[8];\r\n//  } GRIDCELL;\r\nclass Gridcell {\r\n    constructor() {\r\n        this.points = []; // 8\r\n        this.corner = []; // 8\r\n    }\r\n}\r\nclass Triangle {\r\n    constructor() {\r\n        this.xyz = []; // 3\r\n    }\r\n}\r\nconst edgeTable = (/* unused pure expression or super */ null && ([\r\n    0x0,\r\n    0x109,\r\n    0x203,\r\n    0x30a,\r\n    0x406,\r\n    0x50f,\r\n    0x605,\r\n    0x70c,\r\n    0x80c,\r\n    0x905,\r\n    0xa0f,\r\n    0xb06,\r\n    0xc0a,\r\n    0xd03,\r\n    0xe09,\r\n    0xf00,\r\n    0x190,\r\n    0x99,\r\n    0x393,\r\n    0x29a,\r\n    0x596,\r\n    0x49f,\r\n    0x795,\r\n    0x69c,\r\n    0x99c,\r\n    0x895,\r\n    0xb9f,\r\n    0xa96,\r\n    0xd9a,\r\n    0xc93,\r\n    0xf99,\r\n    0xe90,\r\n    0x230,\r\n    0x339,\r\n    0x33,\r\n    0x13a,\r\n    0x636,\r\n    0x73f,\r\n    0x435,\r\n    0x53c,\r\n    0xa3c,\r\n    0xb35,\r\n    0x83f,\r\n    0x936,\r\n    0xe3a,\r\n    0xf33,\r\n    0xc39,\r\n    0xd30,\r\n    0x3a0,\r\n    0x2a9,\r\n    0x1a3,\r\n    0xaa,\r\n    0x7a6,\r\n    0x6af,\r\n    0x5a5,\r\n    0x4ac,\r\n    0xbac,\r\n    0xaa5,\r\n    0x9af,\r\n    0x8a6,\r\n    0xfaa,\r\n    0xea3,\r\n    0xda9,\r\n    0xca0,\r\n    0x460,\r\n    0x569,\r\n    0x663,\r\n    0x76a,\r\n    0x66,\r\n    0x16f,\r\n    0x265,\r\n    0x36c,\r\n    0xc6c,\r\n    0xd65,\r\n    0xe6f,\r\n    0xf66,\r\n    0x86a,\r\n    0x963,\r\n    0xa69,\r\n    0xb60,\r\n    0x5f0,\r\n    0x4f9,\r\n    0x7f3,\r\n    0x6fa,\r\n    0x1f6,\r\n    0xff,\r\n    0x3f5,\r\n    0x2fc,\r\n    0xdfc,\r\n    0xcf5,\r\n    0xfff,\r\n    0xef6,\r\n    0x9fa,\r\n    0x8f3,\r\n    0xbf9,\r\n    0xaf0,\r\n    0x650,\r\n    0x759,\r\n    0x453,\r\n    0x55a,\r\n    0x256,\r\n    0x35f,\r\n    0x55,\r\n    0x15c,\r\n    0xe5c,\r\n    0xf55,\r\n    0xc5f,\r\n    0xd56,\r\n    0xa5a,\r\n    0xb53,\r\n    0x859,\r\n    0x950,\r\n    0x7c0,\r\n    0x6c9,\r\n    0x5c3,\r\n    0x4ca,\r\n    0x3c6,\r\n    0x2cf,\r\n    0x1c5,\r\n    0xcc,\r\n    0xfcc,\r\n    0xec5,\r\n    0xdcf,\r\n    0xcc6,\r\n    0xbca,\r\n    0xac3,\r\n    0x9c9,\r\n    0x8c0,\r\n    0x8c0,\r\n    0x9c9,\r\n    0xac3,\r\n    0xbca,\r\n    0xcc6,\r\n    0xdcf,\r\n    0xec5,\r\n    0xfcc,\r\n    0xcc,\r\n    0x1c5,\r\n    0x2cf,\r\n    0x3c6,\r\n    0x4ca,\r\n    0x5c3,\r\n    0x6c9,\r\n    0x7c0,\r\n    0x950,\r\n    0x859,\r\n    0xb53,\r\n    0xa5a,\r\n    0xd56,\r\n    0xc5f,\r\n    0xf55,\r\n    0xe5c,\r\n    0x15c,\r\n    0x55,\r\n    0x35f,\r\n    0x256,\r\n    0x55a,\r\n    0x453,\r\n    0x759,\r\n    0x650,\r\n    0xaf0,\r\n    0xbf9,\r\n    0x8f3,\r\n    0x9fa,\r\n    0xef6,\r\n    0xfff,\r\n    0xcf5,\r\n    0xdfc,\r\n    0x2fc,\r\n    0x3f5,\r\n    0xff,\r\n    0x1f6,\r\n    0x6fa,\r\n    0x7f3,\r\n    0x4f9,\r\n    0x5f0,\r\n    0xb60,\r\n    0xa69,\r\n    0x963,\r\n    0x86a,\r\n    0xf66,\r\n    0xe6f,\r\n    0xd65,\r\n    0xc6c,\r\n    0x36c,\r\n    0x265,\r\n    0x16f,\r\n    0x66,\r\n    0x76a,\r\n    0x663,\r\n    0x569,\r\n    0x460,\r\n    0xca0,\r\n    0xda9,\r\n    0xea3,\r\n    0xfaa,\r\n    0x8a6,\r\n    0x9af,\r\n    0xaa5,\r\n    0xbac,\r\n    0x4ac,\r\n    0x5a5,\r\n    0x6af,\r\n    0x7a6,\r\n    0xaa,\r\n    0x1a3,\r\n    0x2a9,\r\n    0x3a0,\r\n    0xd30,\r\n    0xc39,\r\n    0xf33,\r\n    0xe3a,\r\n    0x936,\r\n    0x83f,\r\n    0xb35,\r\n    0xa3c,\r\n    0x53c,\r\n    0x435,\r\n    0x73f,\r\n    0x636,\r\n    0x13a,\r\n    0x33,\r\n    0x339,\r\n    0x230,\r\n    0xe90,\r\n    0xf99,\r\n    0xc93,\r\n    0xd9a,\r\n    0xa96,\r\n    0xb9f,\r\n    0x895,\r\n    0x99c,\r\n    0x69c,\r\n    0x795,\r\n    0x49f,\r\n    0x596,\r\n    0x29a,\r\n    0x393,\r\n    0x99,\r\n    0x190,\r\n    0xf00,\r\n    0xe09,\r\n    0xd03,\r\n    0xc0a,\r\n    0xb06,\r\n    0xa0f,\r\n    0x905,\r\n    0x80c,\r\n    0x70c,\r\n    0x605,\r\n    0x50f,\r\n    0x406,\r\n    0x30a,\r\n    0x203,\r\n    0x109,\r\n    0x0,\r\n]));\r\nconst triTable = (/* unused pure expression or super */ null && ([\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],\r\n    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],\r\n    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],\r\n    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],\r\n    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],\r\n    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],\r\n    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],\r\n    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],\r\n    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],\r\n    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],\r\n    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],\r\n    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],\r\n    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],\r\n    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],\r\n    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],\r\n    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],\r\n    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],\r\n    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],\r\n    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],\r\n    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],\r\n    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],\r\n    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],\r\n    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],\r\n    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],\r\n    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],\r\n    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],\r\n    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],\r\n    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],\r\n    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],\r\n    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],\r\n    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],\r\n    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],\r\n    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],\r\n    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],\r\n    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],\r\n    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],\r\n    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],\r\n    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],\r\n    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],\r\n    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],\r\n    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],\r\n    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],\r\n    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],\r\n    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],\r\n    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],\r\n    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],\r\n    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],\r\n    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],\r\n    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],\r\n    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],\r\n    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],\r\n    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],\r\n    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],\r\n    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],\r\n    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],\r\n    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],\r\n    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],\r\n    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],\r\n    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],\r\n    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],\r\n    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],\r\n    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],\r\n    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],\r\n    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],\r\n    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],\r\n    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],\r\n    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],\r\n    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],\r\n    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],\r\n    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],\r\n    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],\r\n    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],\r\n    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],\r\n    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],\r\n    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],\r\n    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],\r\n    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],\r\n    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],\r\n    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],\r\n    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],\r\n    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],\r\n    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],\r\n    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],\r\n    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],\r\n    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],\r\n    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],\r\n    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],\r\n    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],\r\n    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],\r\n    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],\r\n    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],\r\n    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],\r\n    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n]));\r\nfunction polygonise(corners, values, level) {\r\n    let triangles = null;\r\n    // get the marching cube index based on corners\r\n    let cubeindex = 0;\r\n    if (values[0] < level)\r\n        cubeindex |= 1;\r\n    if (values[1] < level)\r\n        cubeindex |= 2;\r\n    if (values[2] < level)\r\n        cubeindex |= 4;\r\n    if (values[3] < level)\r\n        cubeindex |= 8;\r\n    if (values[4] < level)\r\n        cubeindex |= 16;\r\n    if (values[5] < level)\r\n        cubeindex |= 32;\r\n    if (values[6] < level)\r\n        cubeindex |= 64;\r\n    if (values[7] < level)\r\n        cubeindex |= 128;\r\n    /* Cube is entirely in/out of the surface */\r\n    let vertlist = []; // 12\r\n    if (edgeTable[cubeindex] == 0)\r\n        return Mesh.zero();\r\n    /* Find the vertices where the surface intersects the cube */\r\n    if (edgeTable[cubeindex] & 1)\r\n        vertlist[0] = lerp(level, corners[0], corners[1], values[0], values[1]);\r\n    if (edgeTable[cubeindex] & 2)\r\n        vertlist[1] = lerp(level, corners[1], corners[2], values[1], values[2]);\r\n    if (edgeTable[cubeindex] & 4)\r\n        vertlist[2] = lerp(level, corners[2], corners[3], values[2], values[3]);\r\n    if (edgeTable[cubeindex] & 8)\r\n        vertlist[3] = lerp(level, corners[3], corners[0], values[3], values[0]);\r\n    if (edgeTable[cubeindex] & 16)\r\n        vertlist[4] = lerp(level, corners[4], corners[5], values[4], values[5]);\r\n    if (edgeTable[cubeindex] & 32)\r\n        vertlist[5] = lerp(level, corners[5], corners[6], values[5], values[6]);\r\n    if (edgeTable[cubeindex] & 64)\r\n        vertlist[6] = lerp(level, corners[6], corners[7], values[6], values[7]);\r\n    if (edgeTable[cubeindex] & 128)\r\n        vertlist[7] = lerp(level, corners[7], corners[4], values[7], values[4]);\r\n    if (edgeTable[cubeindex] & 256)\r\n        vertlist[8] = lerp(level, corners[0], corners[4], values[0], values[4]);\r\n    if (edgeTable[cubeindex] & 512)\r\n        vertlist[9] = lerp(level, corners[1], corners[5], values[1], values[5]);\r\n    if (edgeTable[cubeindex] & 1024)\r\n        vertlist[10] = lerp(level, corners[2], corners[6], values[2], values[6]);\r\n    if (edgeTable[cubeindex] & 2048)\r\n        vertlist[11] = lerp(level, corners[3], corners[7], values[3], values[7]);\r\n    // create triangles\r\n    // ntriang = 0;\r\n    // for (let i = 0; triTable[cubeindex][i]!=-1; i+=3) {\r\n    //     triangles[ntriang].p[0] = vertlist[triTable[cubeindex][i  ]];\r\n    //     triangles[ntriang].p[1] = vertlist[triTable[cubeindex][i+1]];\r\n    //     triangles[ntriang].p[2] = vertlist[triTable[cubeindex][i+2]];\r\n    //     ntriang++;\r\n    // }\r\n    // return(ntriang);\r\n    return Mesh.zero();\r\n}\r\n/*\r\n    Linearly interpolate the position where an isosurface cuts\r\n    an edge between two vertices, each with their own scalar value\r\n */\r\nfunction lerp(level, p1, p2, valp1, valp2) {\r\n    return Vector3.fromLerpWeights(p1, p2, valp1, valp2, level);\r\n}\r\n\n;// CONCATENATED MODULE: ./src/app/app.ts\nclass App {\r\n    constructor(gl, des = "") {\r\n        // unique constructor\r\n        this.gl = gl;\r\n        this.name = this.constructor.name;\r\n        this.description = des;\r\n    }\r\n    ui(ui) {\r\n        // setup for UI\r\n    }\r\n    start() {\r\n        // additional setup of state\r\n    }\r\n    update(state) {\r\n        // updating state\r\n    }\r\n    draw(gl) {\r\n        // drawing state\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/system/ui.ts\n// name:    ui.js\r\n// author:  Jos Feenstra\r\n// purpose: lets create the UI using html & dom api, because why the hell not\r\n\r\nclass UI {\r\n    constructor(frame) {\r\n        this.globalContext = frame;\r\n        this.currentContext = frame;\r\n    }\r\n    // the context system makes sure that ui additions appear under the currently active,\r\n    // selected app, and that these ui elements are removed when switching to another app.\r\n    toggleVisibility() {\r\n        // simple toggle\r\n        if (this.globalContext.hidden) {\r\n            this.show();\r\n        }\r\n        else {\r\n            this.hide();\r\n        }\r\n    }\r\n    hide() {\r\n        this.globalContext.hidden = true;\r\n    }\r\n    show() {\r\n        this.globalContext.hidden = false;\r\n    }\r\n    addContext(appName) {\r\n        this.currentContext = this.globalContext;\r\n        let appDiv = this.addDiv(appName + " app-interface");\r\n        this.currentContext = appDiv;\r\n    }\r\n    setContext(appName) {\r\n        this.globalContext.getElementsByClassName(appName);\r\n    }\r\n    removeContext(appName) {\r\n        this.setContext(appName);\r\n        let count = this.currentContext.childElementCount;\r\n        for (let i = count - 1; i >= 0; i -= 1) {\r\n            this.currentContext.removeChild(this.currentContext.children.item(i));\r\n        }\r\n        let temp = this.currentContext;\r\n        this.currentContext = this.globalContext;\r\n        this.currentContext.removeChild(temp);\r\n    }\r\n    addElement(element, className = "") {\r\n        let el = document.createElement(element);\r\n        el.className = className;\r\n        this.currentContext.appendChild(el);\r\n        return el;\r\n    }\r\n    addDiv(classname, items = []) {\r\n        let div = this.addElement("div", classname);\r\n        items.forEach((item) => {\r\n            div.appendChild(item);\r\n        });\r\n        return div;\r\n    }\r\n    addBooleanParameter(param, onInput = () => { }) {\r\n        // create hacky button\r\n        // <label class="check-container">\r\n        //   <input type="checkbox" checked="checked">\r\n        //   <span class="checkmark"></span>\r\n        // </label>\r\n        let checkbox = this.addElement("input", "checkbox");\r\n        checkbox.type = "checkbox";\r\n        checkbox.addEventListener("change", () => {\r\n            let state = checkbox.checked;\r\n            param.set(state ? 1 : 0);\r\n            onInput(checkbox.valueAsNumber);\r\n            text1.innerText = param.name;\r\n        });\r\n        checkbox.checked = param.get() == 1;\r\n        // this needs to be done to make css happy\r\n        let checkcontainer = this.addElement("label", "check-container");\r\n        let checkmark = this.addElement("span", "checkmark");\r\n        checkcontainer.appendChild(checkbox);\r\n        checkcontainer.appendChild(checkmark);\r\n        // text\r\n        let text1 = this.addElement("p", "control-text");\r\n        text1.innerText = param.name;\r\n        // TODO update beyond our control\r\n        // param.onset = () => {\r\n        //     // console.log("TODO");\r\n        // };\r\n        this.addDiv("control", [text1, checkcontainer]);\r\n        return checkbox;\r\n    }\r\n    addParameter(param, onInput = () => { }) {\r\n        let p;\r\n        if (param instanceof EnumParameter) {\r\n            p = param.p;\r\n        }\r\n        else {\r\n            p = param;\r\n        }\r\n        // create slider itself\r\n        let slider = this.addRangeInput(p, onInput);\r\n        // create slider title\r\n        let text1 = this.addElement("p", "control-text");\r\n        text1.innerText = p.name;\r\n        // create slider value indicator\r\n        let text2 = this.addElement("p", "control-value");\r\n        if (param instanceof EnumParameter) {\r\n            text2.innerText = param.getName();\r\n        }\r\n        else {\r\n            text2.innerText = slider.value;\r\n        }\r\n        // put them all together\r\n        this.addDiv("control", [text1, slider, text2]);\r\n        // on reverse update\r\n        param.setSliderAndText(slider, text2);\r\n        // on update by user\r\n        slider.oninput = () => {\r\n            p.set(slider.valueAsNumber, false);\r\n            onInput(slider.valueAsNumber);\r\n            if (param instanceof EnumParameter) {\r\n                text2.innerText = param.getName();\r\n            }\r\n            else {\r\n                text2.innerText = slider.value;\r\n            }\r\n        };\r\n        return slider;\r\n    }\r\n    addRangeInput(param, onInput = () => { }) {\r\n        // a slider looks like this : <input type="range" min="1" max="100" step="1" value="50">\r\n        let slider = this.addElement("input", "control-slider");\r\n        slider.type = "range";\r\n        slider.min = param.min.toString();\r\n        slider.max = param.max.toString();\r\n        slider.valueAsNumber = param.state;\r\n        slider.step = param.step.toString();\r\n        return slider;\r\n    }\r\n    addText(text) {\r\n        let p = this.addElement("p", "ui-text");\r\n        p.innerText = text;\r\n    }\r\n    addButton(name, callback) {\r\n        let button = this.addElement("button", "control-button");\r\n        button.innerText = name;\r\n        button.addEventListener("click", callback);\r\n        let text1 = this.addElement("p", "control-text");\r\n        let control = this.addDiv("control", [text1, button]);\r\n        return control;\r\n    }\r\n    addDropdown(enumParam, onchange) {\r\n        // <select>\r\n        //  <option>Cappuccino</option>\r\n        //  <option>Mocha</option>\r\n        // </select>\r\n        let count = enumParam.values.length;\r\n        let dropdownSelector = this.addElement("select", "enum-selector dropdown-select");\r\n        for (let i = 0; i < count; i++) {\r\n            let o = this.addElement("option", "enum-item");\r\n            o.innerText = enumParam.values[i];\r\n            dropdownSelector.appendChild(o);\r\n        }\r\n        // console.log(e);\r\n        dropdownSelector.addEventListener("change", (e) => {\r\n            let target = e.target;\r\n            let i = target.selectedIndex;\r\n            enumParam.set(i);\r\n            onchange(i);\r\n        });\r\n        this.addDiv("dropdown-dark", [dropdownSelector]);\r\n        return dropdownSelector;\r\n    }\r\n}\r\n// a slider parameter\r\nclass Parameter {\r\n    constructor(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        this.name = name;\r\n        this.min = min;\r\n        this.max = max;\r\n        this.step = step;\r\n        this.state = state;\r\n        this.set(this.state);\r\n    }\r\n    static new(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        return new Parameter(name, state, min, max, step);\r\n    }\r\n    static newBoolean(name, state) {\r\n        return new Parameter(name, state ? 1 : 0, 0, 1, 1);\r\n    }\r\n    get() {\r\n        return this.state;\r\n    }\r\n    set(state, activateOnSet = true) {\r\n        // something is still wrong here...\r\n        let clamped = GeonMath.clamp(state, this.min, this.max);\r\n        let rest = state - this.min;\r\n        let times = Math.round(rest / this.step);\r\n        let stepped = this.min + this.step * times;\r\n        this.state = GeonMath.clamp(stepped, this.min, this.max);\r\n        if (activateOnSet && this.slider && this.text)\r\n            this.onset();\r\n    }\r\n    getNPermutations() {\r\n        return Math.min((this.max - this.min) / this.step + 1);\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        this.slider.valueAsNumber = this.state;\r\n        this.text.innerText = this.state.toString();\r\n    }\r\n}\r\n// a parameter representing distinct states\r\nclass EnumParameter {\r\n    constructor(p, values) {\r\n        this.p = p;\r\n        this.values = values;\r\n    }\r\n    static new(name, state, descriptions) {\r\n        return new EnumParameter(new Parameter(name, state, 0, descriptions.length - 1, 1), descriptions);\r\n    }\r\n    getName() {\r\n        return this.values[this.get()];\r\n    }\r\n    // passthroughs\r\n    get() {\r\n        return this.p.get();\r\n    }\r\n    set(state) {\r\n        return this.p.set(state);\r\n    }\r\n    getNPermutations() {\r\n        return this.p.getNPermutations();\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        this.slider.valueAsNumber = this.get();\r\n        this.text.innerText = this.getName();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/app/swap-app.ts\n// name:    swap-app\r\n// author:  Jos Feenstra\r\n// purpose: swap between different apps.\r\n//          - factory for initiazing these apps\r\n//          - making sure core deletes old apps\r\n\r\n\r\nclass SwapApp extends App {\r\n    constructor(gl, core, possibleApps) {\r\n        super(gl);\r\n        this.currentAppIndex = -1;\r\n        this.isuihidden = false;\r\n        this.core = core;\r\n        this.possibleApps = possibleApps;\r\n    }\r\n    getAppNames() {\r\n        let names = [];\r\n        let count = this.possibleApps.length;\r\n        for (let i = 0; i < count; i++) {\r\n            names.push(this.possibleApps[i].name.replace("App", ""));\r\n        }\r\n        return names;\r\n    }\r\n    ui(ui) {\r\n        let names = this.getAppNames();\r\n        this.param = EnumParameter.new("apps", 0, names);\r\n        ui.addDropdown(this.param, (i) => {\r\n            this.swap(i);\r\n        });\r\n    }\r\n    swapFromUrl(hash, ifnot) {\r\n        // select one of the apps based on an url\r\n        let test = hash.substr(1);\r\n        let names = this.getAppNames();\r\n        for (let i = 0; i < names.length; i++) {\r\n            if (names[i].toLowerCase() === test) {\r\n                this.swap(i);\r\n                return;\r\n            }\r\n        }\r\n        // no match\r\n        console.log("no hash match, defaulting...");\r\n        this.swap(ifnot);\r\n    }\r\n    swap(index) {\r\n        // todo do some range checking\r\n        let AppType = this.possibleApps[index];\r\n        if (this.currentAppIndex > -1) {\r\n            let PreviousType = this.possibleApps[this.currentAppIndex];\r\n            console.log("removing", PreviousType.name);\r\n            this.core.removeApp(PreviousType.name);\r\n        }\r\n        console.log("constructing", AppType.name);\r\n        this.currentAppIndex = index;\r\n        let app = new AppType(this.gl);\r\n        \r\n        this.core.addApp(app);\r\n    }\r\n    update(state) {\r\n        if (state.IsKeyPressed("m")) {\r\n            // simple toggle\r\n            this.core.ui.toggleVisibility();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/data/int-cube.ts\n\r\n// a Cube of voxels\r\nclass IntCube {\r\n    constructor(height, width, depth, data = []) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this._depth = depth;\r\n        let size = this._width * this._height * this._depth;\r\n        this.data = new Int32Array(size);\r\n        if (data == [] || data.length == 0)\r\n            this.fill(0);\r\n        else {\r\n            this.setData(data);\r\n        }\r\n    }\r\n    size() {\r\n        return this._width * this._height * this._depth;\r\n    }\r\n    // shallow copy\r\n    clone() {\r\n        let clone = new IntCube(this._height, this._width, this._depth);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.size())\r\n            throw "data.length does not match width * height " + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    fill(value) {\r\n        let size = this.size();\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    inRange(i, j, k) {\r\n        return !(i < 0 || j < 0 || k < 0 || i > this._width - 1 || j > this._height - 1 || k > this._depth - 1);\r\n    }\r\n    getIndex(i, j, k) {\r\n        return i * (this._height * this._depth) + j * this._depth + k;\r\n    }\r\n    getCoords(index) {\r\n        // javascript, dont you dare turn  \'int / int\' into a float...\r\n        let i = Math.floor(index / (this._height * this._depth)) % this._width;\r\n        let j = Math.floor(index / this._depth) % this._height;\r\n        let k = index % this._depth;\r\n        return new Vector3(i, j, k);\r\n    }\r\n    get(i, j, k) {\r\n        return this.data[this.getIndex(i, j, k)];\r\n    }\r\n    tryGet(i, j, k) {\r\n        if (this.inRange(i, j, k)) {\r\n            return this.data[this.getIndex(i, j, k)];\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    set(i, j, k, value) {\r\n        this.data[this.getIndex(i, j, k)] = value;\r\n    }\r\n    trySet(i, j, k, value) {\r\n        if (this.inRange(i, j, k)) {\r\n            this.data[this.getIndex(i, j, k)] = value;\r\n        }\r\n    }\r\n    iter(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    map(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/circle2.ts\n\r\n\r\nclass Circle2 {\r\n    constructor(center, radius) {\r\n        this.center = center;\r\n        this.radius = radius;\r\n    }\r\n    // thank you mr Mitteldorf for making me remember how basic math works\r\n    // http://mathforum.org/library/drmath/view/53027.html\r\n    // calculate the centers of two circles, defined by two points and a radius\r\n    static centersFromPPR(a, b, radius) {\r\n        // throw new Error("Method not implemented.");\r\n        // get in between length and halfway point\r\n        let normal = b.clone().sub(a);\r\n        let dis = normal.length();\r\n        let middle = a\r\n            .clone()\r\n            .add(b)\r\n            .scale(1 / 2);\r\n        // scalar length on mirror line (pythagoras)\r\n        let value = Math.pow(radius, 2) - Math.pow((dis / 2), 2);\r\n        if (value < -Const.TOLERANCE) {\r\n            // no sollution\r\n            return [];\r\n        }\r\n        else if (value < Const.TOLERANCE) {\r\n            // center roughly in the middle, so just return the middle\r\n            return [middle];\r\n        }\r\n        else {\r\n            // two circles possible:\r\n            let disToCenter = Math.pow(value, 0.5);\r\n            let normY = new Vector2(normal.y, -normal.x).normalize();\r\n            // move the middle point up and down\r\n            return [\r\n                middle.clone().add(normY.clone().scale(disToCenter)),\r\n                middle.clone().add(normY.clone().scale(-disToCenter)),\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/circle3.ts\n// purpose: represents a 3d circle\r\n\r\n\r\nclass Circle3 {\r\n    constructor(plane, radius) {\r\n        this.plane = plane;\r\n        this.radius = radius;\r\n    }\r\n    static fromCircle2(circle2, plane = Plane.WorldXY()) {\r\n        // elevate center of circle, make it the center of a plane\r\n        let center3d = plane.pushToWorld(circle2.center.to3D());\r\n        plane = plane.clone();\r\n        plane.center = center3d;\r\n        return new Circle3(plane, circle2.radius);\r\n    }\r\n    includes(p) {\r\n        // test if the point falls in range of the circle, by regarding\r\n        // the circle as a torus\r\n        // CHANGE NOTE: i set this to zero, for testing\r\n        // vertical error\r\n        let [projPoint, yError] = this.plane.closestPoint(p);\r\n        yError = yError / 3;\r\n        // horizontal error: get the difference between point\r\n        let xError = this.plane.center.clone().disTo(projPoint) - this.radius;\r\n        // length of total error vector needs to be smaller than the given\r\n        // tolerance\r\n        return Math.pow(yError, 2) + Math.pow(xError, 2) < Const.TOL_SQUARED;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/domain.ts\n// domain.ts\r\n//\r\n// author: Jos Feenstra\r\n// purpose: general representation of a domain / range / bound of numbers\r\n//\r\n\r\n\r\nclass domain_Domain {\r\n    constructor(t0 = 0.0, t1 = 1.0) {\r\n        // if (t0 > t1) console.error("created a domain with negative size.");\r\n        // if (t0 == t1) console.warn("created a domain with size is 0.0. could cause problems");\r\n        this.t0 = t0;\r\n        this.t1 = t1;\r\n    }\r\n    static fromRadius(r) {\r\n        return new domain_Domain(-r, r);\r\n    }\r\n    static fromInclude(data) {\r\n        // create a new domain which bounds all parsed values\r\n        let min = Number.MAX_VALUE;\r\n        let max = Number.MIN_VALUE;\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i] < min)\r\n                min = data[i];\r\n            if (data[i] > max)\r\n                max = data[i];\r\n        }\r\n        return new domain_Domain(min, max);\r\n    }\r\n    offset(t0Offset, t1Offset) {\r\n        this.t0 += t0Offset;\r\n        this.t1 += t1Offset;\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return value >= this.t0 && value <= this.t1;\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return this.t1 - this.t0;\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return (value - this.t0) / this.size();\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return t * this.size() + this.t0;\r\n    }\r\n    remap(value, other = new domain_Domain()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    *iter(count) {\r\n        // iterate over this Domain \'count\' number of times\r\n        let step = this.size() / count;\r\n        for (let i = this.t0; i < this.t1; i += step) {\r\n            yield i;\r\n        }\r\n    }\r\n    *iterStep(step) {\r\n        // iterate over this domain with a stepsize of \'step\'\r\n        for (let i = this.t0; i < this.t1; i += step) {\r\n            yield i;\r\n        }\r\n    }\r\n    // comform a number to the bound\r\n    comform(value) {\r\n        if (value < this.t0) {\r\n            return this.t0;\r\n        }\r\n        else if (value > this.t1) {\r\n            return this.t1;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n}\r\nclass domain_Domain2 {\r\n    constructor(x = new domain_Domain(), y = new domain_Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    static fromRadius(r) {\r\n        return new domain_Domain2(domain_Domain.fromRadius(r), domain_Domain.fromRadius(r));\r\n    }\r\n    static fromBounds(x0, x1, y0, y1) {\r\n        return new domain_Domain2(new domain_Domain(x0, x1), new domain_Domain(y0, y1));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 4 times\r\n        return new domain_Domain2(domain_Domain.fromInclude(data.getColumn(0)), domain_Domain.fromInclude(data.getColumn(1)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 4)\r\n            throw "need 4 values";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new Vector2(this.x.size(), this.y.size());\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new Vector2(this.x.normalize(value.x), this.y.normalize(value.y));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new Vector2(this.x.elevate(t.x), this.y.elevate(t.y));\r\n    }\r\n    remap(value, other = new domain_Domain2()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    corners() {\r\n        // render the extends of this boundary / domain\r\n        let dim = 2;\r\n        let corners = Math.pow(2, dim);\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                data.push(new Vector2(x, y));\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n}\r\nclass domain_Domain3 {\r\n    constructor(x = new domain_Domain(), y = new domain_Domain(), z = new domain_Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static fromBounds(x0, x1, y0, y1, z0, z1) {\r\n        return new domain_Domain3(new domain_Domain(x0, x1), new domain_Domain(y0, y1), new domain_Domain(z0, z1));\r\n    }\r\n    static fromRadius(r) {\r\n        return new domain_Domain3(domain_Domain.fromRadius(r), domain_Domain.fromRadius(r), domain_Domain.fromRadius(r));\r\n    }\r\n    static fromRadii(rx, ry, rz) {\r\n        return new domain_Domain3(domain_Domain.fromRadius(rx), domain_Domain.fromRadius(ry), domain_Domain.fromRadius(rz));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 6 times\r\n        return new domain_Domain3(domain_Domain.fromInclude(data.getColumn(0)), domain_Domain.fromInclude(data.getColumn(1)), domain_Domain.fromInclude(data.getColumn(2)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 6)\r\n            throw "need 6 values";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        this.z.offset(off[4], off[5]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y) && this.z.includes(value.z);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new Vector3(this.x.size(), this.y.size(), this.z.size());\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new Vector3(this.x.normalize(value.x), this.y.normalize(value.y), this.z.normalize(value.z));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new Vector3(this.x.elevate(t.x), this.y.elevate(t.y), this.z.elevate(t.z));\r\n    }\r\n    remap(value, other = new domain_Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    remapAll(values, other = new domain_Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let newValues = new Vector3Array(values.count());\r\n        for (let i = 0; i < values.count(); i++) {\r\n            let norm = this.normalize(values.getVector(i));\r\n            newValues.setVector(i, other.elevate(norm));\r\n        }\r\n        return newValues;\r\n    }\r\n    corners(matrix) {\r\n        // render the extends of this boundary / domain\r\n        let dim = 3;\r\n        let corners = 2 ^ dim;\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                for (let z of [this.z.t0, this.z.t1]) {\r\n                    data.push(matrix.multiplyVector(new Vector3(x, y, z)));\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/cube.ts\n// name:    cube.ts\r\n// author:  Jos Feenstra\r\n// purpose: Represents a cube in 3d space, in a certain pose.\r\n\r\n\r\nclass Cube {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    static new(plane, domain) {\r\n        return new Cube(plane, domain);\r\n    }\r\n    static fromRadius(point, radius) {\r\n        return new Cube(Plane.WorldXY().moveTo(point), Domain3.fromRadius(radius));\r\n    }\r\n    getCorners() {\r\n        return this.domain.corners(this.plane.matrix);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/geo.ts\n// name:    geo.ts\r\n// author:  Jos Feenstra\r\n// purpose: base class of all 3d geometry\r\n// note:    TODO\r\n\r\n// i want traits....\r\nclass Geo {\r\n    constructor() { }\r\n    clone() { }\r\n    transform(m) {\r\n        return this;\r\n    }\r\n    rotateX(radians) {\r\n        let rotater = Matrix4.newXRotation(radians);\r\n        // etc...\r\n    }\r\n    rotateY(radians) {\r\n        let rotater = Matrix4.newYRotation(radians);\r\n        // etc...\r\n    }\r\n    rotateZ(radians) {\r\n        let rotater = Matrix4.newZRotation(radians);\r\n        // etc...\r\n    }\r\n    rotate(radians, axis) {\r\n        let rotater = Matrix4.newAxisRotation(axis, radians);\r\n        // etc...\r\n    }\r\n    move(m) {\r\n        let mover = Matrix4.newScaler(m.x, m.y, m.z);\r\n        // etc...\r\n    }\r\n    scale(s) {\r\n        let scaler = Matrix4.newScaler(s.x, s.y, s.z);\r\n        // etc..\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/intersect.ts\n\r\n/**\r\n * @returns -1 if no intersection, 0 of parallel or touching, 1 if intersection;\r\n */\r\nfunction lineXplane(l1, l2, p1, p2, p3) {\r\n    let test1 = signed_volume(p1, p2, p3, l1);\r\n    let test2 = signed_volume(p1, p2, p3, l2);\r\n    if (Math.abs(test1) < Const.TOLERANCE || Math.abs(test2) < Const.TOLERANCE) {\r\n        return 0; // triangle touches plane with an edge\r\n    }\r\n    else if ((test1 < 0 && test2 > 0) || (test1 > 0 && test2 < 0)) {\r\n        return 1; // if 1 test pos and other negative -> line intersects plane!\r\n    }\r\n    else {\r\n        return -1; // no intersection\r\n    }\r\n}\r\n/**\r\n * Calculate if line and triangle intersect\r\n *\r\n * NOTE we could expand on the \'return 0\' and explore if its touching a\r\n    vertex, line, or surface of triange\r\n * @returns 0  if line touches triangle\r\n            -1 if line misses  triangle\r\n             1  if line crosses triangle\r\n */\r\nfunction lineXtriangle(l1, l2, p1, p2, p3) {\r\n    // line points must be on opposite sides of the triangle\r\n    // return immidiately if -1: it means no intersection always\r\n    let test0 = lineXplane(l1, l2, p1, p2, p3);\r\n    if (test0 == -1)\r\n        return -1;\r\n    // plane tests\r\n    let test1 = lineXplane(p1, p2, l1, l2, p3);\r\n    if (test1 == -1)\r\n        return -1;\r\n    let test2 = lineXplane(p2, p3, l1, l2, p1);\r\n    if (test2 == -1)\r\n        return -1;\r\n    let test3 = lineXplane(p3, p1, l1, l2, p2);\r\n    if (test3 == -1)\r\n        return -1;\r\n    // debug\r\n    // print("points: ", l1, l2, p1, p2, p3)\r\n    // print(\'tests:\', test0, test1, test2, test3)\r\n    // figure out if the line touches the triangle, or if it intersects\r\n    if (test0 == 1 && test1 == 1 && test2 == 1 && test3 == 1) {\r\n        return 1;\r\n    }\r\n    else {\r\n        // TODO based upon the different tests, we could determine what is hit\r\n        return 0;\r\n    }\r\n}\r\nfunction signed_volume(a, b, c, d) {\r\n    // with vertices a,b,c,d: get signed volume\r\n    // remember: vectors always remain state. We dont want to alter the abcd vectors.\r\n    a = a.clone();\r\n    b = b.clone();\r\n    c = c.clone();\r\n    return ((1 / 6) *\r\n        a\r\n            .clone()\r\n            .sub(d)\r\n            .dot(c.sub(d).cross(b.sub(d))));\r\n}\r\nfunction IsRoughly(test1, arg1) {\r\n    throw new Error("Function not implemented.");\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/line.ts\n\r\n\r\n// heavy weight Line class\r\nclass line_LineCurve2 {\r\n    constructor(from, to) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.vector = to.subbed(this.from);\r\n        this.normal = this.vector.normalized();\r\n        this.bounds = new Domain(0, this.vector.length());\r\n        this.length = this.vector.length();\r\n    }\r\n    at(t, bounded = true) {\r\n        if (bounded)\r\n            t = this.bounds.comform(t);\r\n        return Vector2.fromLerp(this.from, this.to, t / this.length);\r\n    }\r\n    atNormal(t, bounded = true) {\r\n        if (bounded)\r\n            t = new Domain(0, 1).comform(t);\r\n        return Vector2.fromLerp(this.from, this.to, t);\r\n    }\r\n    closestPoint(point, bounded = true) {\r\n        const d = this.vector.length();\r\n        if (d === 0)\r\n            return;\r\n        let lineToPoint = point.subbed(this.from);\r\n        let dot = lineToPoint.dot(this.vector);\r\n        return this.at(dot, bounded);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/rectangle.ts\n\r\n\r\nclass Rectangle2 {\r\n    constructor(pose, domain) {\r\n        this.pose = pose;\r\n        this.domain = domain;\r\n    }\r\n    center() {\r\n        return this.pose.transformVector(new Vector2(0, 0));\r\n    }\r\n    getVertices() {\r\n        let verts = [\r\n            new Vector2(this.domain.x.t0, this.domain.y.t0),\r\n            new Vector2(this.domain.x.t1, this.domain.y.t0),\r\n            new Vector2(this.domain.x.t0, this.domain.y.t1),\r\n            new Vector2(this.domain.x.t1, this.domain.y.t1),\r\n        ];\r\n        verts.forEach((v) => this.pose.transformVector(v));\r\n        return verts;\r\n    }\r\n    to3D() {\r\n        let mat4 = this.pose.toMat4();\r\n        return new rectangle_Rectangle3(new Plane(mat4), this.domain);\r\n    }\r\n}\r\nclass rectangle_Rectangle3 {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    getCorners() {\r\n        let corners = this.domain.corners();\r\n        let corners3 = corners.map((c) => this.plane.pushToWorld(c.to3D()));\r\n        return corners3;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/geo/triangle.ts\n\r\n\r\n\r\n\r\nclass triangle_Triangle2 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return Vector2Array.fromList([this.a, this.b, this.c]);\r\n    }\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.scaled(bari.x);\r\n        let b = this.b.scaled(bari.y);\r\n        let c = this.c.scaled(bari.z);\r\n        return a.add(b).add(c);\r\n    }\r\n    closestPoint(point) {\r\n        // figure out roughly where the point is.\r\n        // note:\r\n        let ab = point.sign(this.a, this.b);\r\n        let bc = point.sign(this.b, this.c);\r\n        let ca = point.sign(this.c, this.a);\r\n        // if its fully within, return it!\r\n        if ((ab < 0 && bc < 0 && ca < 0) || (ab > 0 && bc > 0 && ca > 0)) {\r\n            console.log("fully inside!");\r\n            return point;\r\n        }\r\n        else {\r\n            let abs = Math.abs(ab);\r\n            let bcs = Math.abs(bc);\r\n            let cas = Math.abs(ca);\r\n            if (abs < bcs && abs < cas) {\r\n                // ab\r\n                return new LineCurve2(this.a, this.b).closestPoint(point);\r\n            }\r\n            else if (bcs < cas) {\r\n                // bc\r\n                return new LineCurve2(this.b, this.c).closestPoint(point);\r\n            }\r\n            else {\r\n                // ca\r\n                return new LineCurve2(this.c, this.a).closestPoint(point);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass triangle_Triangle3 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return [this.a, this.b, this.c];\r\n    }\r\n    getPlane() {\r\n        return Plane.from3pt(this.a, this.b, this.c);\r\n    }\r\n    to2D(plane = Plane.WorldXY()) {\r\n        return new triangle_Triangle2(plane.pullToPlane(this.a).to2D(), plane.pullToPlane(this.b).to2D(), plane.pullToPlane(this.c).to2D());\r\n    }\r\n    closestPoint(point) {\r\n        let plane = this.getPlane();\r\n        let [cp, _] = plane.closestPoint(point);\r\n        let planeCP = plane.pullToPlane(cp);\r\n        let planeTriangle = this.to2D(plane);\r\n        return point;\r\n    }\r\n    // Transcribed from Christer Ericson\'s Real-Time Collision Detection:\r\n    // http://realtimecollisiondetection.net/\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.clone().scale(bari.x);\r\n        let b = this.b.clone().scale(bari.y);\r\n        let c = this.c.clone().scale(bari.z);\r\n        return a.added(b).add(c);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/img/kernels.ts\n\r\n// kernels\r\nclass Kernels {\r\n    // inspired from https://github.com/yuta1984/CannyJS/blob/master/canny.js\r\n    static generateGaussianKernel(sigmma, size) {\r\n        // messy, probably auto-generated\r\n        var e, gaussian, i, j, kernel, s, sum, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;\r\n        s = sigmma;\r\n        e = 2.718;\r\n        kernel = new float_matrix_FloatMatrix(size, size);\r\n        sum = 0;\r\n        for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\r\n            x = -(size - 1) / 2 + i;\r\n            for (j = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {\r\n                y = -(size - 1) / 2 + j;\r\n                gaussian = (1 / (2 * Math.PI * s * s)) * Math.pow(e, -(x * x + y * y) / (2 * s * s));\r\n                kernel.set(i, j, gaussian);\r\n                sum += gaussian;\r\n            }\r\n        }\r\n        for (i = _k = 0, _ref2 = size - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {\r\n            for (j = _l = 0, _ref3 = size - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {\r\n                kernel.set(i, j, kernel.get(i, j) / sum);\r\n            }\r\n        }\r\n        return kernel;\r\n    }\r\n}\r\nKernels.SmoothKernel = new float_matrix_FloatMatrix(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1]).forEachValue((i) => (i * 1) / 9);\r\nKernels.SmoothKernel5 = new float_matrix_FloatMatrix(5, 5, [\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n    1,\r\n]).forEachValue((v) => (v * 1) / 25);\r\nKernels.Gauss5 = new float_matrix_FloatMatrix(5, 5, [\r\n    2,\r\n    4,\r\n    5,\r\n    4,\r\n    2,\r\n    4,\r\n    9,\r\n    12,\r\n    9,\r\n    4,\r\n    5,\r\n    12,\r\n    15,\r\n    12,\r\n    5,\r\n    4,\r\n    9,\r\n    12,\r\n    9,\r\n    4,\r\n    2,\r\n    4,\r\n    5,\r\n    4,\r\n    2,\r\n]).forEachValue((v) => (v * 1) / 159);\r\nKernels.TestKernel = new float_matrix_FloatMatrix(3, 3, [1, 0, -1, 0, 0, 0, -1, 0, 1]);\r\nKernels.SobelLeft = new float_matrix_FloatMatrix(3, 3, [1, 2, 1, 0, 0, 0, -1, -2, -1]);\r\nKernels.SobelRight = new float_matrix_FloatMatrix(3, 3, [-1, -2, -1, 0, 0, 0, 1, 2, 1]);\r\nKernels.SobelUp = new float_matrix_FloatMatrix(3, 3, [1, 0, -1, 2, 0, -2, 1, 0, -1]);\r\nKernels.SobelDown = new float_matrix_FloatMatrix(3, 3, [-1, 0, 1, -2, 0, 2, -1, 0, 1]);\r\n\n;// CONCATENATED MODULE: ./src/mesh/line-array.ts\n// name:    line-render-data.ts\r\n// author:  Jos Feenstra\r\n// purpose: represents an object which can be fed directly to a linerenderer.\r\n//          use it to not continuously have to calculate these aspects if the underlying object is unchanged.\r\n\r\n\r\n\r\n// represents a collection of multiple lines. These could form 1 polyline, but this is not a requirement\r\nclass line_array_LineArray {\r\n    constructor(verts, ids) {\r\n        this.verts = verts;\r\n        if (ids == undefined) {\r\n            this.links = line_array_getDefaultIndices(verts.count());\r\n        }\r\n        else {\r\n            this.links = ids;\r\n        }\r\n    }\r\n    // this assumes even vectices are \'from\' points, and odd vertices are \'to\' points\r\n    static fromLines(verts) {\r\n        let data = vector_array_getGeneralFloatMatrix(verts);\r\n        return new line_array_LineArray(data);\r\n    }\r\n    // get all lines from a mesh\r\n    static fromMesh(rend, uv = false) {\r\n        // 3 edges per face, 2 indices per edge\r\n        let mesh = rend.mesh;\r\n        let count = mesh.links.count() * 6;\r\n        let data = new Uint16Array(count);\r\n        for (let i = 0; i < mesh.links.count(); i++) {\r\n            let iData = i * 6;\r\n            data[iData] = mesh.links.get(i, 0);\r\n            data[iData + 1] = mesh.links.get(i, 1);\r\n            data[iData + 2] = mesh.links.get(i, 1);\r\n            data[iData + 3] = mesh.links.get(i, 2);\r\n            data[iData + 4] = mesh.links.get(i, 2);\r\n            data[iData + 5] = mesh.links.get(i, 0);\r\n        }\r\n        if (uv) {\r\n            return new line_array_LineArray(rend.uvs, data);\r\n        }\r\n        else {\r\n            return new line_array_LineArray(mesh.verts, data);\r\n        }\r\n    }\r\n    // create lines as a grid centered at a plane\r\n    static fromGrid(plane, count, dis) {\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = new vector_array_Vector3Array(count * 4);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.setVector(i * 2, new vector_Vector3(t, -halfTotalSize, 0));\r\n            lines.setVector(i * 2 + 1, new vector_Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.setVector(2 * count + i * 2, new vector_Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.setVector(2 * count + i * 2 + 1, new vector_Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new line_array_LineArray(lines);\r\n    }\r\n    // get all lines from a plane\r\n    static fromPlane(plane) {\r\n        let count = const_Const.PLANE_RENDER_LINECOUNT;\r\n        let dis = const_Const.PLANE_RENDER_LINEDISTANCE;\r\n        let disSmall = dis / 10;\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = new vector_array_Vector3Array(count * 4 + 5 * 2);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.setVector(i * 2, new vector_Vector3(t, -halfTotalSize, 0));\r\n            lines.setVector(i * 2 + 1, new vector_Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.setVector(2 * count + i * 2, new vector_Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.setVector(2 * count + i * 2 + 1, new vector_Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // icon I  to show ihat\r\n        let iconLine1 = lines.count() - 10;\r\n        lines.setVector(iconLine1, new vector_Vector3(halfTotalSize + disSmall, -disSmall, 0));\r\n        lines.setVector(iconLine1 + 1, new vector_Vector3(halfTotalSize + disSmall * 4, disSmall, 0));\r\n        let iconLine2 = lines.count() - 8;\r\n        lines.setVector(iconLine2, new vector_Vector3(halfTotalSize + disSmall, disSmall, 0));\r\n        lines.setVector(iconLine2 + 1, new vector_Vector3(halfTotalSize + disSmall * 4, -disSmall, 0));\r\n        // icon II to show jhat\r\n        let iconLine3 = lines.count() - 6;\r\n        lines.setVector(iconLine3, new vector_Vector3(0, halfTotalSize + disSmall * 2.5, 0));\r\n        lines.setVector(iconLine3 + 1, new vector_Vector3(disSmall, halfTotalSize + disSmall * 4, 0));\r\n        let iconLine4 = lines.count() - 4;\r\n        lines.setVector(iconLine4, new vector_Vector3(disSmall, halfTotalSize + disSmall, 0));\r\n        lines.setVector(iconLine4 + 1, new vector_Vector3(-disSmall, halfTotalSize + disSmall * 4, 0));\r\n        // icon III to show khat / normal direction\r\n        let iconLine5 = lines.count() - 2;\r\n        lines.setVector(iconLine5, new vector_Vector3(0, 0, 0));\r\n        lines.setVector(iconLine5 + 1, new vector_Vector3(0, 0, dis));\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new line_array_LineArray(lines);\r\n    }\r\n    // get all lines representing a circle in 2d. use an optional matrix to\r\n    static fromCircle(c) {\r\n        let count = const_Const.CIRCLE_SEGMENTS;\r\n        // let count = 12;\r\n        let verts = new vector_array_Vector3Array(count);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            // radial fraction of a circle\r\n            let t = (i / count) * (Math.PI * 2);\r\n            verts.setVector(i, c.plane.pushToWorld(new vector_Vector3(Math.cos(t) * c.radius, Math.sin(t) * c.radius, 0)));\r\n        }\r\n        return new line_array_LineArray(verts, getPairIndices(count));\r\n    }\r\n    // turn a spline into a polyline, and render it\r\n    static fromSpline() {\r\n        throw "todo!";\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = vector_array_Vector3Array.fromList(cube.getCorners());\r\n        return new line_array_LineArray(verts);\r\n    }\r\n    static fromJoin(lines) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let idsCount = 0;\r\n        let vertCount = 0;\r\n        for (let line of lines) {\r\n            idsCount += line.links.length;\r\n            vertCount += line.verts.count();\r\n        }\r\n        let verts = new vector_array_Vector3Array(vertCount);\r\n        let ids = new Uint16Array(idsCount);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let lineset of lines) {\r\n            for (let i = 0; i < lineset.verts.count(); i++) {\r\n                verts.setRow(accVerts + i, lineset.verts.getRow(i));\r\n            }\r\n            for (let i = 0; i < lineset.links.length; i++) {\r\n                ids[accFaces + i] = lineset.links[i] + accVerts;\r\n            }\r\n            accVerts += lineset.verts.count();\r\n            accFaces += lineset.links.length;\r\n        }\r\n        return new line_array_LineArray(verts, ids);\r\n    }\r\n}\r\n// just get an int sequence from 0 to length.\r\nfunction line_array_getDefaultIndices(count) {\r\n    let data = new Uint16Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i] = i;\r\n    }\r\n    return data;\r\n}\r\nfunction getPairIndices(count) {\r\n    // given count of 3 => return 0,1 | 1,2 | 2,0\r\n    let length = count * 2;\r\n    let data = new Uint16Array(length);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i * 2] = i;\r\n        data[i * 2 + 1] = (i + 1) % count;\r\n    }\r\n    return data;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/math/ray.ts\n// author:  Jos Feenstra\r\n// purpose: infinite Ray used for projection and similar actions\r\n// notes:   found some nice examples at https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld004.htm\r\n\r\nclass Ray {\r\n    // i do this to force intent : from points, or from normal. Both vector3, so otherwise confusing\r\n    constructor(origin, normal) {\r\n        this.origin = origin;\r\n        this.normal = normal.normalize();\r\n    }\r\n    static fromNormal(origin, normal) {\r\n        return new Ray(origin, normal);\r\n    }\r\n    static fromPoints(origin, through) {\r\n        return new Ray(origin, through.subbed(origin).normalize());\r\n    }\r\n    at(t) {\r\n        return this.origin.added(this.normal.scaled(t));\r\n    }\r\n    xPlane(plane) {\r\n        // ray : pt = rOrigin + t * rNormal\r\n        // plane : a, b, c, d -> pNormal(a, b, c) , d\r\n        // plane : P . N + d = 0;\r\n        // substitute for p:\r\n        // t = -(rOrigin . N + d) / (V . N)\r\n        let ray = this; // to be clear\r\n        return -(ray.origin.dot(plane.normal) + plane.d) / ray.normal.dot(plane.normal);\r\n    }\r\n    toLine(length) {\r\n        let toPoint = this.at(length);\r\n        return line_array_LineArray.fromLines([this.origin, toPoint]);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/mesh/topo-mesh.ts\n\r\n\r\n\r\n\r\n\r\n\r\n// a mesh with topological information\r\nclass TopoMesh extends (/* unused pure expression or super */ null && (Renderable)) {\r\n    // private -> should only be used with factory methods\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        super(vertCount, normCount, uvCount, faceCount, texture);\r\n        this.lastTouched = 0; // needed for triangle walk\r\n        this.neighborMap = new IntMatrix(this.mesh.links.count(), 3);\r\n    }\r\n    static copyFromRenderable(rend) {\r\n        let topoMesh = new TopoMesh(rend.mesh.verts.count(), rend.norms.count(), rend.uvs.count(), rend.mesh.links.count());\r\n        topoMesh.mesh.verts = rend.mesh.verts.clone();\r\n        topoMesh.norms = rend.norms.clone();\r\n        topoMesh.uvs = rend.uvs.clone();\r\n        topoMesh.mesh.links = rend.mesh.links.clone();\r\n        topoMesh.setNeighborMap();\r\n        return topoMesh;\r\n    }\r\n    setNeighborMap() {\r\n        // this method fills this.neighborMap after data is loaded\r\n        //\r\n        let edges = new HashTable();\r\n        let pairs = new HashTable();\r\n        // 1 | per triangle\r\n        this.mesh.links.forEachRow((f, faceIndex) => {\r\n            let faceEdges = [\r\n                [f[0], f[1]],\r\n                [f[1], f[2]],\r\n                [f[2], f[0]],\r\n            ];\r\n            faceEdges.forEach((e) => {\r\n                // if (4, 1), orientation is True | if (1, 4), orientation is False\r\n                let orientation = e[0] > e[1];\r\n                // use this min max construction to only store one edge per triangle pair\r\n                // let edge: [number, number] = e.sort();\r\n                let edge = new Int32Array([Math.min(...e), Math.max(...e)]);\r\n                // console.log(edge);\r\n                if (!edges.has(edge)) {\r\n                    // orientation, first tr ID, second tr ID\r\n                    edges.set(edge, [orientation, faceIndex, -1]);\r\n                }\r\n                else {\r\n                    // an edge match is made!\r\n                    // console.log("matched!");\r\n                    let other = edges.get(edge);\r\n                    let nbOrientation = other[0];\r\n                    let nbIndex = other[1];\r\n                    other[2] = faceIndex;\r\n                    edges.set(edge, other); // edge is put away again, if an edge map is ever needed.\r\n                    // assign neighbours\r\n                    this.setNb(faceIndex, edge, nbIndex);\r\n                    this.setNb(nbIndex, edge, faceIndex);\r\n                    // use this info to fill self.pairs\r\n                    // if orientation != other orientation, edge is \'good\' -> False\r\n                    // else -> True, one of the neighbour triangles needs to be flipped\r\n                    let pair = [nbIndex, faceIndex];\r\n                    pair.sort();\r\n                    // pair = (Math.min(...pair), Math.max(...pair))\r\n                    if (orientation != nbOrientation)\r\n                        pairs.set(pair, false);\r\n                    else\r\n                        pairs.set(pair, true);\r\n                }\r\n            });\r\n        });\r\n        // Done. Give feedback\r\n        let count = 0;\r\n        // for pair in pairs.items():\r\n        //     if not pair: count +=1;\r\n        console.log("number of \'wrong\' face neighbours: ", count);\r\n        return;\r\n    }\r\n    /**\r\n     * Get the triangle based on a UV point somewhere on the mesh.\r\n     * Returns -1 if the point is not on the mesh TODO OR IF THE PATH HAS HOLES IN IT TODO FIX THIS!\r\n     * @param  {Vector2} point\r\n     * @returns triangleIndex, or -1 if failure\r\n     */\r\n    walkUV(point) {\r\n        // start where we last stopped\r\n        let faceIndex = this.lastTouched;\r\n        // make sure we never take more steps than triangles in the triangulation.\r\n        // this would mean something went wrong\r\n        let count = this.mesh.links.count();\r\n        for (let _ = 0; _ < count; _++) {\r\n            // i dont know how, but if we accidentally landed outside of the mesh\r\n            if (faceIndex == -1) {\r\n                return -1;\r\n            }\r\n            for (let i = 0; i < 3; i++) {\r\n                let j = (i + 1) % 3;\r\n                let face = this.mesh.links.getRow(faceIndex);\r\n                let edge = [face[i], face[j]];\r\n                let b = this.uvs.getVector(edge[0]);\r\n                let c = this.uvs.getVector(edge[1]);\r\n                let sign = point.sign(b, c);\r\n                if (sign < 0) {\r\n                    faceIndex = this.getNb(faceIndex, edge);\r\n                    // if its ouside, return -1\r\n                    if (faceIndex == -1)\r\n                        return -1;\r\n                    // else: go there immidiately\r\n                    this.lastTouched = faceIndex;\r\n                    break;\r\n                }\r\n                // if this ran 3 times, the point must be within the triangle\r\n                if (i == 2)\r\n                    return faceIndex;\r\n            }\r\n        }\r\n        // something went wrong\r\n        return -1;\r\n    }\r\n    // find the faces closest to the point\r\n    // -1 if the mesh does not contain triangles\r\n    closestFaces(point) {\r\n        let closestVertexId = this.mesh.verts.closestId(point);\r\n        // get all face ids containing closestVertex, along with their centers\r\n        let closestFaces = [];\r\n        //let centers: Vector3[] = []\r\n        this.mesh.links.forEachRow((tr, i) => {\r\n            if (tr.includes(closestVertexId)) {\r\n                closestFaces.push(i);\r\n                //let center = Vector3Array.fromList(this.getFacePoints(i, false)).average();\r\n                //centers.push(center);\r\n            }\r\n        });\r\n        // select the triangle with the closest baricenter\r\n        return closestFaces;\r\n    }\r\n    elevate(p) {\r\n        // \'elevate\' a point in UV space to vertex space using a barycentric remap\r\n        // figure out where this point is located on the mesh\r\n        let face = this.walkUV(p);\r\n        if (face == -1) {\r\n            console.warn("got a point not on triangle...");\r\n            return new Vector3(0, 0, 0);\r\n        }\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr2.toBarycentric(p);\r\n        return tr3.fromBarycentric(bari);\r\n    }\r\n    closestFace(p) {\r\n        // NOTE this doesnt really work all that well...\r\n        let faceIds = this.closestFaces(p);\r\n        let closestPoints = new Vector3Array(faceIds.length);\r\n        faceIds.forEach((id, i) => {\r\n            let tr = this.getTriangle3(id);\r\n            let cp = tr.closestPoint(p);\r\n            closestPoints.setVector(i, cp);\r\n        });\r\n        // find the closest closest point\r\n        let id = closestPoints.closestId(p);\r\n        return faceIds[id];\r\n    }\r\n    // \'flatten\' a point in vertex space to uv space using a barycentric remap\r\n    // NOTE : this is not exactly a \'project to closest triangle\', something like that wouldnt always work\r\n    flatten(p, face) {\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr3.toBarycentric(p);\r\n        return tr2.fromBarycentric(bari);\r\n    }\r\n    // combo\r\n    flattenClosestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        return this.flatten(p, face);\r\n    }\r\n    closestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        let triangle = this.getTriangle3(face);\r\n        let bari = triangle.toBarycentric(p);\r\n        return triangle.fromBarycentric(bari);\r\n    }\r\n    getTriangle2(id) {\r\n        let p = this.getFacePoints(id, true);\r\n        return new Triangle2(p[0], p[1], p[2]);\r\n    }\r\n    getTriangle3(id) {\r\n        let p = this.getFacePoints(id, false);\r\n        return new Triangle3(p[0], p[1], p[2]);\r\n    }\r\n    setNb(faceIndex, commonEdge, nbIndex) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                this.neighborMap.set(faceIndex, j, nbIndex);\r\n                return;\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw "these are not actually neighbors!";\r\n    }\r\n    getNb(faceIndex, commonEdge) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                return this.neighborMap.get(faceIndex, j);\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw "common edge does not match triangle index!";\r\n    }\r\n    getFacePoints(tr, uv) {\r\n        let pointIds = this.mesh.links.getRow(tr);\r\n        if (uv) {\r\n            return [this.uvs.getVector(pointIds[0]), this.uvs.getVector(pointIds[1]), this.uvs.getVector(pointIds[2])];\r\n        }\r\n        else {\r\n            return [\r\n                this.mesh.verts.getVector(pointIds[0]),\r\n                this.mesh.verts.getVector(pointIds[1]),\r\n                this.mesh.verts.getVector(pointIds[2]),\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/render/camera.ts\n// author : Jos Feenstra\r\n// purpose : contain all logic regarding\r\n\r\n\r\n\r\n\r\n\r\nclass Camera {\r\n    constructor(canvas, z_offset = 1, canMove = false) {\r\n        this.angleAlpha = 0; // rotation x\r\n        this.angleBeta = 0; // rotation y\r\n        this.mousePos = vector_Vector2.zero();\r\n        // camera matrix properties\r\n        this.fov = (20 * Math.PI) / 100;\r\n        this.zFar = 10000;\r\n        this.zNear = 0.1;\r\n        // other consts\r\n        this.speed = 1;\r\n        this.worldPlane = plane_Plane.WorldXY();\r\n        this.canMove = canMove;\r\n        this.pos = new vector_Vector3(0, 0, 0);\r\n        this.z_offset = -z_offset;\r\n        this.offset = new vector_Vector3(0, 0, -z_offset);\r\n        this.updateMatrices(canvas);\r\n    }\r\n    new(canvas, zOffset = 1, canMove = false) {\r\n        return new Camera(canvas, zOffset, canMove);\r\n    }\r\n    update(state) {\r\n        this.updateControls(state);\r\n        this.updateMatrices(state.canvas);\r\n        this.updateClick(state);\r\n        if (state.IsKeyPressed("p")) {\r\n            console.log(`printing camera status. \n                pos: ${this.pos}, \n                offset: ${this.offset}, \n                speed: ${this.speed}, \n                alpha ${this.angleAlpha},\n                beta: ${this.angleBeta}`);\r\n            console.log("speed is now: " + this.speed);\r\n        }\r\n    }\r\n    set(offset, alpha, beta) {\r\n        this.z_offset = offset;\r\n        this.angleAlpha = alpha;\r\n        this.angleBeta = beta;\r\n    }\r\n    updateMatrices(canvas) {\r\n        this.worldMatrix = this.getWorldMatrix();\r\n        this.projectMatrix = this.getProjectionMatrix(canvas);\r\n        this.totalMatrix = this.worldMatrix.multiplied(this.projectMatrix);\r\n    }\r\n    lookat(position, target) {\r\n        // set matrices to the thing\r\n        let matrix = matrix_Matrix4.newLookAt(position, target, this.worldPlane.khat);\r\n    }\r\n    updateClick(state) {\r\n        // todo\r\n    }\r\n    updateControls(state) {\r\n        let deltaScroll = state.scrollValue * 1.2;\r\n        this.offset.z = Math.min(-0.001, this.z_offset - deltaScroll);\r\n        if (state.IsKeyPressed("Shift")) {\r\n            this.speed *= 2;\r\n        }\r\n        if (state.IsKeyPressed("Control")) {\r\n            this.speed = Math.max(this.speed * 0.5, 0.1);\r\n        }\r\n        // deal with mouse\r\n        let prevPos = this.mousePos.clone();\r\n        this.mousePos = state.mousePos.clone();\r\n        let delta = prevPos.clone().sub(this.mousePos);\r\n        this.getMouseWorldRay(state.canvas.width, state.canvas.height);\r\n        if (state.mouseRightDown) {\r\n            this.angleAlpha = GeonMath.clamp(this.angleAlpha + delta.y * 0.01, 0, Math.PI);\r\n            this.angleBeta += delta.x * -0.01;\r\n        }\r\n        function relativeUnitY(angle) {\r\n            let m = matrix_Matrix4.newZRotation(angle);\r\n            return m.multiplyVector(vector_Vector3.unitY());\r\n        }\r\n        function relativeUnitX(angle) {\r\n            let m = matrix_Matrix4.newZRotation(angle);\r\n            return m.multiplyVector(vector_Vector3.unitX());\r\n        }\r\n        if (!this.canMove) {\r\n            return;\r\n        }\r\n        if (state.IsKeyDown("s"))\r\n            this.pos.add(relativeUnitY(-this.angleBeta).scale(0.01 * this.speed));\r\n        if (state.IsKeyDown("w"))\r\n            this.pos.add(relativeUnitY(-this.angleBeta).scale(-0.01 * this.speed));\r\n        if (state.IsKeyDown("a"))\r\n            this.pos.add(relativeUnitX(-this.angleBeta).scale(0.01 * this.speed));\r\n        if (state.IsKeyDown("d"))\r\n            this.pos.add(relativeUnitX(-this.angleBeta).scale(-0.01 * this.speed));\r\n        if (state.IsKeyDown("q"))\r\n            this.pos.z += 0.01 * this.speed;\r\n        if (state.IsKeyDown("e"))\r\n            this.pos.z -= 0.01 * this.speed;\r\n    }\r\n    getCameraPoint() {\r\n        return this.worldMatrix.inverse().multiplyVector(new vector_Vector3(0, 0, 0));\r\n    }\r\n    getMouseWorldRay(canvasWidth, canvasHeight, useMouse = true) {\r\n        // get a ray from origin through mousepos\r\n        // mouse unit screen position:\r\n        //       -------------- -0.5\r\n        //       |            |\r\n        //       |      .(0,0)|\r\n        //       |            |\r\n        //       -------------- 0.5\r\n        //     -0.72        0.72\r\n        //    (0.72 = 0.5 * aspect)\r\n        //\r\n        let size = 0.5; // size indicator of the fustrum\r\n        let mp = this.mousePos;\r\n        let aspect = canvasWidth / canvasHeight;\r\n        let mouseUnitX = (-size + mp.x / canvasWidth) * aspect;\r\n        let mouseUnitY = -size + mp.y / canvasHeight;\r\n        let f = size / Math.tan(this.fov / 2); // focal length\r\n        let invWorld = this.worldMatrix.inverse();\r\n        let origin = invWorld.multiplyVector(new vector_Vector3(0, 0, 0));\r\n        // TODO instead of doing this, just extract the x, y, and z columns of invWorld\r\n        let iDestiny = invWorld.multiplyVector(new vector_Vector3(1, 0, 0));\r\n        let jDestiny = invWorld.multiplyVector(new vector_Vector3(0, 1, 0));\r\n        let kDestiny = invWorld.multiplyVector(new vector_Vector3(0, 0, -1));\r\n        let ihat = iDestiny.sub(origin).normalize();\r\n        let jhat = jDestiny.sub(origin).normalize();\r\n        let khat = kDestiny.sub(origin).normalize();\r\n        // pardon this insanely ugly statement\r\n        let screenPoint = useMouse\r\n            ? origin\r\n                .added(khat.scaled(f))\r\n                .add(ihat.scaled(mouseUnitX))\r\n                .add(jhat.scaled(-mouseUnitY))\r\n            : origin.added(khat.scaled(f));\r\n        return Ray.fromPoints(origin, screenPoint);\r\n    }\r\n    getWorldMatrix() {\r\n        let offset = this.offset;\r\n        let angleA = this.angleAlpha;\r\n        let angleB = this.angleBeta;\r\n        // translate so z means \'up\'\r\n        let yzFlip = new matrix_Matrix4([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\r\n        // translated to fit screen\r\n        let position = matrix_Matrix4.newTranslation(this.pos.x, this.pos.y, this.pos.z);\r\n        let mOffset = matrix_Matrix4.newTranslation(offset.x, offset.y, offset.z);\r\n        // rotated by user\r\n        let x_rotation = matrix_Matrix4.newXRotation(angleA);\r\n        let z_rotation = matrix_Matrix4.newZRotation(angleB);\r\n        let rotation = z_rotation.multiply(x_rotation);\r\n        // let transform = mOffset.multiply(rotation).multiply(position);\r\n        let transform = position.multiply(rotation).multiply(mOffset);\r\n        return transform;\r\n    }\r\n    getProjectionMatrix(canvas) {\r\n        // aspects\r\n        let aspect = canvas.width / canvas.height; // note: this should be constant\r\n        // let z_plane = -1. / Math.tan(pi / 8.);\r\n        // projection to screen\r\n        // let projection = Matrix4.newOrthographic(-1, 1, -1, 1, 0.1, 0.1);\r\n        let projection = matrix_Matrix4.newPerspective(this.fov, aspect, this.zNear, this.zFar);\r\n        return projection;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/render/combo.ts\n// name:    combo.ts\r\n// author:  Jos Feenstra\r\n// purpose:\r\n// - combination of state, bufferedState, and renderer:\r\n//\r\n// 1.      state\r\n//           ||\r\n//        (buffer)\r\n//           \\/\r\n// 2.     buffered\r\n//           ||\r\n//        (render)\r\n//           \\/\r\n// 3. rendered to screen\r\n//\r\n// TODO: maybe find a better name, but \'combo\' is quite distinct in a way\r\n// todo: force buffering a bit more. make a way that requiers this.buffered to be filled\r\n// staticcombo\r\n// dynacombo\r\n// multistaic combo\r\n// Vector3 & dotrenderer\r\nclass combo_Combi {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.buffered = [];\r\n        this.state = [];\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        for (let i = 0; i < this.buffered.length; i++) {\r\n            const b = this.buffered[i];\r\n            this.renderer.setAndRender(b, context);\r\n        }\r\n    }\r\n}\r\nclass Combo {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.state = state;\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        this.renderer.render(context);\r\n    }\r\n}\r\n// Combi\r\n// // small tie-together of data & renderer.\r\n// // used to interact with the rendering behaviour of a renderableMesh.\r\n// // TODO: typecheck if data & renderer are compatible\r\n// import { Renderer, DrawSpeed } from "./renderer";\r\n// import { Scene } from "./scene";\r\n// // TODO add this information to the new Renderable\r\n// export class StaticRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): StaticRenderUnit<A, B> {\r\n//         return new StaticRenderUnit(renderer, data);\r\n//     }\r\n//     buffer() {\r\n//         this.renderer.buffer(this.data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n// export class DynamicRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): DynamicRenderUnit<A, B> {\r\n//         return new DynamicRenderUnit(renderer, data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.buffer();\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n\n;// CONCATENATED MODULE: ./src/render/light.ts\n// Name:    scene.ts\r\n// Author:  Jos Feenstra\r\n\r\nclass Light {\r\n    constructor(pos, color, spot, dir) {\r\n        this.pos = pos;\r\n        this.color = color;\r\n        this.spot = spot;\r\n        this.dir = dir;\r\n    }\r\n    static new(pos, color = [1, 1, 1, 1]) {\r\n        return new Light(pos, color, false, Vector3.zero());\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/render/context.ts\nclass Context {\r\n    constructor(camera) {\r\n        this.camera = camera;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/render/renderer.ts\n// webgl-helpers.ts\r\n//\r\n// author: Jos Feenstra\r\n// credits to : https://webglfundamentals.org/\r\n// note: im still figuring out how to organize this\r\n// import { Scene } from "./scene";\r\nvar nextTextureId = 0;\r\nvar rendercallsperframe = 0;\r\nvar renderer_DrawSpeed;\r\n(function (DrawSpeed) {\r\n    DrawSpeed[DrawSpeed["StaticDraw"] = 0] = "StaticDraw";\r\n    DrawSpeed[DrawSpeed["DynamicDraw"] = 1] = "DynamicDraw";\r\n})(renderer_DrawSpeed || (renderer_DrawSpeed = {}));\r\n// @param T = data to feed the renderer at \'set\'\r\nclass renderer_Renderer {\r\n    constructor(gl, vertexScript, fragmentScript) {\r\n        this.gl = gl;\r\n        this.program = renderer_Renderer.createProgramFromScripts(gl, vertexScript, fragmentScript);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, renderer_DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n    // helpers. these could live somewhere else... maybe in Context?\r\n    //#region\r\n    static getNextTextureID() {\r\n        let id = nextTextureId;\r\n        nextTextureId += 1;\r\n        return id;\r\n    }\r\n    static resizeCanvas(gl) {\r\n        // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n        let canvas = gl.canvas;\r\n        const displayWidth = canvas.clientWidth;\r\n        const displayHeight = canvas.clientHeight;\r\n        // Check if the canvas is not the same size.\r\n        const needResize = gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight;\r\n        if (needResize) {\r\n            // Make the canvas the same size\r\n            gl.canvas.width = displayWidth;\r\n            gl.canvas.height = displayHeight;\r\n        }\r\n        // Tell WebGL how to convert from clip space to pixels\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        return needResize;\r\n    }\r\n    convertDrawSpeed(speed) {\r\n        if (speed == renderer_DrawSpeed.DynamicDraw) {\r\n            return this.gl.DYNAMIC_DRAW;\r\n        }\r\n        else {\r\n            return this.gl.STATIC_DRAW;\r\n        }\r\n    }\r\n    static initWebglContext(canvas) {\r\n        let possiblyGl = canvas.getContext("webgl");\r\n        if (possiblyGl == undefined) {\r\n            console.log("webgl unavailable...");\r\n        }\r\n        let gl = possiblyGl;\r\n        gl.enable(gl.BLEND);\r\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        gl.clearDepth(1);\r\n        return gl;\r\n    }\r\n    static compileShader(gl, shaderSource, shaderType) {\r\n        let shader = gl.createShader(shaderType);\r\n        gl.shaderSource(shader, shaderSource);\r\n        gl.compileShader(shader);\r\n        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!success) {\r\n            throw "could not compile shader:" + shaderSource + gl.getShaderInfoLog(shader);\r\n        }\r\n        return shader;\r\n    }\r\n    static createProgram(gl, vertexShader, fragmentShader) {\r\n        let program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!success) {\r\n            throw "program failed to link:" + gl.getProgramInfoLog(program);\r\n        }\r\n        return program;\r\n    }\r\n    static createProgramFromScripts(gl, vertexScript, fragmentScript) {\r\n        let vertexShader = renderer_Renderer.compileShader(gl, vertexScript, gl.VERTEX_SHADER);\r\n        let fragmentShader = renderer_Renderer.compileShader(gl, fragmentScript, gl.FRAGMENT_SHADER);\r\n        return renderer_Renderer.createProgram(gl, vertexShader, fragmentShader);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/billboard-renderer.ts\n// name:    billboard-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: Renderer images as billboards.\r\n\r\n// this is just a template for copy-pasting\r\nclass TemplateRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl) {\r\n        let vs = "";\r\n        let fs = "";\r\n        super(gl, vs, fs);\r\n    }\r\n    static new(gl) {\r\n        return new TemplateRenderer(gl);\r\n    }\r\n    set(p, speed) {\r\n        // TODO\r\n    }\r\n    render(context) {\r\n        // TODO\r\n    }\r\n    setAndRender(pack, context) {\r\n        this.set(pack, DrawSpeed.StaticDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n// export class TextRenderer {\r\n//     // TODO\r\n//     // use the billboard renderer to render series of ascii characters,\r\n//     // by using standard positions of certain font images.\r\n//     br: BillBoardRenderer;\r\n//     // todo horizontal justification\r\n//     // todo vertical justification\r\n//     constructor(gl: WebGLRenderingContext) {\r\n//         this.br = new BillBoardRenderer(gl);\r\n//     }\r\n//     set(strings: string[], locations: Vector3Array) {\r\n//         if (strings.length != locations.count()) {\r\n//             console.warn("couldnt set TextRenderer: strings not equal to locations...");\r\n//         }\r\n//         let length = strings.length;\r\n//         // TODO: set a whole bunch of stuff\r\n//     }\r\n//     render() {}\r\n// }\r\n\n;// CONCATENATED MODULE: ./src/renderers/dot-renderer2.ts\n// jos feenstra\r\n\r\nclass DotRenderer2 extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl, size = 5, color = [1, 1, 1, 1], square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\n        attribute vec2 a_position;\n        \n        uniform vec2 u_resolution;\n        uniform float u_size;\n\n        void main() {\n            vec2 clipped = ((a_position / u_resolution) * 2.0) - 1.0;\n      \n            gl_PointSize = u_size;\n            gl_Position = vec4(clipped, 0, 1);\n            // gl_Position = vec4(0,0,0,1);\n        }\n        `;\r\n        let fragmentSourceSquare = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_Color;\n        vec2 center = vec2(0.5, 0.5);\n\n        void main() {\n            gl_FragColor = vec4(1,1,1,1);\n        }\n        `;\r\n        let fragmentSourceRound = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_Color;\n        vec2 center = vec2(0.5, 0.5);\n\n        void main() {\n            if (distance(center, gl_PointCoord) > 0.5) {\n               discard;\n            }\n            gl_FragColor = vec4(1,1,1,1);\n        }\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.u_resolution = gl.getUniformLocation(this.program, "u_resolution");\r\n        this.u_size = gl.getUniformLocation(this.program, "u_size");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        this.color = color;\r\n        this.size = size;\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set() { }\r\n    render(context) { }\r\n    // render 1 image to the screen\r\n    setAndRender(dots, context) {\r\n        let gl = this.gl;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniform2f(this.u_resolution, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform1f(this.u_size, this.size);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // // Bind the position buffer.\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        // // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don\'t normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0; // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(this.a_position, size, type, normalize, stride, offset);\r\n        // fill with data;\r\n        let data = this.toFloat32Array(dots);\r\n        gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\r\n        // Draw the point.\r\n        var primitiveType = gl.POINTS;\r\n        var offset = 0;\r\n        var count = dots.length;\r\n        gl.drawArrays(primitiveType, offset, count);\r\n    }\r\n    // Fill the buffer with the values that define a rectangle.\r\n    toFloat32Array(dots) {\r\n        let data = new Float32Array(dots.length * 2);\r\n        for (let i = 0; i < dots.length; i++) {\r\n            data[i * 2] = dots[i].x;\r\n            data[i * 2 + 1] = dots[i].y;\r\n        }\r\n        return data;\r\n    }\r\n    randomInt(range) {\r\n        return Math.floor(Math.random() * range);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/dot-renderer3.ts\n// jos feenstra\r\n\r\n\r\nclass dot_renderer3_DotRenderer3 extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl, radius = 5, color = [1, 1, 1, 1], square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform mat4 u_transform;\n        uniform vec4 u_color;\n        uniform float u_size;\n\n        attribute vec3 a_vertex;\n\n        void main() {\n            // Set the size of a rendered point.\n            gl_PointSize = u_size;\n\n            // Transform the location of the vertex.\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\n        }\n\n        `;\r\n        let fragmentSourceSquare = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n        // vec2 center = vec2(0.5, 0.5);\n\n        void main() {\n            gl_FragColor = u_color;\n        }\n        `;\r\n        let fragmentSourceRound = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n        vec2 center = vec2(0.5, 0.5);\n\n        void main() {\n            if (distance(center, gl_PointCoord) > 0.5) {\n               discard;\n            }\n            gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_size = gl.getUniformLocation(this.program, "u_size");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        this.color = color;\r\n        this.size = radius;\r\n        this.count = 0;\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, "a_vertex");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set(points, speed) {\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        // convert all possible entries to a general entry\r\n        let array = getGeneralFloatMatrix(points);\r\n        // from some other thing\r\n        this.count = array.count();\r\n        // // Bind the position buffer.\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, array._width, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, array.data, super.convertDrawSpeed(speed));\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        // console.log(matrix.data);\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniform1f(this.u_size, this.size);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        // Draw the point.\r\n        gl.drawArrays(gl.POINTS, 0, this.count);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/line-renderer.ts\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\n\r\nclass line_renderer_LineRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl, color = [1, 0, 0, 0.5]) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\n        precision mediump int;\n        precision mediump float;\n\n        attribute vec4 a_position;\n        uniform mat4 u_transform;\n        uniform vec4 u_color;\n\n        void main() {\n            gl_Position = u_transform * a_position;\n        }\n        `;\r\n        const fs = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n\n        void main () {\n            gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // set uniforms which wont change\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n    }\r\n    set(data, speed = DrawSpeed.StaticDraw, personal = Matrix4.newIdentity()) {\r\n        // save how many faces need to be drawn\r\n        let gl = this.gl;\r\n        let links;\r\n        let verts;\r\n        if (data instanceof Mesh) {\r\n            verts = data.verts;\r\n            links = data.links.getData();\r\n        }\r\n        else {\r\n            verts = data.verts;\r\n            links = data.links;\r\n        }\r\n        // console.log(links);\r\n        gl.useProgram(this.program);\r\n        this.count = links.length;\r\n        this.vertCount = verts._width;\r\n        let drawspeed = this.convertDrawSpeed(speed);\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, verts.data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, links.buffer, drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        //\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        //\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/simple-mesh-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\nclass simple_mesh_renderer_SimpleMeshRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl, color = [1, 0, 0, 0.25]) {\r\n        const vs = `\n        precision mediump int;\n        precision mediump float;\n\n        attribute vec4 a_position;\n        uniform mat4 u_transform;\n        uniform vec4 u_color;\n\n        void main() {\n            gl_Position = u_transform * a_position;\n        }\n        `;\r\n        const fs = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n\n        void main () {\n            gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(mesh, speed = DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.data, this.convertDrawSpeed(speed));\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, this.convertDrawSpeed(speed));\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/mesh-normals-renderer.ts\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\n\r\n\r\n\r\nclass mesh_normals_renderer_NormalRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\n        precision mediump int;\n        precision mediump float;\n\n        attribute vec4 a_vertex;\n        attribute vec4 a_vertex_color;\n\n        uniform mat4 u_transform;\n\n        varying vec4 v_color;\n\n        void main() {\n            gl_Position = u_transform * a_vertex;\n            v_color = a_vertex_color;\n        }\n        `;\r\n        const fs = `\n        precision mediump int;\n        precision mediump float;\n\n        varying vec4 v_color;\n\n        void main () {\n            gl_FragColor = v_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, "a_vertex");\r\n        this.a_color = gl.getAttribLocation(this.program, "a_vertex_color");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_color_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n        this.scale = 0.4;\r\n    }\r\n    // take a general render mesh, and extract normals\r\n    set(rend, speed = DrawSpeed.StaticDraw) {\r\n        // save how many verts need to be drawn\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        let drawspeed = this.convertDrawSpeed(speed);\r\n        this.vertCount = 3;\r\n        let lineverts;\r\n        let normals;\r\n        // different buffer fills based upon normal kind\r\n        let normalKind = rend.getNormalType();\r\n        if (normalKind == NormalKind.Face) {\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = faceCount * 2;\r\n            lineverts = new Vector3Array(this.count);\r\n            normals = new Vector3Array(this.count);\r\n            for (let f = 0; f < faceCount; f++) {\r\n                let center = rend.getFaceVertices(f).average();\r\n                let normal = rend.norms.getVector(f);\r\n                let i1 = f * 2;\r\n                let i2 = f * 2 + 1;\r\n                lineverts.setVector(i1, center);\r\n                lineverts.setVector(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new Vector3(1, 1, 1).div(2));\r\n                normals.setVector(i1, color);\r\n                normals.setVector(i2, color);\r\n            }\r\n        }\r\n        else if (normalKind == NormalKind.Vertex) {\r\n            let vertCount = rend.mesh.verts.count();\r\n            this.count = vertCount * 2;\r\n            lineverts = new Vector3Array(this.count);\r\n            normals = new Vector3Array(this.count);\r\n            for (let i = 0; i < vertCount; i++) {\r\n                let center = rend.mesh.verts.getVector(i);\r\n                let normal = rend.norms.getVector(i);\r\n                let i1 = i * 2;\r\n                let i2 = i * 2 + 1;\r\n                lineverts.setVector(i1, center);\r\n                lineverts.setVector(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new Vector3(1, 1, 1)).div(2);\r\n                normals.setVector(i1, color);\r\n                normals.setVector(i2, color);\r\n            }\r\n            // console.log(normals);\r\n        }\r\n        else {\r\n            console.warn("no normals for type", normalKind);\r\n            this.count = 0;\r\n            return;\r\n        }\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, lineverts.data, drawspeed);\r\n        // normals\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, normals.data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, getDefaultIndices(this.count), drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        let camera = c.camera;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // index buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/render/meta-renderer.ts\n\r\nclass meta_renderer_MetaRenderer {\r\n    setAndRender(r, context) {\r\n        this.set(r, DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/mesh-debug-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MeshDebugRenderer extends (/* unused pure expression or super */ null && (MetaRenderer)) {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new SimpleMeshRenderer(gl, faceColor);\r\n        this.lineRend = new LineRenderer(gl, edgeColor);\r\n        this.personal = Matrix4.newIdentity();\r\n        if (renderNormal)\r\n            this.normRend = new NormalRenderer(gl);\r\n    }\r\n    static new(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        return new MeshDebugRenderer(gl, faceColor, edgeColor, renderNormal);\r\n    }\r\n    set(data, speed = DrawSpeed.StaticDraw) {\r\n        var _a;\r\n        this.personal = data.position;\r\n        this.faceRend.set(data.mesh);\r\n        this.lineRend.set(LineArray.fromMesh(data), speed);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.set(data, speed);\r\n    }\r\n    render(c) {\r\n        var _a;\r\n        this.faceRend.render(c);\r\n        this.lineRend.render(c);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.render(c);\r\n    }\r\n    setAndRender(r, c) {\r\n        this.set(r, DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/rectangle-renderer.ts\n// jos feenstra\r\n\r\nclass RectangleRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\n        attribute vec2 a_position;\n\n        uniform vec2 u_resolution;\n\n        void main() {\n            // convert the rectangle from pixels to 0.0 to 1.0\n            vec2 zeroToOne = ((a_position / u_resolution) * 2.0) - 1.0;\n\n            // convert from 0->1 to 0->2\n            // vec2 zeroToTwo = zeroToOne * 2.0;\n\n            // convert from 0->2 to -1->+1 (clipspace)\n            // vec2 clipSpace = zeroToTwo - 1.0;\n\n            gl_Position = vec4(zeroToOne * vec2(1, -1), 0, 1);\n        }\n        `;\r\n        let fragmentSource = `\n        precision mediump float;\n\n        uniform vec4 u_color;\n        \n        void main() {\n           gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vertexSource, fragmentSource);\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.u_resolution = gl.getUniformLocation(this.program, "u_resolution");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        // Create a buffer to put three 2d clip space points in\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set() {\r\n        throw "not used";\r\n    }\r\n    render() {\r\n        throw "not used!";\r\n    }\r\n    setAndRender(rs, c) {\r\n        // Clear the canvas\r\n        let gl = this.gl;\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // Turn on the attribute\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.uniform2f(this.u_resolution, gl.canvas.width, gl.canvas.height);\r\n        // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don\'t normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0; // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(this.a_position, size, type, normalize, stride, offset);\r\n        // draw 50 random rectangles in random colors\r\n        for (let r of rs) {\r\n            // Setup a random rectangle\r\n            // This will write to positionBuffer because\r\n            // its the last thing we bound on the ARRAY_BUFFER\r\n            // bind point\r\n            this.setRectangle(gl, r);\r\n            // Set a random color.\r\n            gl.uniform4f(this.u_color, Math.random(), Math.random(), Math.random(), 1);\r\n            // Draw the rectangle.\r\n            var primitiveType = gl.TRIANGLES;\r\n            var offset = 0;\r\n            var count = 6;\r\n            gl.drawArrays(primitiveType, offset, count);\r\n        }\r\n    }\r\n    // Fill the buffer with the values that define a rectangle.\r\n    setRectangle(gl, r) {\r\n        let verts = r.getVertices();\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n            verts[0].x,\r\n            verts[0].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[3].x,\r\n            verts[3].y,\r\n        ]), gl.STATIC_DRAW);\r\n    }\r\n    randomInt(range) {\r\n        return Math.floor(Math.random() * range);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/shaded-mesh-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: A shader wrapper for rendering shaded, textured, meshes\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ShadedMeshRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl) {\r\n        const vs = `\n\n        attribute vec4 a_vertex_position;\n        attribute vec3 a_vertex_normal;\n        attribute float a_vertex_ambi;\n    \n        uniform mat4 u_normal_matrix;\n        uniform mat4 u_personal_matrix;\n        uniform mat4 u_model_view_matrix;\n        uniform mat4 u_projection_matrix;\n\n        // should be uniforms constances\n        uniform vec3 u_ambient_light;\n        uniform vec3 u_dir_light_color;\n        uniform vec3 u_dir_light_vector;  \n\n        // varying vec2 v_texture_coord;\n        varying vec3 v_lighting;\n    \n        void main(void) {\n\n            gl_Position = u_projection_matrix * u_model_view_matrix * u_personal_matrix * a_vertex_position;\n            // v_texture_coord = a_texture_coord;\n        \n            // Apply lighting effect\n            // highpr is removed\n            vec4 transformedNormal = u_normal_matrix * vec4(a_vertex_normal, 1.0);\n            float directional = max(dot(transformedNormal.xyz, u_dir_light_vector), 0.0);\n            v_lighting = (u_ambient_light + (u_dir_light_color * directional));\n        }\n        `;\r\n        const fs = `\n        precision mediump float;\n\n        // Calculates the diffuse factor produced by the light illumination  \n        // if done like this, color could look nicer\n        // float diffuseFactor(vec3 normal, vec3 light_direction) {\n        //     float df = dot(normalize(normal), normalize(light_direction));\n        //     if (gl_FrontFacing) {\n        //         df = -df;\n        //     }\n        //     return max(0.0, df);\n        // }\n\n        varying vec3 v_lighting;\n\n        void main() {\n\n            // Fragment shader output\n            gl_FragColor = vec4(v_lighting, 1.0);\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_normal_matrix = gl.getUniformLocation(this.program, "u_normal_matrix");\r\n        this.u_model_view_matrix = gl.getUniformLocation(this.program, "u_model_view_matrix");\r\n        this.u_projection_matrix = gl.getUniformLocation(this.program, "u_projection_matrix");\r\n        this.u_personal_matrix = gl.getUniformLocation(this.program, "u_personal_matrix");\r\n        // light uniforms\r\n        this.u_ambient_light = gl.getUniformLocation(this.program, "u_ambient_light");\r\n        this.u_dir_light_color = gl.getUniformLocation(this.program, "u_dir_light_color");\r\n        this.u_dir_light_vector = gl.getUniformLocation(this.program, "u_dir_light_vector");\r\n        // init attributes: verts | normals | ambi\r\n        this.a_vertex_position = gl.getAttribLocation(this.program, "a_vertex_position");\r\n        this.a_vertex_postition_buffer = gl.createBuffer();\r\n        this.a_vertex_normal = gl.getAttribLocation(this.program, "a_vertex_normal");\r\n        this.a_vertex_normal_buffer = gl.createBuffer();\r\n        this.a_vertex_ambi = gl.getAttribLocation(this.program, "a_vertex_ambi");\r\n        this.a_vertex_ambi_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(rend, speed = DrawSpeed.StaticDraw) {\r\n        // NOTE: processing time is longer: we use DrawArray instead of DrawElements, to deal with normals & uv data\r\n        let gl = this.gl;\r\n        this.setShallow(gl, rend);\r\n        let normalType = rend.getNormalType();\r\n        if (normalType == NormalKind.Face) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            this.count = rend.mesh.links.data.length;\r\n            let ds = this.convertDrawSpeed(speed);\r\n            // convert to non-indexed verts & norms\r\n            let verts = new Vector3Array(this.count);\r\n            let norms = new Vector3Array(this.count);\r\n            let ambi = new Float32Array(this.count);\r\n            let faceCount = rend.mesh.links.count();\r\n            for (let i = 0; i < rend.mesh.links.count(); i++) {\r\n                let norm = rend.norms.getVector(i);\r\n                rend.mesh.links.getRow(i).forEach((v, j) => {\r\n                    let id = i * 3 + j;\r\n                    verts.setVector(id, rend.mesh.verts.getVector(v));\r\n                    norms.setVector(id, norm);\r\n                    ambi[id] = 1;\r\n                });\r\n            }\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, verts.data.buffer, ds);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, norms.data.buffer, ds);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, getDefaultIndices(this.count), this.convertDrawSpeed(speed));\r\n        }\r\n        else if (normalType == NormalKind.Vertex) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            let ds = this.convertDrawSpeed(speed);\r\n            // convert to non-indexed verts & norms\r\n            let ambi = rend.ambi;\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = rend.mesh.links.data.length;\r\n            // console.log(rend.mesh.links);\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.mesh.verts.data, ds);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.norms.data, ds);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, rend.mesh.links.data, ds);\r\n        }\r\n        else {\r\n            console.log("cannot render with this normal data");\r\n        }\r\n        // never render more than possible\r\n        if (this.count > Const.MAX_U16) {\r\n            this.count = Const.MAX_U16;\r\n            console.warn("mesh max reached.");\r\n        }\r\n    }\r\n    // set only the basic elements.\r\n    // use this to dynamicly alter things like position and color,\r\n    // without refilling all buffers with it\r\n    setShallow(gl, rend) {\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // position\r\n        gl.uniformMatrix4fv(this.u_personal_matrix, false, rend.position.data);\r\n        // color\r\n        let color = rend.color;\r\n        // shift shadow to darker, slightly to blue\r\n        let shadowColor = color.map((x) => x * 0.25);\r\n        shadowColor[2] = Math.min(1, shadowColor[2] * 1.05);\r\n        // shift bright color slightly to yellow\r\n        let brightColor = color.map((x) => x);\r\n        brightColor[0] = Math.min(1, brightColor[0] * 1.05);\r\n        brightColor[1] = Math.min(1, brightColor[1] * 1.05);\r\n        brightColor[2] = Math.min(1, brightColor[2] * 1);\r\n        gl.uniform3fv(this.u_ambient_light, shadowColor.slice(0, 3));\r\n        gl.uniform3fv(this.u_dir_light_color, brightColor.slice(0, 3));\r\n    }\r\n    // render the previous set data to the screen\r\n    render(c) {\r\n        // console.log("rendering..");\r\n        let gl = this.gl;\r\n        let camera = c.camera;\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_normal_matrix, false, Matrix4.newIdentity().data);\r\n        gl.uniformMatrix4fv(this.u_model_view_matrix, false, camera.worldMatrix.data);\r\n        gl.uniformMatrix4fv(this.u_projection_matrix, false, camera.projectMatrix.data);\r\n        // set light direction\r\n        let vec = camera.getMouseWorldRay(gl.canvas.width, gl.canvas.height, false).normal;\r\n        gl.uniform3fv(this.u_dir_light_vector, Vector3.unitX().add(Vector3.unitY()).add(Vector3.unitZ()).normalize().toArray());\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_vertex_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_vertex_normal);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        // gl.enableVertexAttribArray(this.a_vertex_ambi);\r\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n        // gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/texture-mesh-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\nclass texture_mesh_renderer_TextureMeshRenderer extends (/* unused pure expression or super */ null && (Renderer)) {\r\n    constructor(gl) {\r\n        const vs = `\n        // precision mediump int;\n        // precision mediump float;\n\n        attribute vec4 a_position;\n        attribute vec2 a_texcoord;\n\n        uniform mat4 u_transform;\n\n        varying vec2 v_texcoord;\n\n        void main() {\n            gl_Position = u_transform * a_position;\n            v_texcoord = a_texcoord;\n        }\n        `;\r\n        const fs = `\n        precision mediump float;\n\n        varying vec2 v_texcoord;\n\n        uniform sampler2D u_texture;\n\n        void main() {\n            gl_FragColor = texture2D(u_texture, v_texcoord);\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_texture = gl.getUniformLocation(this.program, "u_texture");\r\n        // init three buffers: verts | uvs | links\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_texcoord = gl.getAttribLocation(this.program, "a_texcoord");\r\n        this.a_texcoord_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // init texture\r\n        this.texture_id = Renderer.getNextTextureID();\r\n        this.texture = gl.createTexture();\r\n    }\r\n    static new(gl) {\r\n        return new texture_mesh_renderer_TextureMeshRenderer(gl);\r\n    }\r\n    set(r, speed) {\r\n        let gl = this.gl;\r\n        if (!r.texture) {\r\n            console.warn("Mesh does not contain a texture!");\r\n            return;\r\n        }\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = r.mesh.links.data.length;\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.mesh.verts.data, this.convertDrawSpeed(speed));\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.uvs.data, this.convertDrawSpeed(speed));\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(r.mesh.links.data), this.convertDrawSpeed(speed));\r\n        // texture\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r.texture);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    render(context) {\r\n        let gl = this.gl;\r\n        let camera = context.camera;\r\n        let matrix = camera.totalMatrix;\r\n        // console.log("rendering..");\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // set texture\r\n        gl.uniform1i(this.u_texture, this.texture_id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_texcoord);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/graph-debug-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GraphDebugRenderer extends (/* unused pure expression or super */ null && (MetaRenderer)) {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new SimpleMeshRenderer(gl, faceColor);\r\n        this.lineRend = new LineRenderer(gl, edgeColor);\r\n        this.pointRend = new DotRenderer3(gl, 7, edgeColor, false);\r\n        if (renderNormal)\r\n            this.normRend = new NormalRenderer(gl);\r\n    }\r\n    set(graph, speed = DrawSpeed.StaticDraw) {\r\n        //this.faceRend.setMesh(gl, mesh);\r\n        this.pointRend.set(graph.allVertPositions(), speed);\r\n        this.lineRend.set(graph.toLines(), speed);\r\n        // this.normRend?.setWithLists(graph.allVertPositions(), graph.allNorms(), speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        this.pointRend.render(c);\r\n        // this.faceRend.render(gl, camera.totalMatrix);\r\n        this.lineRend.render(c);\r\n        // this.normRend?.render(gl, camera);\r\n    }\r\n    setAndRender(r, context) {\r\n        throw new Error("Method not implemented.");\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/system/domwrappers.ts\n// domwrappers.ts\r\n// author : Jos Feenstra\r\n// purpuse : wrap certain DOM functionalities\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nfunction addDropFileEventListeners(canvas, filesCallback) {\r\n    console.log("setting up drag events...");\r\n    canvas.addEventListener("dragenter", function (ev) {\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log("entering entering...");\r\n        return true;\r\n    }, true);\r\n    // setup file upload\r\n    canvas.addEventListener("dragover", function (ev) {\r\n        //add hover class when drag over\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log("over drag....");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener("dragleave", function (ev) {\r\n        //remove hover class when drag out\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log("leaving drag....");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener("drop", function (ev) {\r\n        //prevent browser from open the file when drop off\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n        //retrieve uploaded files data\r\n        var files = ev.dataTransfer.files;\r\n        filesCallback(files);\r\n        return true;\r\n    }, true);\r\n}\r\nfunction loadImageTest(files) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let image = yield loadImageFromFile(files.item(0));\r\n    });\r\n}\r\nfunction loadTextFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadJSONFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(JSON.parse(reader.result));\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadImageFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(file);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageFromBlob(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(blob);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageHelper1(fileReader) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement("img");\r\n        img.src = fileReader.result;\r\n        img.onload = () => resolve(loadImageHelper2(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper2(image) {\r\n    var _a;\r\n    // turn it into image data by building a complete canvas and sampling it\r\n    let canvas = document.createElement("canvas");\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let ctx = canvas.getContext("2d");\r\n    ctx.drawImage(image, 0, 0);\r\n    let data = ctx.getImageData(0, 0, image.width, image.height);\r\n    (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);\r\n    return data;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/system/input-state.ts\n// CanvasInputHandler.ts\r\n// author : Jos Feenstra\r\n// purpose : handle all input events.\r\n\r\nvar Key;\r\n(function (Key) {\r\n    Key[Key["A"] = 0] = "A";\r\n    Key[Key["B"] = 1] = "B";\r\n    Key[Key["C"] = 2] = "C";\r\n    Key[Key["D"] = 3] = "D";\r\n    Key[Key["E"] = 4] = "E";\r\n    Key[Key["F"] = 5] = "F";\r\n    Key[Key["G"] = 6] = "G";\r\n    Key[Key["H"] = 7] = "H";\r\n    Key[Key["I"] = 8] = "I";\r\n    Key[Key["J"] = 9] = "J";\r\n    Key[Key["K"] = 10] = "K";\r\n    Key[Key["L"] = 11] = "L";\r\n    Key[Key["M"] = 12] = "M";\r\n    Key[Key["N"] = 13] = "N";\r\n    Key[Key["O"] = 14] = "O";\r\n    Key[Key["P"] = 15] = "P";\r\n    Key[Key["Q"] = 16] = "Q";\r\n    Key[Key["R"] = 17] = "R";\r\n    Key[Key["S"] = 18] = "S";\r\n    Key[Key["T"] = 19] = "T";\r\n    Key[Key["U"] = 20] = "U";\r\n    Key[Key["V"] = 21] = "V";\r\n    Key[Key["W"] = 22] = "W";\r\n    Key[Key["X"] = 23] = "X";\r\n    Key[Key["Y"] = 24] = "Y";\r\n    Key[Key["Z"] = 25] = "Z";\r\n    Key[Key["Up"] = 26] = "Up";\r\n    Key[Key["Down"] = 27] = "Down";\r\n    Key[Key["Left"] = 28] = "Left";\r\n    Key[Key["Right"] = 29] = "Right";\r\n    Key[Key["Space"] = 30] = "Space";\r\n    Key[Key["Control"] = 31] = "Control";\r\n    Key[Key["Alt"] = 32] = "Alt";\r\n    Key[Key["Shift"] = 33] = "Shift";\r\n    Key[Key["Enter"] = 34] = "Enter";\r\n    Key[Key["Esc"] = 35] = "Esc";\r\n    Key[Key["N1"] = 36] = "N1";\r\n    Key[Key["N2"] = 37] = "N2";\r\n    Key[Key["N3"] = 38] = "N3";\r\n    Key[Key["N4"] = 39] = "N4";\r\n    Key[Key["N5"] = 40] = "N5";\r\n    Key[Key["N6"] = 41] = "N6";\r\n    Key[Key["N7"] = 42] = "N7";\r\n    Key[Key["N8"] = 43] = "N8";\r\n    Key[Key["N9"] = 44] = "N9";\r\n    Key[Key["N0"] = 45] = "N0";\r\n    Key[Key["Plus"] = 46] = "Plus";\r\n    Key[Key["Minus"] = 47] = "Minus";\r\n    Key[Key["Backspace"] = 48] = "Backspace";\r\n})(Key || (Key = {}));\r\nfunction toMapping(key) {\r\n    switch (key) {\r\n        case Key.A:\r\n            return 1;\r\n        case Key.B:\r\n            return 2;\r\n        case Key.C:\r\n            return 3;\r\n        case Key.D:\r\n            return 4;\r\n        case Key.E:\r\n            return 5;\r\n        case Key.F:\r\n            return 6;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\nclass InputState {\r\n    constructor(canvas) {\r\n        this.mousePos = vector_Vector2.zero();\r\n        this.mouseDelta = vector_Vector2.zero();\r\n        this.mouseLeftDown = false;\r\n        this.mouseLeftPressed = false;\r\n        this.mouseLeftPrev = false;\r\n        this.mouseRightDown = false;\r\n        this.mouseRightPressed = false;\r\n        this.mouseRightPrev = false;\r\n        this.mouseMiddleDown = false;\r\n        this.mouseMiddlePressed = false;\r\n        this.mouseMiddlePrev = false;\r\n        this.keysDown = {};\r\n        this.keysPressed = [];\r\n        this.scrollValue = 0;\r\n        // link\r\n        this.canvas = canvas;\r\n        // time\r\n        this.tick = 0;\r\n        this.oldTime = Date.now();\r\n        this.newTime = this.oldTime;\r\n        this.startTime = Date.now();\r\n        this.minimumTick = 1000 / 144;\r\n        // mouse\r\n        canvas.addEventListener("mousemove", this.setMousePos.bind(this));\r\n        canvas.addEventListener("mousedown", this.setMouseDown.bind(this));\r\n        canvas.addEventListener("mouseup", this.setMouseUp.bind(this));\r\n        canvas.addEventListener("contextmenu", (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        canvas.addEventListener("mousemove", this.setMousePos.bind(this));\r\n        canvas.addEventListener("wheel", this.setMouseScroll.bind(this));\r\n        canvas.addEventListener("touchmove", this.setTouch.bind(this));\r\n        canvas.addEventListener("touchstart", this.setTouch.bind(this));\r\n        canvas.addEventListener("touchend", this.setTouchUp.bind(this));\r\n        for (let i = 0; i < 223; i++)\r\n            this.keysDown[i] = false;\r\n        // keyboard\r\n        canvas.addEventListener("keydown", this.onKeyDown.bind(this));\r\n        // canvas.addEventListener("keypressed", this.onKeyPressed.bind(this));\r\n        canvas.addEventListener("keyup", this.onKeyUp.bind(this));\r\n        // final\r\n        canvas.focus();\r\n    }\r\n    preUpdate() {\r\n        // this must be called every tick within whatever context this is used\r\n        // update time\r\n        this.newTime = Date.now();\r\n        this.tick = this.newTime - this.oldTime;\r\n        this.oldTime = this.newTime;\r\n        // update mouse\r\n        this.mouseLeftPressed = this.mouseLeftPrev != this.mouseLeftDown && this.mouseLeftDown;\r\n        this.mouseRightPressed = this.mouseRightPrev != this.mouseRightDown && this.mouseRightDown;\r\n        this.mouseMiddlePressed =\r\n            this.mouseMiddlePrev != this.mouseMiddleDown && this.mouseMiddleDown;\r\n        this.mouseLeftPrev = this.mouseLeftDown;\r\n        this.mouseRightPrev = this.mouseRightDown;\r\n        this.mouseMiddlePrev = this.mouseMiddleDown;\r\n    }\r\n    postUpdate() {\r\n        // this also must be called for keyIsPressed to work\r\n        // refresh keypresses\r\n        this.keysPressed = [];\r\n    }\r\n    IsKeyDown(key) {\r\n        return this.keysDown[key];\r\n    }\r\n    IsKeyPressed(key) {\r\n        return this.keysPressed.includes(key);\r\n    }\r\n    onKeyDown(e) {\r\n        if (this.keysDown[e.key] == true)\r\n            return;\r\n        console.log(e.key);\r\n        this.keysDown[e.key.toLowerCase()] = true;\r\n        this.keysPressed.push(e.key);\r\n    }\r\n    onKeyUp(e) {\r\n        this.keysDown[e.key.toLowerCase()] = false;\r\n    }\r\n    onKeyPressed(e) {\r\n        // NOTE: i made a different system to handle this, see onKeyDown\r\n    }\r\n    setTouch(e) {\r\n        e.preventDefault();\r\n        this.mousePos = new vector_Vector2(e.touches[0].clientX, e.touches[0].clientY);\r\n        this.mouseLeftDown = true;\r\n    }\r\n    setTouchUp(e) {\r\n        e.preventDefault();\r\n        this.mouseLeftDown = false;\r\n    }\r\n    setMouseScroll(e) {\r\n        // console.log("we be scrollin\' now...")\r\n        // normalize all scrolling behaviour\r\n        let value = 0.1;\r\n        if (e.deltaY < 0)\r\n            value = -0.1;\r\n        // we dont want negative scroll values...\r\n        this.scrollValue = Math.max(0, this.scrollValue + value);\r\n    }\r\n    setMousePos(e) {\r\n        // this is a bit messy, BUT, multiply by camera parameters\r\n        this.mousePos = new vector_Vector2(e.clientX, e.clientY);\r\n    }\r\n    setMouseUp(e) {\r\n        let code = e.buttons;\r\n        if (code < 4) {\r\n            this.mouseMiddleDown = false;\r\n        }\r\n        if (code < 2) {\r\n            this.mouseRightDown = false;\r\n        }\r\n        if (code < 1) {\r\n            this.mouseLeftDown = false;\r\n        }\r\n    }\r\n    setMouseDown(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        this.canvas.focus();\r\n        let code = e.buttons;\r\n        if (code >= 4) {\r\n            code -= 4;\r\n            this.mouseMiddleDown = true;\r\n        }\r\n        if (code >= 2) {\r\n            code -= 2;\r\n            this.mouseRightDown = true;\r\n        }\r\n        if (code >= 1) {\r\n            code -= 1;\r\n            this.mouseLeftDown = true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/system/fpsCounter.ts\nclass FpsCounter {\r\n    constructor() {\r\n        this.fps = 0;\r\n        this.updateEveryXTicks = 100;\r\n        this.elapsed = 0;\r\n        this.frames = 0;\r\n    }\r\n    update(state) {\r\n        this.frames += 1;\r\n        this.elapsed += state.tick;\r\n        if (this.elapsed > this.updateEveryXTicks) {\r\n            this.setFps();\r\n            this.elapsed = 0;\r\n            this.frames = 0;\r\n        }\r\n    }\r\n    setFps() {\r\n        this.fps = Math.round((this.frames / this.elapsed) * 1000);\r\n    }\r\n    getFps() {\r\n        return this.fps;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/system/core.ts\n// Author: Jos Feenstra\r\n// Purpose: The Core app. This can hold multiple other apps with their own Update and Draw calls.\r\n// Use this to switch between Apps, or run multiple Apps.\r\n\r\n\r\n\r\nclass Core {\r\n    constructor(canvas, gl, uiFrame) {\r\n        this.STOP = false;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n        this.state = new InputState(canvas);\r\n        this.fpsCounter = new FpsCounter();\r\n        this.ui = new UI(uiFrame);\r\n        this.apps = new Map();\r\n    }\r\n    // todo: cycle through apps\r\n    addApp(app) {\r\n        this.apps.set(app.name, app);\r\n        this.activateApp(app);\r\n    }\r\n    removeApp(appName) {\r\n        this.ui.removeContext(appName);\r\n        this.apps.delete(appName);\r\n    }\r\n    activateApp(app) {\r\n        this.ui.addContext(app.name);\r\n        this.ui.addText(app.description);\r\n        app.ui(this.ui);\r\n        app.start();\r\n    }\r\n    update() {\r\n        this.state.preUpdate();\r\n        this.fpsCounter.update(this.state);\r\n        if (this.state.IsKeyPressed("Esc"))\r\n            this.STOP = true;\r\n        this.apps.forEach((app) => {\r\n            app.update(this.state);\r\n        });\r\n        this.state.postUpdate();\r\n    }\r\n    draw() {\r\n        const canvas = this.canvas;\r\n        const gl = this.gl;\r\n        // put fps in the title\r\n        // document.title = "fps: " + this.fpsCounter.getFps();\r\n        // pre-gl business\r\n        if (window.innerHeight != canvas.height || window.innerWidth != canvas.width) {\r\n            canvas.height = window.innerHeight;\r\n            // canvas.clientHeight = window.innerHeight;\r\n            canvas.style.height = window.innerHeight.toString();\r\n            canvas.width = window.innerWidth;\r\n            // canvas.clientWidth = window.innerWidth;\r\n            canvas.style.width = window.innerWidth.toString();\r\n            gl.viewport(0, 0, window.innerWidth, window.innerHeight);\r\n        }\r\n        // Renderer.resizeCanvas(this.gl);\r\n        this.gl.clearColor(0, 0, 0, 0);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\r\n        // render all apps\r\n        // TODO : reverse order\r\n        this.apps.forEach((app) => {\r\n            app.draw(this.gl);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/rendercombos/image-combi.ts\n\r\n\r\nclass ImageCombi extends (/* unused pure expression or super */ null && (Combi)) {\r\n    constructor(gl) {\r\n        super(gl, [], TextureMeshRenderer.new);\r\n    }\r\n    static new(gl) {\r\n        return new ImageCombi(gl);\r\n    }\r\n    buffer() {\r\n        // i was having trouble rendering images... this is a workaround:\r\n        // convert the this.images[] list into the this.imageMeshes list. then render that with the normal renderer\r\n        this.buffered = [];\r\n        let size = 256;\r\n        let accHeight = 0;\r\n        this.state.forEach((s, i) => {\r\n            let height = s.height;\r\n            let width = s.width;\r\n            let rec = new Rectangle3(Plane.fromPVV(new Vector3(0, 0, 0), new Vector3(0, 0, 1), new Vector3(-1, 0, 0)), Domain2.fromBounds(10, 10 + width, accHeight, accHeight + height));\r\n            let mesh = Mesh.fromRect(rec);\r\n            mesh.setTexture(s.resize(size, size).toImageData()); // note: webgl can only work with 2^x * 512 images\r\n            this.buffered.push(mesh);\r\n            accHeight += height + 10;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/lib.ts\n// purpose: make sure the entire library is callable from one point.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./demo/apps/spherical/spherical.ts\n\r\nfunction createGraph(liftType, subcount, quadsubcount, randomEdges) {\r\n    // 0 | setup\r\n    const mesh = mesh_Mesh.newIcosahedron(0.5);\r\n    let graph = mesh.toGraph();\r\n    let center = new vector_Vector3(0, 0, 0);\r\n    let radius = 1;\r\n    // 1 | subdivide\r\n    for (let i = 0; i < subcount; i++) {\r\n        graph.subdivide();\r\n        // lift to sphere after every subdivision\r\n        if (liftType > 0) {\r\n            let count = graph.getVertexCount();\r\n            for (let i = 0; i < count; i++) {\r\n                let pos = graph.getVertexPos(i);\r\n                let normal = pos;\r\n                let dis = center.disTo(pos);\r\n                let lift = radius - dis;\r\n                if (liftType > 1) {\r\n                    pos.add(normal.scaled(lift));\r\n                }\r\n                else {\r\n                    pos.add(normal.normalized().scaled(lift));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 2 | remove random edges\r\n    if (randomEdges == 1) {\r\n        quadification(graph);\r\n    }\r\n    // 3 | subdivide quad\r\n    for (let i = 0; i < quadsubcount; i++) {\r\n        graph.subdivideQuad();\r\n    }\r\n    // lift to sphere after every subdivision\r\n    if (liftType > 0) {\r\n        let count = graph.getVertexCount();\r\n        for (let i = 0; i < count; i++) {\r\n            let pos = graph.getVertexPos(i);\r\n            let normal = graph.getVertexNormal(i);\r\n            let dis = center.disTo(pos);\r\n            let lift = radius - dis;\r\n            if (liftType > 1) {\r\n                pos.add(normal.scaled(lift));\r\n            }\r\n            else {\r\n                pos.add(normal.normalized().scaled(lift));\r\n            }\r\n        }\r\n    }\r\n    // quad relaxation from beginning?\r\n    return graph;\r\n}\r\nfunction createTileWorld(count, height) {\r\n    let m = new IntMatrix(count, height);\r\n    for (let i = 0; i < m._height; i++) {\r\n        let val = randomInt(m._width + 1);\r\n        for (let j = 0; j < m._width; j++) {\r\n            if (j < val) {\r\n                m.set(i, j, 1);\r\n            }\r\n            else {\r\n                m.set(i, j, 0);\r\n            }\r\n        }\r\n    }\r\n    return m;\r\n}\r\nfunction meshifyGraphSurface(graph) {\r\n    // init result\r\n    let meshes = [];\r\n    // per quad\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let i = 0; i < loops.length; i++) {\r\n        const loop = loops[i];\r\n        if (loop.length < 4) {\r\n            console.log("invalids");\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let m = Mesh.newQuad([vecs[0], vecs[3], vecs[1], vecs[2]]);\r\n        meshes.push(m);\r\n    }\r\n    let rend = Mesh.fromJoin(meshes).toRenderable();\r\n    rend.calculateVertexNormals();\r\n    return rend;\r\n}\r\nfunction meshifyTileWorld(graph, tiles, radius, // base\r\nstoreyHeight) {\r\n    // init result\r\n    let meshes = [];\r\n    // per quad\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let i = 0; i < loops.length; i++) {\r\n        const loop = loops[i];\r\n        if (loop.length < 4) {\r\n            console.log("invalids");\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let row = tiles.getRow(i);\r\n        // fill row\r\n        for (let j = 0; j < tiles._width; j++) {\r\n            let tileType = row[j];\r\n            if (tileType == 0) {\r\n                continue;\r\n            }\r\n            let level = radius + j * storeyHeight;\r\n            let level2 = radius + (j + 1) * storeyHeight;\r\n            let m = Mesh.newOct([\r\n                vecs[0].scaled(level),\r\n                vecs[1].scaled(level),\r\n                vecs[3].scaled(level),\r\n                vecs[2].scaled(level),\r\n                vecs[0].scaled(level2),\r\n                vecs[1].scaled(level2),\r\n                vecs[3].scaled(level2),\r\n                vecs[2].scaled(level2),\r\n            ]);\r\n            meshes.push(m);\r\n        }\r\n    }\r\n    let rend = Mesh.fromJoin(meshes).toRenderable();\r\n    rend.calculateVertexNormals();\r\n    return rend;\r\n}\r\nfunction constructMeshFromSphereGraph(graph, radius, // to project back\r\nliftBot, //\r\nliftTop, //\r\nrand) {\r\n    // recalculate world mesh\r\n    let scaler1 = 1 + liftBot / radius;\r\n    let scaler2 = 1 + liftTop / radius;\r\n    let meshes = [];\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let loop of loops) {\r\n        if (Math.random() > rand) {\r\n            continue;\r\n        }\r\n        if (loop.length < 4) {\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let m = mesh_Mesh.newOct([\r\n            vecs[0].scaled(scaler1),\r\n            vecs[1].scaled(scaler1),\r\n            vecs[3].scaled(scaler1),\r\n            vecs[2].scaled(scaler1),\r\n            vecs[0].scaled(scaler2),\r\n            vecs[1].scaled(scaler2),\r\n            vecs[3].scaled(scaler2),\r\n            vecs[2].scaled(scaler2),\r\n        ]);\r\n        meshes.push(m);\r\n    }\r\n    let rend = mesh_Mesh.fromJoin(meshes);\r\n    return rend;\r\n}\r\nfunction averageEdgeLength(graph) {\r\n    let count = 0;\r\n    let sum = 0;\r\n    graph.forEveryEdgeVerts((a, b) => {\r\n        sum += a.disTo(b);\r\n        count += 1;\r\n    });\r\n    let average = sum / count;\r\n    return average;\r\n}\r\nfunction edgeSmooth(graph, average, scale) {\r\n    graph.forEveryEdgeVerts((a, b) => {\r\n        let distance = a.disTo(b);\r\n        let diff = average - distance;\r\n        let vector = b.subbed(a);\r\n        a.add(vector.scaled(-diff * scale));\r\n        b.add(vector.scaled(diff * scale));\r\n    });\r\n}\r\nfunction laPlacian(graph) {\r\n    let count = graph.getVertexCount();\r\n    let news = [];\r\n    // get center of nbs\r\n    for (let vi = 0; vi < count; vi++) {\r\n        let v = graph.getVert(vi);\r\n        if (v.dead)\r\n            continue;\r\n        let sum = Vector3.zero();\r\n        let nbs = graph.getVertNeighbors(vi);\r\n        for (let nb of nbs) {\r\n            sum.add(graph.getVertexPos(nb));\r\n        }\r\n        sum.scale(1 / nbs.length);\r\n        news.push(sum);\r\n    }\r\n    // set\r\n    for (let vi = 0; vi < count; vi++) {\r\n        graph.getVertexPos(vi).copy(news[vi]);\r\n    }\r\n}\r\nfunction squarification(graph, centerCornerAverage) {\r\n    // make the quad graph as \'square\' as possible\r\n    // prepare\r\n    let faces = graph.allVertLoopsAsInts();\r\n    let count = faces.length;\r\n    let centers = new Array(count);\r\n    let movers = new Array(graph.verts.length);\r\n    let counters = new Array(graph.verts.length);\r\n    for (let i = 0; i < movers.length; i++) {\r\n        movers[i] = Vector3.new(0, 0, 0);\r\n        counters[i] = 0;\r\n    }\r\n    let cca = 0;\r\n    // iterate per face\r\n    for (let i = 0; i < count; i++) {\r\n        // get face, center and corners\r\n        let center = centers[i];\r\n        let face = faces[i];\r\n        let faceCount = face.length;\r\n        if (face.length == 0) {\r\n            throw "HELP, WE ARE NOT DEALING WITH QUADS HERE!";\r\n        }\r\n        center = Vector3.new(0, 0, 0);\r\n        let corners = new Array(faceCount);\r\n        for (let j = 0; j < faceCount; j++) {\r\n            let vi = face[j];\r\n            corners[j] = graph.getVertexPos(vi);\r\n            center.add(corners[j]);\r\n        }\r\n        center.scale(1 / faceCount);\r\n        // now that we have center, calculate cca\r\n        let local_cca = 0;\r\n        for (let j = 0; j < faceCount; j++) {\r\n            local_cca = center.disTo(corners[j]);\r\n        }\r\n        local_cca /= faceCount;\r\n        cca += local_cca;\r\n        // but use the given one if present\r\n        let scaler;\r\n        let cca_diff;\r\n        if (centerCornerAverage) {\r\n            scaler = centerCornerAverage;\r\n            cca_diff = centerCornerAverage - local_cca;\r\n        }\r\n        else {\r\n            scaler = local_cca;\r\n            cca_diff = 0;\r\n        }\r\n        // rotate all corners into the same space, and get the average of that\r\n        // TODO SAVE TIME BY DOING THIS:\r\n        // new Vector2(v.dot(ihat), v.dot(jhat)).angle()\r\n        let plane = Plane.from3pt(center, corners[0], corners[1]);\r\n        let normedCorners = new Array(face.length);\r\n        let normedCenter = Vector3.new(0, 0, 0);\r\n        let delta = 2 / faceCount;\r\n        for (let j = 0; j < faceCount; j++) {\r\n            normedCorners[j] = plane.rotateVector(corners[j], j * Math.PI * delta);\r\n            normedCenter.add(normedCorners[j]);\r\n        }\r\n        // scale this averaged to the center corner average\r\n        normedCenter.scale(1 / 4);\r\n        let normal = normedCenter.subbed(center).normalize();\r\n        let perfectCorner = center.added(normal.scaled(local_cca));\r\n        // increate gunfactor if square is very small (awww)\r\n        let gunfactor = 1;\r\n        let equalizer = 200;\r\n        gunfactor += Math.max(-1 * cca_diff * equalizer, 0);\r\n        // console.log(gunfactor);\r\n        // rotate this average back, and add it to the movers of every vertex\r\n        for (let j = 0; j < faceCount; j++) {\r\n            let vi = face[j];\r\n            let v = plane.rotateVector(perfectCorner, j * Math.PI * delta);\r\n            movers[vi].add(v.scaled(gunfactor));\r\n            counters[vi] += 1;\r\n        }\r\n    }\r\n    // now, move the graph\r\n    for (let i = 0; i < movers.length; i++) {\r\n        let mover = movers[i];\r\n        let counter = counters[i];\r\n        if (counter < 1) {\r\n            continue;\r\n        }\r\n        let v = graph.getVertexPos(i);\r\n        v.add(mover.scale(1 / counter));\r\n    }\r\n    // return the center corner average, to be used in the next cycle\r\n    cca /= count;\r\n    return cca;\r\n}\r\nfunction quadification(graph) {\r\n    // edge deletion heuristic:\r\n    // remove edges between two triangles to create a quad.\r\n    // keep removing edges until no triangle neighbors another triangle.\r\n    // prepare\r\n    let count = graph.edges.length;\r\n    let edgeIds = new Array(count);\r\n    let visited = new Array(count);\r\n    graph.edges.forEach((e, i) => {\r\n        edgeIds[i] = i;\r\n        visited[i] = false;\r\n    });\r\n    // shuffle\r\n    let shuffler = (a, b) => {\r\n        return 0.5 - Math.random();\r\n    };\r\n    edgeIds.sort(shuffler);\r\n    // per edge\r\n    for (let i = 0; i < count; i++) {\r\n        let ei = edgeIds[i];\r\n        let e = graph.edges[ei];\r\n        if (e.dead || visited[ei]) {\r\n            continue;\r\n        }\r\n        let loops = graph.getLoopsAdjacentToEdge(ei);\r\n        // only delete edges between triangles\r\n        if (loops[0].length > 3 || loops[1].length > 3) {\r\n            continue;\r\n        }\r\n        // the edges of this new quad should not be touched!\r\n        for (let loop of loops) {\r\n            for (let edgeIndex of loop) {\r\n                visited[edgeIndex] = true;\r\n            }\r\n        }\r\n        // now remove this edge itself\r\n        graph.deleteEdgeByIndex(ei);\r\n    }\r\n}\r\nfunction randomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/transform-line-renderer.ts\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\nclass TransformLineRenderer extends renderer_Renderer {\r\n    constructor(gl, color = [1, 0, 0, 0.5]) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\n        precision mediump int;\n        precision mediump float;\n\n        attribute vec4 a_position;\n        uniform mat4 u_transform;\n        uniform mat4 u_personal;\n        uniform vec4 u_color;\n\n        void main() {\n            gl_Position = u_transform * u_personal * a_position;\n        }\n        `;\r\n        const fs = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n\n        void main () {\n            gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_personal = gl.getUniformLocation(this.program, "u_personal");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // set uniforms which wont change\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n        this.personal = matrix_Matrix4.newIdentity();\r\n        this.color = color;\r\n    }\r\n    static new(gl, color = [1, 0, 0, 0.5]) {\r\n        return new TransformLineRenderer(gl, color);\r\n    }\r\n    set(data, speed = renderer_DrawSpeed.StaticDraw) {\r\n        // save how many faces need to be drawn\r\n        let gl = this.gl;\r\n        let links;\r\n        let verts;\r\n        // extract\r\n        verts = data.mesh.verts;\r\n        links = data.mesh.toLines().links.getData();\r\n        this.personal = data.position;\r\n        this.color = data.linecolor;\r\n        // set it\r\n        gl.useProgram(this.program);\r\n        this.count = links.length;\r\n        this.vertCount = verts._width;\r\n        let drawspeed = this.convertDrawSpeed(speed);\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, verts.data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, links.buffer, drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        //\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        //\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniformMatrix4fv(this.u_personal, false, this.personal.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/renderers/transform-mesh-renderer.ts\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\nclass TransformMeshRenderer extends renderer_Renderer {\r\n    constructor(gl, color = [1, 0, 0, 0.25]) {\r\n        const vs = `\n        precision mediump int;\n        precision mediump float;\n\n        attribute vec4 a_position;\n        uniform mat4 u_transform;\n        uniform mat4 u_personal;\n        uniform vec4 u_color;\n\n        void main() {\n            gl_Position = u_transform * u_personal * a_position;\n        }\n        `;\r\n        const fs = `\n        precision mediump int;\n        precision mediump float;\n\n        uniform vec4 u_color;\n\n        void main () {\n            gl_FragColor = u_color;\n        }\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, "u_transform");\r\n        this.u_personal = gl.getUniformLocation(this.program, "u_personal");\r\n        this.u_color = gl.getUniformLocation(this.program, "u_color");\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, "a_position");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        this.personal = matrix_Matrix4.newIdentity();\r\n        this.color = color;\r\n    }\r\n    set(data, speed = renderer_DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        let mesh = data.mesh;\r\n        this.color = data.color;\r\n        this.personal = data.position;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.data, this.convertDrawSpeed(speed));\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, this.convertDrawSpeed(speed));\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniformMatrix4fv(this.u_personal, false, this.personal.data);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, renderer_DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/rendercombos/mesh-combo.ts\n\r\n\r\n\r\n\r\nclass StaticMeshCombo extends Combo {\r\n    constructor(gl) {\r\n        super(gl, mesh_Mesh.newEmpty(0, 0, 0), TransformLineRenderer.new);\r\n        this.color = [0, 0, 0, 0.8];\r\n        this.linecolor = [0.3, 0.3, 0.3, 1];\r\n        this.renderer2 = new TransformMeshRenderer(gl);\r\n    }\r\n    static new(gl) {\r\n        return new StaticMeshCombo(gl);\r\n    }\r\n    set(mesh) {\r\n        this.state = mesh;\r\n        this.buffer();\r\n    }\r\n    // how to convert from state to buffered\r\n    buffer() {\r\n        this.buffered = this.state.toRenderable();\r\n        this.buffered.calculateFaceNormals();\r\n        this.buffered.color = this.color;\r\n        this.buffered.linecolor = this.linecolor;\r\n        this.commit();\r\n    }\r\n    commit() {\r\n        this.buffered.color = this.color;\r\n        this.buffered.linecolor = this.linecolor;\r\n        this.renderer.set(this.buffered, renderer_DrawSpeed.StaticDraw);\r\n        this.renderer2.set(this.buffered, renderer_DrawSpeed.StaticDraw);\r\n    }\r\n    render(context) {\r\n        this.renderer2.render(context);\r\n        this.renderer.render(context);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./demo/apps/spherical/spherical-landing.ts\n// TODO\r\n// - improve quadification: less triangles!\r\n// - improve squarification: speed & equal sizes\r\n\r\n\r\n\r\n\r\nclass SphericalLandingApp extends App {\r\n    constructor(gl) {\r\n        super(gl, "Multiple Layers of spherical geometry");\r\n        this.radius = 0.1;\r\n        this.smoothlimit = 0;\r\n        this.worlds = [];\r\n        this.lerpColorState = 0;\r\n        this.mousePos = new vector_Vector2(0, 0);\r\n        this.lerpSpeed = 0.1;\r\n        this.color = [0, 0, 0, 0.8];\r\n        this.linecolor = [0.3, 0.3, 0.3, 1];\r\n        let canvas = gl.canvas;\r\n        this.c = new Context(new Camera(canvas, 1, true));\r\n        this.c.camera.pos = new vector_Vector3(-0.41347096487880547, 1.4944804848730606, 0.8300000000000006);\r\n        this.c.camera.set(-1, 2.379899, 0.751);\r\n        // this.c.camera.set(-4.08, 1.24, -0.71);\r\n    }\r\n    ui(ui) {\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        this.rotate = new Parameter("rotate", 1, 0, 1, 1);\r\n        this.randomEdges = new Parameter("delete edges", 1, 0, 1, 1);\r\n        this.smooth = new Parameter("smooth", 0, 0, 1, 1);\r\n        this.subCount = new Parameter("sub count", 2, 0, 4, 1);\r\n        this.quadSubCount = new Parameter("sub count quad", 1, 0, 2, 1);\r\n        this.liftType = EnumParameter.new("lift type", 1, ["none", "sphere", "buggy"]);\r\n        ui.hide();\r\n        ui.addBooleanParameter(this.rotate);\r\n        ui.addBooleanParameter(this.randomEdges, reset);\r\n        ui.addBooleanParameter(this.smooth);\r\n        ui.addParameter(this.subCount, reset);\r\n        ui.addParameter(this.quadSubCount, reset);\r\n        ui.addParameter(this.liftType, reset);\r\n        ui.addButton("recalculate", reset);\r\n    }\r\n    start() {\r\n        // set some values\r\n        this.radius = 1;\r\n        this.smoothlimit = 0;\r\n        // create the graph\r\n        this.graph = createGraph(1, this.subCount.get(), this.quadSubCount.get(), this.randomEdges.get());\r\n        // 5 | convert\r\n        this.average = averageEdgeLength(this.graph);\r\n        this.bufferWorld();\r\n        let canvas = this.gl.canvas;\r\n        let goto = canvas.getAttribute("data-goto");\r\n        console.log(goto);\r\n    }\r\n    bufferWorld() {\r\n        this.worlds = [];\r\n        let levels = [0, 0.1, 0.2, 0.3];\r\n        let freqs = [0.7, 0.5, 0.3];\r\n        for (let i = 0; i < 3; i++) {\r\n            let bot = levels[i];\r\n            let top = levels[i + 1];\r\n            let freq = freqs[i];\r\n            let mc = StaticMeshCombo.new(this.gl);\r\n            mc.set(constructMeshFromSphereGraph(this.graph, this.radius, bot, top, freq));\r\n            this.worlds.push(mc);\r\n        }\r\n    }\r\n    update(state) {\r\n        this.c.camera.update(state);\r\n        // update rotation\r\n        let speedb = 0.00007;\r\n        let scalar = 1 + 5 * Math.log10(1 + this.mousePos.disTo(state.mousePos));\r\n        this.mousePos = state.mousePos;\r\n        speedb *= scalar;\r\n        this.lerpSpeed = GeonMath.lerp(this.lerpSpeed, speedb, 0.03);\r\n        // rotate mesh\r\n        if (this.rotate.get() == 1) {\r\n            // rotate\r\n            let alpha = this.lerpSpeed * state.tick;\r\n            let rotx = matrix_Matrix4.newXRotation(alpha);\r\n            let roty = matrix_Matrix4.newYRotation(alpha);\r\n            let rot = rotx.multiply(roty);\r\n            this.worlds[0].buffered.position.multiply(rot);\r\n            this.worlds[1].buffered.position.multiply(matrix_Matrix4.newXRotation(-alpha));\r\n            this.worlds[2].buffered.position.multiply(matrix_Matrix4.newZRotation(-alpha));\r\n        }\r\n        // update color\r\n        this.updateColors(state);\r\n        // commit\r\n        for (let world of this.worlds) {\r\n            world.commit();\r\n        }\r\n    }\r\n    updateColors(state) {\r\n        let canvas = this.gl.canvas;\r\n        const step = 0.003;\r\n        let filled = canvas.getAttribute("data-filled");\r\n        if (filled == "1" && this.lerpColorState < 1) {\r\n            // fill it\r\n            console.log("fill");\r\n            this.lerpColorState += step;\r\n        }\r\n        else if (filled == "0" && this.lerpColorState > 0) {\r\n            // empty it\r\n            console.log("empty");\r\n            this.lerpColorState -= step;\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        let fade1 = GeonMath.fade(this.lerpColorState);\r\n        let fade2 = GeonMath.fade(Math.min(this.lerpColorState * 2, 1));\r\n        this.worlds.forEach((w) => {\r\n            w.color = blendColor(this.color, [0, 0, 0, 0], 1 - fade1);\r\n            w.linecolor = blendColor(this.linecolor, [0, 0, 0, 0], 1 - fade2);\r\n        });\r\n        this.lerpSpeed *= fade1;\r\n    }\r\n    draw(gl) {\r\n        if (this.lerpColorState == 0) {\r\n            return;\r\n        }\r\n        for (let world of this.worlds) {\r\n            world.render(this.c);\r\n        }\r\n    }\r\n}\r\nfunction blendColor(a, b, delta) {\r\n    return a.map((v, i) => {\r\n        return v * (1 - delta) + b[i] * delta;\r\n    });\r\n}\r\n\n;// CONCATENATED MODULE: ./demo/index.ts\n// Name:    index.ts\r\n// Author:  Jos Feenstra\r\n// Purpose: Entry point\r\n\r\n\r\nvar core;\r\nfunction main() {\r\n    // get references of all items on the canvas\r\n    let canvas = document.getElementById("canvas");\r\n    let video = document.getElementById("camera");\r\n    let ui = document.getElementById("interface");\r\n    let cameraOn = document.getElementById("camera-on");\r\n    let cameraStop = document.getElementById("camera-off");\r\n    let buttonPredict = document.getElementById("predict");\r\n    // init core\r\n    let gl = renderer_Renderer.initWebglContext(canvas);\r\n    core = new Core(canvas, gl, ui);\r\n    // init swap app\r\n    let appCollection = [SphericalLandingApp];\r\n    let swapApp = new SwapApp(gl, core, appCollection);\r\n    core.addApp(swapApp);\r\n    swapApp.swap(0);\r\n    // infinite loop\r\n    function loop() {\r\n        if (core.STOP) {\r\n            // TODO : notify the User that we have stopped running...\r\n            return;\r\n        }\r\n        core.update();\r\n        core.draw();\r\n        requestAnimationFrame(loop);\r\n    }\r\n    requestAnimationFrame(loop);\r\n}\r\nwindow.addEventListener("load", function () {\r\n    main();\r\n}, false);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9kYXRhL2ludC1tYXRyaXgudHM/MDMxYiIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9tYXRoL2NvbnN0LnRzPzI3OTQiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvbWF0aC9tYXRoLnRzP2RjYjgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZGF0YS9mbG9hdC1tYXRyaXgudHM/Nzk3NSIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9tYXRoL21hdHJpeC50cz8zN2ViIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL21hdGgvdXRpbC50cz9lNDQxIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL21hdGgvdmVjdG9yLnRzP2YxMDMiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZGF0YS92ZWN0b3ItYXJyYXkudHM/NjMzZiIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9tZXNoL3JlbmRlci1tZXNoLnRzPzg0MmMiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvbWF0aC9zdGF0aXN0aWNzLnRzPzBhNjgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZ2VvL3BsYW5lLnRzPzRiN2IiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZGF0YS9oYXNoLXRhYmxlLnRzPzQ0ODciLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvbWVzaC9ncmFwaC50cz8zNzRmIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL21lc2gvbWVzaC50cz80OTU5Iiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL2FsZ29yaXRobXMvbWFyY2hpbmctY3ViZXMudHM/MzlhMCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9hcHAvYXBwLnRzPzExMWYiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvc3lzdGVtL3VpLnRzPzM1OTAiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvYXBwL3N3YXAtYXBwLnRzP2MxZTgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZGF0YS9pbnQtY3ViZS50cz9kMjQ2Iiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL2dlby9jaXJjbGUyLnRzPzA4ZTciLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZ2VvL2NpcmNsZTMudHM/ZjQ1NCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9tYXRoL2RvbWFpbi50cz8wYjRiIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL2dlby9jdWJlLnRzP2JhZGIiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvZ2VvL2dlby50cz9mODdjIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL2dlby9pbnRlcnNlY3QudHM/YzkyNyIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9nZW8vbGluZS50cz82ZTdjIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL2dlby9yZWN0YW5nbGUudHM/YTBhOCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9nZW8vdHJpYW5nbGUudHM/YzNlOCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9pbWcva2VybmVscy50cz85NDVmIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL21lc2gvbGluZS1hcnJheS50cz81NzA5Iiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL21hdGgvcmF5LnRzP2YxMTgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvbWVzaC90b3BvLW1lc2gudHM/NmVlYyIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXIvY2FtZXJhLnRzPzMwZjgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyL2NvbWJvLnRzPzU5NmEiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyL2xpZ2h0LnRzPzdiMDUiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyL2NvbnRleHQudHM/MjUwZCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXIvcmVuZGVyZXIudHM/YzhjZCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXJlcnMvYmlsbGJvYXJkLXJlbmRlcmVyLnRzP2UzZmMiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL2RvdC1yZW5kZXJlcjIudHM/MWYzMSIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXJlcnMvZG90LXJlbmRlcmVyMy50cz9iZDc5Iiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3JlbmRlcmVycy9saW5lLXJlbmRlcmVyLnRzPzlkOTgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL3NpbXBsZS1tZXNoLXJlbmRlcmVyLnRzPzg5ZWUiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL21lc2gtbm9ybWFscy1yZW5kZXJlci50cz9lM2U3Iiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3JlbmRlci9tZXRhLXJlbmRlcmVyLnRzPzU2M2UiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL21lc2gtZGVidWctcmVuZGVyZXIudHM/OTIxYSIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXJlcnMvcmVjdGFuZ2xlLXJlbmRlcmVyLnRzP2U0NTMiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL3NoYWRlZC1tZXNoLXJlbmRlcmVyLnRzPzdlYzgiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL3RleHR1cmUtbWVzaC1yZW5kZXJlci50cz8wMzQxIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3JlbmRlcmVycy9ncmFwaC1kZWJ1Zy1yZW5kZXJlci50cz9mMWExIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3N5c3RlbS9kb213cmFwcGVycy50cz9kZmMxIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3N5c3RlbS9pbnB1dC1zdGF0ZS50cz84NjllIiwid2VicGFjazovL2dlb24tZW5naW5lLy4vc3JjL3N5c3RlbS9mcHNDb3VudGVyLnRzPzViOTUiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvc3lzdGVtL2NvcmUudHM/YTA3NSIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9yZW5kZXJjb21ib3MvaW1hZ2UtY29tYmkudHM/ZDQyNSIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL3NyYy9saWIudHM/NTZmMCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL2RlbW8vYXBwcy9zcGhlcmljYWwvc3BoZXJpY2FsLnRzPzM0YTkiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL3RyYW5zZm9ybS1saW5lLXJlbmRlcmVyLnRzP2FjY2MiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyZXJzL3RyYW5zZm9ybS1tZXNoLXJlbmRlcmVyLnRzP2EzZDIiLCJ3ZWJwYWNrOi8vZ2Vvbi1lbmdpbmUvLi9zcmMvcmVuZGVyY29tYm9zL21lc2gtY29tYm8udHM/OGI3YyIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL2RlbW8vYXBwcy9zcGhlcmljYWwvc3BoZXJpY2FsLWxhbmRpbmcudHM/YjE2NCIsIndlYnBhY2s6Ly9nZW9uLWVuZ2luZS8uL2RlbW8vaW5kZXgudHM/ODNjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ08sTUFBTSxvQkFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFTO0FBQ2pDLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdjJCTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZ0M7QUFDRTtBQUNDO0FBQ0w7QUFDdkIsTUFBTSxjQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQU87QUFDbkMsU0FBUztBQUNUO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixPQUFPLElBQUksT0FBTyxJQUFJLE9BQU87QUFDdkQ7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPLENBQUMsY0FBYyxvQkFBb0IsY0FBYyxvQkFBb0IsY0FBYztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFPO0FBQ3BCLE1BQU0sY0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU87QUFDMUI7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU8sSUFBSSxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBcUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUE2QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBWTtBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLGtDQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msa0NBQWtDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsR0FBRyxPQUFPLEdBQUc7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUFnQjtBQUNoQyxnQkFBZ0IsdUJBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBUyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFTLEdBQUc7QUFDMUM7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBLHNCQUFzQixtQkFBWTtBQUNsQywyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUIsdUNBQXVDLHFCQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9sQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQytDO0FBQ0s7QUFDWDtBQUN3QjtBQUM1QjtBQUNMO0FBQ3pCLE1BQU0sU0FBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSTtBQUN2QjtBQUNBO0FBQ0EsbUJBQW1CLFNBQUk7QUFDdkI7QUFDQTtBQUNBLG1CQUFtQixTQUFJLENBQUMsa0NBQXFCLFNBQVMsNkJBQWtCO0FBQ3hFO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSSxLQUFLLHlCQUFZLGlCQUFpQixvQkFBUztBQUNsRTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFxQjtBQUN6QyxvQkFBb0IsNkJBQWtCO0FBQ3RDLG1CQUFtQixTQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSSxLQUFLLHlCQUFZLFNBQVMsb0JBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQVk7QUFDcEMsd0JBQXdCLG9CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQUk7QUFDbkI7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCLG9CQUFvQixjQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsY0FBTztBQUM5QiwwQkFBMEIsaUJBQWlCO0FBQzNDLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQU87QUFDMUM7QUFDQTtBQUNBLG1DQUFtQyxjQUFPO0FBQzFDO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQVk7QUFDcEM7QUFDQSxzQkFBc0Isa0JBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2Qyx3QkFBd0IsY0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2Qyx3QkFBd0IsY0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFPO0FBQzlCLHVCQUF1QixnQkFBZ0I7QUFDdkMsK0JBQStCLGNBQU87QUFDdEM7QUFDQSxrQ0FBa0MsY0FBTztBQUN6QztBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQXFCO0FBQ3pDO0FBQ0Esd0JBQXdCLG9CQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGVBQWUsU0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFTO0FBQ3JDLDJCQUEyQix3QkFBd0I7QUFDbkQsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQSxtQkFBbUIsU0FBSTtBQUN2QjtBQUNBLHlCQUF5QixjQUFjO0FBQ3ZDO0FBQ0EsbUJBQW1CLFNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBbUI7QUFDbEM7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRCxtQkFBbUIsZUFBZTtBQUNsQztBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RCxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUFZO0FBQ3BDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBWTtBQUNwQyx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFpBO0FBQ0E7QUFDQTtBQUNvQztBQUNLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNW5CTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ3dDO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkM7QUFDakI7QUFDckIsc0JBQXNCLEdBQUc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoRXlDO0FBQ3pDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZzQztBQUNHO0FBQ2xDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ3NDO0FBQ047QUFDekI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDUjtBQUNyQyxNQUFNLGFBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sY0FBTztBQUNwQix3QkFBd0IsYUFBTSxZQUFZLGFBQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTyxDQUFDLGFBQU0sZ0JBQWdCLGFBQU07QUFDdkQ7QUFDQTtBQUNBLG1CQUFtQixjQUFPLEtBQUssYUFBTSxjQUFjLGFBQU07QUFDekQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU8sQ0FBQyxhQUFNLGlDQUFpQyxhQUFNO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sY0FBTztBQUNwQix3QkFBd0IsYUFBTSxZQUFZLGFBQU0sWUFBWSxhQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTyxLQUFLLGFBQU0sY0FBYyxhQUFNLGNBQWMsYUFBTTtBQUM3RTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU8sQ0FBQyxhQUFNLGdCQUFnQixhQUFNLGdCQUFnQixhQUFNO0FBQzdFO0FBQ0E7QUFDQSxtQkFBbUIsY0FBTyxDQUFDLGFBQU0saUJBQWlCLGFBQU0saUJBQWlCLGFBQU07QUFDL0U7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQU8sQ0FBQyxhQUFNLGlDQUFpQyxhQUFNLGlDQUFpQyxhQUFNO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFPO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDeUM7QUFDVDtBQUN6QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUN5QztBQUN6QztBQUNPO0FBQ1AsbUJBQW1CO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRXdDO0FBQ0M7QUFDekM7QUFDTyxNQUFNLGVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QnlDO0FBQ1Q7QUFDekI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBVTtBQUM3QjtBQUNBO0FBQ08sTUFBTSxvQkFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkNvRDtBQUNYO0FBQ0w7QUFDSjtBQUN6QixNQUFNLGtCQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLGtCQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R21EO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQVc7QUFDaEM7QUFDQSx5Q0FBeUMscUNBQXFDO0FBQzlFO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0NBQXdDO0FBQ2xGLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUFXO0FBQ3RDLDRCQUE0Qix3QkFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQVc7QUFDcEMsd0JBQXdCLHdCQUFXO0FBQ25DLHlCQUF5Qix3QkFBVztBQUNwQyxzQkFBc0Isd0JBQVc7QUFDakMsd0JBQXdCLHdCQUFXOzs7QUN2Rm5DO0FBQ0E7QUFDQTtBQUNBO0FBQzJFO0FBQ3JDO0FBQ0c7QUFDekM7QUFDTyxNQUFNLG9CQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQXFCO0FBQ3hDLG1CQUFtQixvQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFTO0FBQ2hDO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQVk7QUFDcEM7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLHVDQUF1QyxjQUFPO0FBQzlDLDJDQUEyQyxjQUFPO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLG1EQUFtRCxjQUFPO0FBQzFELHVEQUF1RCxjQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQTRCO0FBQ2hELGtCQUFrQixxQ0FBK0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQVk7QUFDcEM7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLHVDQUF1QyxjQUFPO0FBQzlDLDJDQUEyQyxjQUFPO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBLG1EQUFtRCxjQUFPO0FBQzFELHVEQUF1RCxjQUFPO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxjQUFPO0FBQzlDLDJDQUEyQyxjQUFPO0FBQ2xEO0FBQ0EsdUNBQXVDLGNBQU87QUFDOUMsMkNBQTJDLGNBQU87QUFDbEQ7QUFDQTtBQUNBLHVDQUF1QyxjQUFPO0FBQzlDLDJDQUEyQyxjQUFPO0FBQ2xEO0FBQ0EsdUNBQXVDLGNBQU87QUFDOUMsMkNBQTJDLGNBQU87QUFDbEQ7QUFDQTtBQUNBLHVDQUF1QyxjQUFPO0FBQzlDLDJDQUEyQyxjQUFPO0FBQ2xEO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUFxQjtBQUN6QztBQUNBLHdCQUF3Qix5QkFBWTtBQUNwQztBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQSx1REFBdUQsY0FBTztBQUM5RDtBQUNBLG1CQUFtQixvQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQXFCO0FBQ3pDLG1CQUFtQixvQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDTyxTQUFTLDRCQUFpQjtBQUNqQztBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5S0E7QUFDQTtBQUNBO0FBQytDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQW1CO0FBQ2xDO0FBQ0E7OztBQ2hDK0M7QUFDQTtBQUNLO0FBQ1g7QUFDRTtBQUNZO0FBQ3ZEO0FBQ08sdUJBQXVCLDBEQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOU5BO0FBQ0E7QUFDcUM7QUFDRztBQUNDO0FBQ1A7QUFDZ0I7QUFDM0M7QUFDUDtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0Isd0JBQXdCLG1CQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBYTtBQUN2QztBQUNBLHVCQUF1QixjQUFPO0FBQzlCO0FBQ0EsMEJBQTBCLGNBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLDBCQUEwQixZQUFZO0FBQ3RDLHlCQUF5QixXQUFXO0FBQ3BDLHdCQUF3QixnQkFBZ0I7QUFDeEMsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBb0I7QUFDeEMsb0NBQW9DLG9CQUFhO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQW9CO0FBQ3hDLG9DQUFvQyxvQkFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxpREFBaUQsY0FBTztBQUN4RDtBQUNBLG1EQUFtRCxjQUFPO0FBQzFELG1EQUFtRCxjQUFPO0FBQzFELG1EQUFtRCxjQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixjQUFPO0FBQ2hDO0FBQ0EsdUJBQXVCLDZCQUFzQjtBQUM3QyxzQkFBc0IsNkJBQXNCO0FBQzVDO0FBQ0EseUJBQXlCLDJCQUFvQjtBQUM3Qyx5QkFBeUIsMkJBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBc0I7QUFDL0M7QUFDQTtBQUNBOzs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxXQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDeUM7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYk87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ08sSUFBSSxrQkFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsa0JBQVMsS0FBSyxrQkFBUyxLQUFLO0FBQy9CO0FBQ08sTUFBTSxpQkFBUTtBQUNyQjtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFRO0FBQy9CO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQVE7QUFDbkMsNkJBQTZCLGlCQUFRO0FBQ3JDLGVBQWUsaUJBQVE7QUFDdkI7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTtBQUN5RDtBQUN6RDtBQUNPLCtCQUErQix3REFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQ0E7QUFDOEM7QUFDdkMsMkJBQTJCLHdEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNHQTtBQUM2RDtBQUNKO0FBQ2xELE1BQU0sMEJBQVksU0FBUyx3REFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDeUM7QUFDZ0I7QUFDckI7QUFDN0IsTUFBTSwwQkFBWSxTQUFTLHdEQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoR0E7QUFDQTtBQUNBO0FBQzZDO0FBQ3RDLE1BQU0sdUNBQWtCLFNBQVMsd0RBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RUE7QUFDQTtBQUNBO0FBQ29EO0FBQ0g7QUFDUjtBQUNjO0FBQ0U7QUFDbEQsTUFBTSxvQ0FBYyxTQUFTLHdEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdJbUM7QUFDNUIsTUFBTSwwQkFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDK0M7QUFDTjtBQUNNO0FBQ0E7QUFDYTtBQUNIO0FBQ0Y7QUFDaEQsZ0NBQWdDLDREQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZDQTtBQUM4QztBQUN2QyxnQ0FBZ0Msd0RBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVHQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDSDtBQUNIO0FBQ1I7QUFDZ0I7QUFDaEI7QUFDVjtBQUN4QixpQ0FBaUMsd0RBQVE7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0M7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUN5RDtBQUNsRCxNQUFNLHlDQUFtQixTQUFTLHdEQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UDtBQUNBOzs7QUMxVUE7QUFDQTtBQUNBO0FBQ3lDO0FBQ2dCO0FBQ2xELG9DQUFvQyxpQkFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoR0E7QUFDQTtBQUNBO0FBQ3NEO0FBQy9DLG9DQUFvQyxpQkFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQW1CO0FBQzNDO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBcUI7QUFDekM7QUFDQTtBQUNBOzs7QUN0RnNDO0FBQ1M7QUFDOEI7QUFDQTtBQUN0RSw4QkFBOEIsS0FBSztBQUMxQztBQUNBLGtCQUFrQixrQkFBYSxXQUFXLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw2QkFBb0I7QUFDN0QsMENBQTBDLDZCQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDd0g7QUFDaEQ7QUFDeEI7QUFDdUI7QUFDaEUsa0NBQWtDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxLQUFLLE1BQU07QUFDdkMsZ0NBQWdDLGNBQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixTQUFTO0FBQ25DLCtCQUErQixTQUFTO0FBQ3hDLDBCQUEwQixTQUFTO0FBQ25DLDRCQUE0QixTQUFTO0FBQ3JDLGdDQUFnQyxTQUFTO0FBQ3pDLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBb0I7QUFDM0MsdUJBQXVCLDJCQUFvQjtBQUMzQztBQUNBO0FBQ0Esc0RBQXNELDJCQUFvQjtBQUMxRSxzREFBc0QsMkJBQW9CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakMsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtDQUF5QjtBQUN0QyxlQUFlLElBQUk7QUFDbkI7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIzNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnZW5lcmljIGFsbC1wdXBvc2UgbWF0cml4IG9mIGludHNcclxuZXhwb3J0IGNsYXNzIEludE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQsIHdpZHRoLCBkYXRhID0gW10pIHtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDE2QXJyYXkodGhpcy5fd2lkdGggKiB0aGlzLl9oZWlnaHQpO1xyXG4gICAgICAgIGlmIChkYXRhID09IFtdIHx8IGRhdGEubGVuZ3RoID09IDApXHJcbiAgICAgICAgICAgIHRoaXMuZmlsbCgwKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YShkYXRhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTGlzdChsaXN0LCB3aWR0aCkge1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSBsaXN0Lmxlbmd0aCAvIHdpZHRoO1xyXG4gICAgICAgIGxldCBhcnJheSA9IG5ldyBJbnRNYXRyaXgoaGVpZ2h0LCB3aWR0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycmF5LmRhdGFbaV0gPSBsaXN0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICBwcmludCgpIHtcclxuICAgICAgICBsZXQgc3RyaW5ncyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IFdJRFRIID0gODtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hlaWdodDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChcInxcIik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuZ2V0KGksIGopLnRvRml4ZWQoMik7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucGFkU3RhcnQoV0lEVEgsIFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChzdHIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPCB0aGlzLl93aWR0aCAtIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goXCIgIFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goXCIgIHxcXG5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHN0cmluZ3Muam9pbihcIlwiKSk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBsZXQgY2xvbmUgPSBuZXcgSW50TWF0cml4KHRoaXMuX2hlaWdodCwgdGhpcy5fd2lkdGgpO1xyXG4gICAgICAgIGNsb25lLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgc2V0RGF0YShkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9IHRoaXMuX2hlaWdodCAqIHRoaXMuX3dpZHRoKVxyXG4gICAgICAgICAgICB0aHJvdyBcImRhdGEubGVuZ3RoIGRvZXMgbm90IG1hdGNoIHdpZHRoICogaGVpZ2h0IFwiICsgZGF0YS5sZW5ndGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmRhdGEuc2V0KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgLy8gbnVtYmVyIG9mIGVudHJpZXMgLyByb3dzLlxyXG4gICAgICAgIC8vIHdoZW4gZGVycml2ZWQgY2xhc3NlcyBhc2sgZm9yICdob3cgbWFueSBvZiB4PycgdGhleSB1c3VhbGx5IG1lYW4gdGhpcy5cclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0RGltZW5zaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuX2hlaWdodCwgdGhpcy5fd2lkdGhdO1xyXG4gICAgfVxyXG4gICAgaW5SYW5nZShpLCBqKSB7XHJcbiAgICAgICAgcmV0dXJuICEoaSA8IDAgfHwgaSA+IHRoaXMuX2hlaWdodCAtIDEgfHwgaiA8IDAgfHwgaiA+IHRoaXMuX3dpZHRoIC0gMSk7XHJcbiAgICB9XHJcbiAgICBmaWxsKHZhbHVlKSB7XHJcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLl9oZWlnaHQgKiB0aGlzLl93aWR0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWxsV2l0aChkYXRhLCB2YWx1ZXNQZXJFbnRyeSA9IHRoaXMuX3dpZHRoKSB7XHJcbiAgICAgICAgLy8gdmFsdWVzIHBlciBlbnRyeSBjYW4gYmUgdXNlZCB0byBzZXREYXRhIHdoaWNoIGlzIG5vdCBvZiB0aGUgc2FtZSBzaGFwZS5cclxuICAgICAgICBsZXQgdnBlID0gdmFsdWVzUGVyRW50cnk7XHJcbiAgICAgICAgaWYgKHZwZSA+IHRoaXMuX3dpZHRoKVxyXG4gICAgICAgICAgICB0aHJvdyBcInZhbHVlcyBwZXIgZW50cnkgaXMgbGFyZ2VyIHRoYW4gdGhpcy5fd2lkdGguIFRoaXMgd2lsbCBzcGlsbCBvdmVyLlwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2cGU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoaSwgaiwgZGF0YVtpICogdnBlICsgal0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGksIGopIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5SYW5nZShpLCBqKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJvdXQgb2YgcmFuZ2UhXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpICogdGhpcy5fd2lkdGggKyBqXTtcclxuICAgIH1cclxuICAgIGdldFJvdyhpKSB7XHJcbiAgICAgICAgLy8gaWYgKGkgPCAwIHx8IGkgPiB0aGlzLmhlaWdodCkgdGhyb3cgXCJjb2x1bW4gaXMgb3V0IG9mIGJvdW5kcyBmb3IgQXJyYXlcIlxyXG4gICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX3dpZHRoKTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3dpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgZGF0YVtqXSA9IHRoaXMuZ2V0KGksIGopO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIGdldENvbHVtbihqKSB7XHJcbiAgICAgICAgLy8gaWYgKGogPCAwIHx8IGogPiB0aGlzLndpZHRoKSB0aHJvdyBcImNvbHVtbiBpcyBvdXQgb2YgYm91bmRzIGZvciBBcnJheVwiXHJcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkodGhpcy5faGVpZ2h0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2hlaWdodDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGkgKiB0aGlzLl93aWR0aCArIGo7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIHNldChpLCBqLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pblJhbmdlKGksIGopKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm91dCBvZiByYW5nZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIGpdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXRSb3cocm93SW5kZXgsIHJvdykge1xyXG4gICAgICAgIC8vIGlmICh0aGlzLndpZHRoICE9IHJvdy5sZW5ndGgpIHRocm93IFwiZGltZW50aW9uIG9mIGZsb2F0YXJyYXkgaXMgbm90IFwiICsgcm93Lmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3dpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQocm93SW5kZXgsIGosIHJvd1tqXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGFrZVJvd3MoaW5kaWNlcykge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBhcnJheSBmcm9tIGEgY291cGxlIG9mIHJvd3NcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLl9oZWlnaHQsIHRoaXMuX3dpZHRoKTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBhcnJheSA9IG5ldyBJbnRNYXRyaXgoY291bnQsIHRoaXMuX3dpZHRoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGdldEluZGV4ID0gaW5kaWNlc1tpXTtcclxuICAgICAgICAgICAgYXJyYXkuc2V0Um93KGksIHRoaXMuZ2V0Um93KGdldEluZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIGdldERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIGZvckVhY2hWYWx1ZShjYWxsYmFja2ZuKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gY2FsbGJhY2tmbih0aGlzLmRhdGFbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZvckVhY2hSb3coY2FsbGJhY2tmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHRoaXMuZ2V0Um93KGkpO1xyXG4gICAgICAgICAgICBjYWxsYmFja2ZuKHJvdywgaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIHJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdHJ1ZUZvckFsbChjYWxsYmFja2ZuKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFjYWxsYmFja2ZuKHRoaXMuZGF0YVtpXSwgaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBjb25zdC50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogQ2VydGFpbiBtYXRoIGNvbnN0YW5jZXNcclxuLy8gdG9kbzogICAgVGhlc2UgYXJlIHNvbWV3aGF0IGxpa2UgdGhlIHNldHRpbmdzIG9mIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uIFRoaXMgY291bGQgYmUgZXhwYW5kZWQgdXBvbiAoanNvbidzLCBpbi1hcHAgZnVuY3Rpb25hbGl0aXkpXHJcbmV4cG9ydCBjbGFzcyBDb25zdCB7XHJcbiAgICBzdGF0aWMgSXNSb3VnbHlaZXJvKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlKSA8IHRoaXMuVE9MRVJBTkNFO1xyXG4gICAgfVxyXG59XHJcbkNvbnN0LlRPTEVSQU5DRSA9IDAuMDAwMTsgLy8gdG9sZXJhbmNlIHVzZWQgZm9yIGRldGVybWluaW5nIGlmIDEgdmFsdWUgaXMgdGhlIHNhbWUgYXMgc29tZSBvdGhlciB2YWx1ZSwgcmVsYXRpdmVseSBzcGVha2luZ1xyXG5Db25zdC5UT0xfU1FVQVJFRCA9IE1hdGgucG93KENvbnN0LlRPTEVSQU5DRSwgMik7XHJcbkNvbnN0Lk1BWF9VMTYgPSA2NTUzNjtcclxuLy8gLS0tLS0gTGluZSBSZW5kZXIgU2V0dGluZ3MgLS0tLS1cclxuQ29uc3QuUExBTkVfUkVOREVSX0xJTkVDT1VOVCA9IDk7XHJcbkNvbnN0LlBMQU5FX1JFTkRFUl9MSU5FRElTVEFOQ0UgPSAwLjM7XHJcbkNvbnN0LkNJUkNMRV9TRUdNRU5UUyA9IDEwMDtcclxuIiwiLy8gcHVycG9zZTogc2ltcGxlIG9wZXJhdGlvbnMgd2l0aCBvbmx5IG51bWJlcnNcclxuZXhwb3J0IGNsYXNzIEdlb25NYXRoIHtcclxuICAgIC8vIG1ha2Ugc3VyZSAndmFsdWUnIGlzIG1vcmUgdGhhbiAnbG93ZXInLCBhbmQgbGVzcyB0aGFuICd1cHBlcidcclxuICAgIHN0YXRpYyBjbGFtcCh2YWx1ZSwgbG93ZXIsIHVwcGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBsb3dlciksIHVwcGVyKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmYWRlKHQpIHtcclxuICAgICAgICAvLyBGYWRlIGZ1bmN0aW9uIGFzIGRlZmluZWQgYnkgS2VuIFBlcmxpbi4gIFRoaXMgZWFzZXMgY29vcmRpbmF0ZSB2YWx1ZXNcclxuICAgICAgICAvLyBzbyB0aGF0IHRoZXkgd2lsbCBlYXNlIHRvd2FyZHMgaW50ZWdyYWwgdmFsdWVzLiAgVGhpcyBlbmRzIHVwIHNtb290aGluZ1xyXG4gICAgICAgIC8vIHRoZSBmaW5hbCBvdXRwdXQuXHJcbiAgICAgICAgcmV0dXJuIHQgKiB0ICogdCAqICh0ICogKHQgKiA2IC0gMTUpICsgMTApOyAvLyA2dF41IC0gMTV0XjQgKyAxMHReM1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGxlcnAoYSwgYiwgeCkge1xyXG4gICAgICAgIHJldHVybiBhICsgeCAqIChiIC0gYSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmFkVG9EZWcocikge1xyXG4gICAgICAgIHJldHVybiAociAqIDE4MCkgLyBNYXRoLlBJO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlZ1RvUmFkKGQpIHtcclxuICAgICAgICByZXR1cm4gKGQgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgIH1cclxufVxyXG4iLCIvLyBnZW5lcmljIGFsbC1wdXBvc2UgbWF0cml4IG9mIGZsb2F0c1xyXG5leHBvcnQgY2xhc3MgRmxvYXRNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoaGVpZ2h0LCB3aWR0aCwgZGF0YSA9IFtdKSB7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl93aWR0aCAqIHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgaWYgKGRhdGEgPT0gW10gfHwgZGF0YS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhpcy5maWxsKDApO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5zZXREYXRhKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgbGV0IHN0cmluZ3MgPSBbXTtcclxuICAgICAgICBjb25zdCBXSURUSCA9IDg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9oZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goXCJ8XCIpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3dpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHIgPSB0aGlzLmdldChpLCBqKS50b0ZpeGVkKDIpO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gc3RyLnBhZFN0YXJ0KFdJRFRILCBcIiBcIik7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goc3RyKTtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgdGhpcy5fd2lkdGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKFwiICBcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyaW5ncy5wdXNoKFwiICB8XFxuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhzdHJpbmdzLmpvaW4oXCJcIikpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IEZsb2F0TWF0cml4KHRoaXMuX2hlaWdodCwgdGhpcy5fd2lkdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsb25lLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIHNldERhdGEoZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSB0aGlzLl9oZWlnaHQgKiB0aGlzLl93aWR0aClcclxuICAgICAgICAgICAgdGhyb3cgXCJkYXRhLmxlbmd0aCBkb2VzIG5vdCBtYXRjaCB3aWR0aCAqIGhlaWdodCBcIiArIGRhdGEubGVuZ3RoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhLnNldChkYXRhKTtcclxuICAgIH1cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIC8vIG51bWJlciBvZiBlbnRyaWVzIC8gcm93cy5cclxuICAgICAgICAvLyB3aGVuIGRlcnJpdmVkIGNsYXNzZXMgYXNrIGZvciAnaG93IG1hbnkgb2YgeD8nIHRoZXkgdXN1YWxseSBtZWFuIHRoaXMuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIGdldERpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLl9oZWlnaHQsIHRoaXMuX3dpZHRoXTtcclxuICAgIH1cclxuICAgIGZpbGwodmFsdWUpIHtcclxuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX2hlaWdodCAqIHRoaXMuX3dpZHRoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbGxXaXRoKGRhdGEsIHZhbHVlc1BlckVudHJ5ID0gdGhpcy5fd2lkdGgpIHtcclxuICAgICAgICAvLyB2YWx1ZXMgcGVyIGVudHJ5IGNhbiBiZSB1c2VkIHRvIHNldERhdGEgd2hpY2ggaXMgbm90IG9mIHRoZSBzYW1lIHNoYXBlLlxyXG4gICAgICAgIGxldCB2cGUgPSB2YWx1ZXNQZXJFbnRyeTtcclxuICAgICAgICBpZiAodnBlID4gdGhpcy5fd2lkdGgpXHJcbiAgICAgICAgICAgIHRocm93IFwidmFsdWVzIHBlciBlbnRyeSBpcyBsYXJnZXIgdGhhbiB0aGlzLl93aWR0aC4gVGhpcyB3aWxsIHNwaWxsIG92ZXIuXCI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZwZTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldChpLCBqLCBkYXRhW2kgKiB2cGUgKyBqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQoaSwgaikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaSAqIHRoaXMuX3dpZHRoICsgal07XHJcbiAgICB9XHJcbiAgICBnZXRSb3coaSkge1xyXG4gICAgICAgIC8vIGlmIChpIDwgMCB8fCBpID4gdGhpcy5oZWlnaHQpIHRocm93IFwiY29sdW1uIGlzIG91dCBvZiBib3VuZHMgZm9yIEZsb2F0QXJyYXlcIlxyXG4gICAgICAgIGxldCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl93aWR0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl93aWR0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGRhdGFbal0gPSB0aGlzLmdldChpLCBqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBnZXRDb2x1bW4oaikge1xyXG4gICAgICAgIC8vIGlmIChqIDwgMCB8fCBqID4gdGhpcy53aWR0aCkgdGhyb3cgXCJjb2x1bW4gaXMgb3V0IG9mIGJvdW5kcyBmb3IgRmxvYXRBcnJheVwiXHJcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpICogdGhpcy5fd2lkdGggKyBqO1xyXG4gICAgICAgICAgICBkYXRhW2ldID0gdGhpcy5kYXRhW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBzZXQoaSwgaiwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmRhdGFbaSAqIHRoaXMuX3dpZHRoICsgal0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldFJvdyhyb3dJbmRleCwgcm93KSB7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMud2lkdGggIT0gcm93Lmxlbmd0aCkgdGhyb3cgXCJkaW1lbnRpb24gb2YgZmxvYXRhcnJheSBpcyBub3QgXCIgKyByb3cubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICB0aGlzLnNldChyb3dJbmRleCwgaiwgcm93W2pdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoVmFsdWUoY2FsbGJhY2tmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGNhbGxiYWNrZm4odGhpcy5kYXRhW2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0YWtlUm93cyhpbmRpY2VzKSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGZsb2F0YXJyYXlcclxuICAgICAgICBjb25zdCBjb3VudCA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBhcnJheSA9IG5ldyBGbG9hdE1hdHJpeChjb3VudCwgdGhpcy5fd2lkdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZ2V0SW5kZXggPSBpbmRpY2VzW2ldO1xyXG4gICAgICAgICAgICBhcnJheS5zZXRSb3coaSwgdGhpcy5nZXRSb3coZ2V0SW5kZXgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG4gICAgLy8gY3JlYXRlIGEgbmV3IGZsb2F0bWF0cml4LCBwcm9jZXNzZWQgYnkgaXRlcmF0aW5nXHJcbiAgICBtYXBXaXRoKG90aGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gTWF0aC5taW4odGhpcy5fd2lkdGgsIG90aGVyLl9oZWlnaHQpO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSBNYXRoLm1pbih0aGlzLl9oZWlnaHQsIG90aGVyLl9oZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGksIGosIGNhbGxiYWNrKHRoaXMuZ2V0KGksIGopLCBvdGhlci5nZXQoaSwgaikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLy8gZ2VuZXJhbGl6ZWQgbXVsdGlwbGljYXRpb25cclxuICAgIG11bHRpcGx5KGIpIHtcclxuICAgICAgICBsZXQgYSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGIuX3dpZHRoICE9PSBhLl9oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1ucyBpbiBBIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gQlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgRmxvYXRNYXRyaXgoYS5faGVpZ2h0LCBiLl93aWR0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9kdWN0Ll9oZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIuX3dpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYS5fd2lkdGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3Quc2V0KGksIGosIHByb2R1Y3QuZ2V0KGksIGopICsgYS5nZXQoaSwgaykgKiBiLmdldChrLCBqKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbU5hdGl2ZShuYXRpdmUpIHtcclxuICAgICAgICAvLyBhc3N1bWUgYWxsIHN1YmFycmF5cyBoYXZlIHRoZSBzYW1lIHNoYXBlISFcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gbmF0aXZlLmxlbmd0aDtcclxuICAgICAgICBsZXQgd2lkdGggPSBuYXRpdmVbMF0ubGVuZ3RoO1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBuZXcgRmxvYXRNYXRyaXgoaGVpZ2h0LCB3aWR0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYXRpdmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuYXRpdmVbMF0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbmF0aXZlW2ldW2pdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgdG9OYXRpdmUoKSB7XHJcbiAgICAgICAgbGV0IG5hdGl2ZSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgbmF0aXZlW2ldID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbmF0aXZlW2ldW2pdID0gdGhpcy5nZXQoaSwgaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hdGl2ZTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBtYXRyaXhcclxuLy8gYXV0aG9yOiBKb3MgRmVlbnN0cmFcclxuLy8gVE9ETzogRklYIE1BVFJJWDQgISEhXHJcbi8vIE5PVEU6XHJcbmltcG9ydCB7IEZsb2F0TWF0cml4IH0gZnJvbSBcIi4uL2RhdGEvZmxvYXQtbWF0cml4XCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi92ZWN0b3JcIjtcclxuLy8gM3gzIG1hdHJpeCBvZiBmbG9hdHMgdXNlZCBmb3IgMmQgbWF0aFxyXG4vLyBpbnNwaXJlZCBieSBHcmVnZyBUYXZhcmVzLlxyXG5leHBvcnQgY2xhc3MgTWF0cml4MyBleHRlbmRzIEZsb2F0TWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBbXSkge1xyXG4gICAgICAgIHN1cGVyKDMsIDMsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld0lkZW50aXR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4MyhbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld1Byb2plY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgbWF0cml4IGZsaXBzIHRoZSBZIGF4aXMgc28gMCBpcyBhdCB0aGUgdG9wLlxyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4MyhbMiAvIHdpZHRoLCAwLCAwLCAwLCAtMiAvIGhlaWdodCwgMCwgLTEsIDEsIDFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdUcmFuc2xhdGlvbihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDMoWzEsIDAsIDAsIDAsIDEsIDAsIGR4LCBkeSwgMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgc3RhdGljIG5ld1JvdGF0aW9uKHIpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKHIpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4ocik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKFtjLCAtcywgMCwgcywgYywgMCwgMCwgMCwgMV0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld1NjYWxhcihzeCwgc3kpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDMoW3N4LCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMV0pO1xyXG4gICAgfVxyXG4gICAgdG9NYXQ0KCkge1xyXG4gICAgICAgIGxldCBkID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4NChbXHJcbiAgICAgICAgICAgIGRbMF0sXHJcbiAgICAgICAgICAgIGRbMV0sXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGRbMl0sXHJcbiAgICAgICAgICAgIGRbM10sXHJcbiAgICAgICAgICAgIGRbNF0sXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGRbNV0sXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIDEsXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGRbNl0sXHJcbiAgICAgICAgICAgIGRbN10sXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIGRbOF0sXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBwcm9qZWN0KHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShNYXRyaXgzLm5ld1Byb2plY3Rpb24od2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlTihkeCwgZHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShNYXRyaXgzLm5ld1RyYW5zbGF0aW9uKGR4LCBkeSkpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNsYXRlKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShNYXRyaXgzLm5ld1RyYW5zbGF0aW9uKHYueCwgdi55KSk7XHJcbiAgICB9XHJcbiAgICByb3RhdGUocikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KE1hdHJpeDMubmV3Um90YXRpb24ocikpO1xyXG4gICAgfVxyXG4gICAgc2NhbGUoc3gsIHN5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoTWF0cml4My5uZXdTY2FsYXIoc3gsIHN5KSk7XHJcbiAgICB9XHJcbiAgICAvLyBtdWx0aXBseSB0d28gbTMnc1xyXG4gICAgbXVsdGlwbHkob3RoZXIpIHtcclxuICAgICAgICBsZXQgYSA9IHRoaXMuZGF0YTtcclxuICAgICAgICBsZXQgYiA9IG90aGVyLmRhdGE7XHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMCAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYTAxID0gYVswICogMyArIDFdO1xyXG4gICAgICAgIHZhciBhMDIgPSBhWzAgKiAzICsgMl07XHJcbiAgICAgICAgdmFyIGExMCA9IGFbMSAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYTExID0gYVsxICogMyArIDFdO1xyXG4gICAgICAgIHZhciBhMTIgPSBhWzEgKiAzICsgMl07XHJcbiAgICAgICAgdmFyIGEyMCA9IGFbMiAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYTIxID0gYVsyICogMyArIDFdO1xyXG4gICAgICAgIHZhciBhMjIgPSBhWzIgKiAzICsgMl07XHJcbiAgICAgICAgdmFyIGIwMCA9IGJbMCAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYjAxID0gYlswICogMyArIDFdO1xyXG4gICAgICAgIHZhciBiMDIgPSBiWzAgKiAzICsgMl07XHJcbiAgICAgICAgdmFyIGIxMCA9IGJbMSAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYjExID0gYlsxICogMyArIDFdO1xyXG4gICAgICAgIHZhciBiMTIgPSBiWzEgKiAzICsgMl07XHJcbiAgICAgICAgdmFyIGIyMCA9IGJbMiAqIDMgKyAwXTtcclxuICAgICAgICB2YXIgYjIxID0gYlsyICogMyArIDFdO1xyXG4gICAgICAgIHZhciBiMjIgPSBiWzIgKiAzICsgMl07XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgzKFtcclxuICAgICAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwLFxyXG4gICAgICAgICAgICBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjEsXHJcbiAgICAgICAgICAgIGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMixcclxuICAgICAgICAgICAgYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwLFxyXG4gICAgICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEsXHJcbiAgICAgICAgICAgIGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMixcclxuICAgICAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwLFxyXG4gICAgICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEsXHJcbiAgICAgICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMixcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIC8vIHRyYW5zZm9ybSBhIHZlY3Rvci4gUkVDWUNMRSBJVFxyXG4gICAgdHJhbnNmb3JtVmVjdG9yKHYpIHtcclxuICAgICAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgICAgICBsZXQgdjAgPSB2Lng7XHJcbiAgICAgICAgbGV0IHYxID0gdi55O1xyXG4gICAgICAgIGxldCBkID0gdjAgKiBtWzAgKiAzICsgMl0gKyB2MSAqIG1bMSAqIDMgKyAyXSArIG1bMiAqIDMgKyAyXTtcclxuICAgICAgICB2LnggPSAodjAgKiBtWzAgKiAzICsgMF0gKyB2MSAqIG1bMSAqIDMgKyAwXSArIG1bMiAqIDMgKyAwXSkgLyBkO1xyXG4gICAgICAgIHYueSA9ICh2MCAqIG1bMCAqIDMgKyAxXSArIHYxICogbVsxICogMyArIDFdICsgbVsyICogMyArIDFdKSAvIGQ7XHJcbiAgICAgICAgcmV0dXJuIHY7XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gdGhlIGludmVyc2Ugb2YgdGhpcyBtYXRyaXhcclxuICAgIGludmVyc2UoKSB7XHJcbiAgICAgICAgLy8gaXZlIGdvdCBubyBpZGVhIHdoYXQgaXMgaGFwcGVuaW5nIGhlcmUsXHJcbiAgICAgICAgLy8gYnV0IGFwcGFyYW50bHksIHRoaXMgaXMgaG93IHlvdSBpbnZlcnNlIGEgM3gzIG1hdHJpeC5cclxuICAgICAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgdDAwID0gbVsxICogMyArIDFdICogbVsyICogMyArIDJdIC0gbVsxICogMyArIDJdICogbVsyICogMyArIDFdO1xyXG4gICAgICAgIHZhciB0MTAgPSBtWzAgKiAzICsgMV0gKiBtWzIgKiAzICsgMl0gLSBtWzAgKiAzICsgMl0gKiBtWzIgKiAzICsgMV07XHJcbiAgICAgICAgdmFyIHQyMCA9IG1bMCAqIDMgKyAxXSAqIG1bMSAqIDMgKyAyXSAtIG1bMCAqIDMgKyAyXSAqIG1bMSAqIDMgKyAxXTtcclxuICAgICAgICAvLyBkaXNjcmltaW5hbnRcclxuICAgICAgICB2YXIgZCA9IDEuMCAvIChtWzAgKiAzICsgMF0gKiB0MDAgLSBtWzEgKiAzICsgMF0gKiB0MTAgKyBtWzIgKiAzICsgMF0gKiB0MjApO1xyXG4gICAgICAgIHRoaXMuc2V0RGF0YShbXHJcbiAgICAgICAgICAgIGQgKiB0MDAsXHJcbiAgICAgICAgICAgIC1kICogdDEwLFxyXG4gICAgICAgICAgICBkICogdDIwLFxyXG4gICAgICAgICAgICAtZCAqIChtWzEgKiAzICsgMF0gKiBtWzIgKiAzICsgMl0gLSBtWzEgKiAzICsgMl0gKiBtWzIgKiAzICsgMF0pLFxyXG4gICAgICAgICAgICBkICogKG1bMCAqIDMgKyAwXSAqIG1bMiAqIDMgKyAyXSAtIG1bMCAqIDMgKyAyXSAqIG1bMiAqIDMgKyAwXSksXHJcbiAgICAgICAgICAgIC1kICogKG1bMCAqIDMgKyAwXSAqIG1bMSAqIDMgKyAyXSAtIG1bMCAqIDMgKyAyXSAqIG1bMSAqIDMgKyAwXSksXHJcbiAgICAgICAgICAgIGQgKiAobVsxICogMyArIDBdICogbVsyICogMyArIDFdIC0gbVsxICogMyArIDFdICogbVsyICogMyArIDBdKSxcclxuICAgICAgICAgICAgLWQgKiAobVswICogMyArIDBdICogbVsyICogMyArIDFdIC0gbVswICogMyArIDFdICogbVsyICogMyArIDBdKSxcclxuICAgICAgICAgICAgZCAqIChtWzAgKiAzICsgMF0gKiBtWzEgKiAzICsgMV0gLSBtWzAgKiAzICsgMV0gKiBtWzEgKiAzICsgMF0pLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcbi8vIDR4NCBtYXRyaXggb2YgZmxvYXRzIHVzZWQgZm9yIDNkIG1hdGhcclxuLy8gaW5zcGlyZWQgYnkgR3JlZ2cgVGF2YXJlcy5cclxuZXhwb3J0IGNsYXNzIE1hdHJpeDQgZXh0ZW5kcyBGbG9hdE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gW10pIHtcclxuICAgICAgICBzdXBlcig0LCA0LCBkYXRhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXcoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4NChkYXRhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdJZGVudGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDQoWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdDb3B5KG90aGVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhW2ldID0gb3RoZXIuZGF0YVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRyaXg0Lm5ld0NvcHkodGhpcyk7XHJcbiAgICB9XHJcbiAgICBtdWx0aXBsaWVkKG90aGVyKSB7XHJcbiAgICAgICAgLy8gTk9URTogaSBzd2FwcGVkIGEgYW5kIGIsIHRoaXMgbWFrZXMgbW9yZSBzZW5zZSB0byBtZSwgYnV0IGkgY291bGQgYmUgd3JvbmcgYWJvdXQgaXQuLi5cclxuICAgICAgICBjb25zdCBhID0gb3RoZXIuZGF0YTtcclxuICAgICAgICBjb25zdCBiID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIHZhciBiMDAgPSBiWzAgKiA0ICsgMF07XHJcbiAgICAgICAgdmFyIGIwMSA9IGJbMCAqIDQgKyAxXTtcclxuICAgICAgICB2YXIgYjAyID0gYlswICogNCArIDJdO1xyXG4gICAgICAgIHZhciBiMDMgPSBiWzAgKiA0ICsgM107XHJcbiAgICAgICAgdmFyIGIxMCA9IGJbMSAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgYjExID0gYlsxICogNCArIDFdO1xyXG4gICAgICAgIHZhciBiMTIgPSBiWzEgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIGIxMyA9IGJbMSAqIDQgKyAzXTtcclxuICAgICAgICB2YXIgYjIwID0gYlsyICogNCArIDBdO1xyXG4gICAgICAgIHZhciBiMjEgPSBiWzIgKiA0ICsgMV07XHJcbiAgICAgICAgdmFyIGIyMiA9IGJbMiAqIDQgKyAyXTtcclxuICAgICAgICB2YXIgYjIzID0gYlsyICogNCArIDNdO1xyXG4gICAgICAgIHZhciBiMzAgPSBiWzMgKiA0ICsgMF07XHJcbiAgICAgICAgdmFyIGIzMSA9IGJbMyAqIDQgKyAxXTtcclxuICAgICAgICB2YXIgYjMyID0gYlszICogNCArIDJdO1xyXG4gICAgICAgIHZhciBiMzMgPSBiWzMgKiA0ICsgM107XHJcbiAgICAgICAgdmFyIGEwMCA9IGFbMCAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgYTAxID0gYVswICogNCArIDFdO1xyXG4gICAgICAgIHZhciBhMDIgPSBhWzAgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIGEwMyA9IGFbMCAqIDQgKyAzXTtcclxuICAgICAgICB2YXIgYTEwID0gYVsxICogNCArIDBdO1xyXG4gICAgICAgIHZhciBhMTEgPSBhWzEgKiA0ICsgMV07XHJcbiAgICAgICAgdmFyIGExMiA9IGFbMSAqIDQgKyAyXTtcclxuICAgICAgICB2YXIgYTEzID0gYVsxICogNCArIDNdO1xyXG4gICAgICAgIHZhciBhMjAgPSBhWzIgKiA0ICsgMF07XHJcbiAgICAgICAgdmFyIGEyMSA9IGFbMiAqIDQgKyAxXTtcclxuICAgICAgICB2YXIgYTIyID0gYVsyICogNCArIDJdO1xyXG4gICAgICAgIHZhciBhMjMgPSBhWzIgKiA0ICsgM107XHJcbiAgICAgICAgdmFyIGEzMCA9IGFbMyAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgYTMxID0gYVszICogNCArIDFdO1xyXG4gICAgICAgIHZhciBhMzIgPSBhWzMgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIGEzMyA9IGFbMyAqIDQgKyAzXTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDQoW1xyXG4gICAgICAgICAgICBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzAsXHJcbiAgICAgICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSArIGIwMyAqIGEzMSxcclxuICAgICAgICAgICAgYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyICsgYjAzICogYTMyLFxyXG4gICAgICAgICAgICBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzMsXHJcbiAgICAgICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCArIGIxMyAqIGEzMCxcclxuICAgICAgICAgICAgYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxICsgYjEzICogYTMxLFxyXG4gICAgICAgICAgICBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzIsXHJcbiAgICAgICAgICAgIGIxMCAqIGEwMyArIGIxMSAqIGExMyArIGIxMiAqIGEyMyArIGIxMyAqIGEzMyxcclxuICAgICAgICAgICAgYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwICsgYjIzICogYTMwLFxyXG4gICAgICAgICAgICBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzEsXHJcbiAgICAgICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMixcclxuICAgICAgICAgICAgYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzLFxyXG4gICAgICAgICAgICBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzAsXHJcbiAgICAgICAgICAgIGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMSxcclxuICAgICAgICAgICAgYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyLFxyXG4gICAgICAgICAgICBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzMsXHJcbiAgICAgICAgXSk7XHJcbiAgICB9XHJcbiAgICBtdWx0aXBseShvdGhlcikge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMubXVsdGlwbGllZChvdGhlcikuZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHRyYW5zcG9zZSgpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgcmVzID0gbWF0cml4LmRhdGE7XHJcbiAgICAgICAgbGV0IG9sZCA9IHRoaXMuZGF0YTtcclxuICAgICAgICByZXNbMF0gPSBvbGRbMF07XHJcbiAgICAgICAgcmVzWzFdID0gb2xkWzRdO1xyXG4gICAgICAgIHJlc1syXSA9IG9sZFs4XTtcclxuICAgICAgICByZXNbM10gPSBvbGRbMTJdO1xyXG4gICAgICAgIHJlc1s0XSA9IG9sZFsxXTtcclxuICAgICAgICByZXNbNV0gPSBvbGRbNV07XHJcbiAgICAgICAgcmVzWzZdID0gb2xkWzldO1xyXG4gICAgICAgIHJlc1s3XSA9IG9sZFsxM107XHJcbiAgICAgICAgcmVzWzhdID0gb2xkWzJdO1xyXG4gICAgICAgIHJlc1s5XSA9IG9sZFs2XTtcclxuICAgICAgICByZXNbMTBdID0gb2xkWzEwXTtcclxuICAgICAgICByZXNbMTFdID0gb2xkWzE0XTtcclxuICAgICAgICByZXNbMTJdID0gb2xkWzNdO1xyXG4gICAgICAgIHJlc1sxM10gPSBvbGRbN107XHJcbiAgICAgICAgcmVzWzE0XSA9IG9sZFsxMV07XHJcbiAgICAgICAgcmVzWzE1XSA9IG9sZFsxNV07XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdMb29rQXQoY2FtZXJhUG9zaXRpb24sIHRhcmdldCwgdXApIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgZGF0YSA9IG1hdHJpeC5kYXRhO1xyXG4gICAgICAgIGxldCB6QXhpcyA9IGNhbWVyYVBvc2l0aW9uLmNsb25lKCkuc3ViKHRhcmdldCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgbGV0IHhBeGlzID0gdXAuY2xvbmUoKS5jcm9zcyh1cCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgbGV0IHlBeGlzID0gekF4aXMuY2xvbmUoKS5jcm9zcyh4QXhpcykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgZGF0YVswXSA9IHhBeGlzLng7XHJcbiAgICAgICAgZGF0YVsxXSA9IHhBeGlzLnk7XHJcbiAgICAgICAgZGF0YVsyXSA9IHhBeGlzLno7XHJcbiAgICAgICAgZGF0YVszXSA9IDA7XHJcbiAgICAgICAgZGF0YVs0XSA9IHlBeGlzLng7XHJcbiAgICAgICAgZGF0YVs1XSA9IHlBeGlzLnk7XHJcbiAgICAgICAgZGF0YVs2XSA9IHlBeGlzLno7XHJcbiAgICAgICAgZGF0YVs3XSA9IDA7XHJcbiAgICAgICAgZGF0YVs4XSA9IHpBeGlzLng7XHJcbiAgICAgICAgZGF0YVs5XSA9IHpBeGlzLnk7XHJcbiAgICAgICAgZGF0YVsxMF0gPSB6QXhpcy56O1xyXG4gICAgICAgIGRhdGFbMTFdID0gMDtcclxuICAgICAgICBkYXRhWzEyXSA9IGNhbWVyYVBvc2l0aW9uLng7XHJcbiAgICAgICAgZGF0YVsxM10gPSBjYW1lcmFQb3NpdGlvbi55O1xyXG4gICAgICAgIGRhdGFbMTRdID0gY2FtZXJhUG9zaXRpb24uejtcclxuICAgICAgICBkYXRhWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgcGVyc3BlY3RpdmUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGdpdmVuIHRoZSBhbmd1bGFyIGhlaWdodFxyXG4gICAgICogb2YgdGhlIGZydXN0dW0sIHRoZSBhc3BlY3QgcmF0aW8sIGFuZCB0aGUgbmVhciBhbmQgZmFyIGNsaXBwaW5nIHBsYW5lcy4gIFRoZVxyXG4gICAgICogYXJndW1lbnRzIGRlZmluZSBhIGZydXN0dW0gZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gIFRoZSBnaXZlblxyXG4gICAgICogYW5nbGUgaXMgdGhlIHZlcnRpY2FsIGFuZ2xlIG9mIHRoZSBmcnVzdHVtLCBhbmQgdGhlIGhvcml6b250YWwgYW5nbGUgaXNcclxuICAgICAqIGRldGVybWluZWQgdG8gcHJvZHVjZSB0aGUgZ2l2ZW4gYXNwZWN0IHJhdGlvLiAgVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlXHJcbiAgICAgKiB0aGUgZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiAgTm90ZSB0aGF0IG5lYXIgYW5kIGZhclxyXG4gICAgICogYXJlIG5vdCB6IGNvb3JkaW5hdGVzLCBidXQgcmF0aGVyIHRoZXkgYXJlIGRpc3RhbmNlcyBhbG9uZyB0aGUgbmVnYXRpdmVcclxuICAgICAqIHotYXhpcy4gIFRoZSBtYXRyaXggZ2VuZXJhdGVkIHNlbmRzIHRoZSB2aWV3aW5nIGZydXN0dW0gdG8gdGhlIHVuaXQgYm94LlxyXG4gICAgICogV2UgYXNzdW1lIGEgdW5pdCBib3ggZXh0ZW5kaW5nIGZyb20gLTEgdG8gMSBpbiB0aGUgeCBhbmQgeSBkaW1lbnNpb25zIGFuZFxyXG4gICAgICogZnJvbSAtMSB0byAxIGluIHRoZSB6IGRpbWVuc2lvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZE9mVmlld0luUmFkaWFucyBmaWVsZCBvZiB2aWV3IGluIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3QgYXNwZWN0IG9mIHZpZXdwb3J0ICh3aWR0aCAvIGhlaWdodClcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIG5lYXIgWiBjbGlwcGluZyBwbGFuZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhciBmYXIgWiBjbGlwcGluZyBwbGFuZVxyXG4gICAgICogQHBhcmFtIHtNYXRyaXg0fSBbZHN0XSBvcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgcmVzdWx0XHJcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXg0fSBkc3Qgb3IgYSBuZXcgbWF0cml4IGlmIG5vbmUgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld1BlcnNwZWN0aXZlKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgZGF0YSA9IG1hdHJpeC5kYXRhO1xyXG4gICAgICAgIHZhciBmID0gTWF0aC50YW4oTWF0aC5QSSAqIDAuNSAtIDAuNSAqIGZvdik7XHJcbiAgICAgICAgdmFyIHJhbmdlSW52ID0gMS4wIC8gKG5lYXIgLSBmYXIpO1xyXG4gICAgICAgIGRhdGFbMF0gPSBmIC8gYXNwZWN0O1xyXG4gICAgICAgIGRhdGFbMV0gPSAwO1xyXG4gICAgICAgIGRhdGFbMl0gPSAwO1xyXG4gICAgICAgIGRhdGFbM10gPSAwO1xyXG4gICAgICAgIGRhdGFbNF0gPSAwO1xyXG4gICAgICAgIGRhdGFbNV0gPSBmO1xyXG4gICAgICAgIGRhdGFbNl0gPSAwO1xyXG4gICAgICAgIGRhdGFbN10gPSAwO1xyXG4gICAgICAgIGRhdGFbOF0gPSAwO1xyXG4gICAgICAgIGRhdGFbOV0gPSAwO1xyXG4gICAgICAgIGRhdGFbMTBdID0gKG5lYXIgKyBmYXIpICogcmFuZ2VJbnY7XHJcbiAgICAgICAgZGF0YVsxMV0gPSAtMTtcclxuICAgICAgICBkYXRhWzEyXSA9IDA7XHJcbiAgICAgICAgZGF0YVsxM10gPSAwO1xyXG4gICAgICAgIGRhdGFbMTRdID0gbmVhciAqIGZhciAqIHJhbmdlSW52ICogMjtcclxuICAgICAgICBkYXRhWzE1XSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYSA0LWJ5LTQgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gbWF0cml4IGdpdmVuIHRoZSBjb29yZGluYXRlcyBvZiB0aGVcclxuICAgICAqIHBsYW5lcyBkZWZpbmluZyB0aGUgYXhpcy1hbGlnbmVkLCBib3gtc2hhcGVkIHZpZXdpbmcgdm9sdW1lLiAgVGhlIG1hdHJpeFxyXG4gICAgICogZ2VuZXJhdGVkIHNlbmRzIHRoYXQgYm94IHRvIHRoZSB1bml0IGJveC4gIE5vdGUgdGhhdCBhbHRob3VnaCBsZWZ0IGFuZCByaWdodFxyXG4gICAgICogYXJlIHggY29vcmRpbmF0ZXMgYW5kIGJvdHRvbSBhbmQgdG9wIGFyZSB5IGNvb3JkaW5hdGVzLCBuZWFyIGFuZCBmYXJcclxuICAgICAqIGFyZSBub3QgeiBjb29yZGluYXRlcywgYnV0IHJhdGhlciB0aGV5IGFyZSBkaXN0YW5jZXMgYWxvbmcgdGhlIG5lZ2F0aXZlXHJcbiAgICAgKiB6LWF4aXMuICBXZSBhc3N1bWUgYSB1bml0IGJveCBleHRlbmRpbmcgZnJvbSAtMSB0byAxIGluIHRoZSB4IGFuZCB5XHJcbiAgICAgKiBkaW1lbnNpb25zIGFuZCBmcm9tIC0xIHRvIDEgaW4gdGhlIHogZGltZW5zaW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgbGVmdCBwbGFuZSBvZiB0aGUgYm94LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBwbGFuZSBvZiB0aGUgYm94LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUaGUgeSBjb29yZGluYXRlIG9mIHRoZSByaWdodCBwbGFuZSBvZiB0aGUgYm94LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgVGhlIG5lZ2F0aXZlIHogY29vcmRpbmF0ZSBvZiB0aGUgbmVhciBwbGFuZSBvZiB0aGUgYm94LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBmYXIgcGxhbmUgb2YgdGhlIGJveC5cclxuICAgICAqIEBwYXJhbSB7TWF0cml4NH0gW2RzdF0gb3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHJlc3VsdFxyXG4gICAgICogQHJldHVybiB7TWF0cml4NH0gZHN0IG9yIGEgbmV3IG1hdHJpeCBpZiBub25lIHByb3ZpZGVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBuZXdPcnRob2dyYXBoaWMobGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgZHN0ID0gbWF0cml4LmRhdGE7XHJcbiAgICAgICAgZHN0WzBdID0gMiAvIChyaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIGRzdFsxXSA9IDA7XHJcbiAgICAgICAgZHN0WzJdID0gMDtcclxuICAgICAgICBkc3RbM10gPSAwO1xyXG4gICAgICAgIGRzdFs0XSA9IDA7XHJcbiAgICAgICAgZHN0WzVdID0gMiAvICh0b3AgLSBib3R0b20pO1xyXG4gICAgICAgIGRzdFs2XSA9IDA7XHJcbiAgICAgICAgZHN0WzddID0gMDtcclxuICAgICAgICBkc3RbOF0gPSAwO1xyXG4gICAgICAgIGRzdFs5XSA9IDA7XHJcbiAgICAgICAgZHN0WzEwXSA9IDIgLyAobmVhciAtIGZhcik7XHJcbiAgICAgICAgZHN0WzExXSA9IDA7XHJcbiAgICAgICAgZHN0WzEyXSA9IChsZWZ0ICsgcmlnaHQpIC8gKGxlZnQgLSByaWdodCk7XHJcbiAgICAgICAgZHN0WzEzXSA9IChib3R0b20gKyB0b3ApIC8gKGJvdHRvbSAtIHRvcCk7XHJcbiAgICAgICAgZHN0WzE0XSA9IChuZWFyICsgZmFyKSAvIChuZWFyIC0gZmFyKTtcclxuICAgICAgICBkc3RbMTVdID0gMTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhIDQtYnktNCBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZ2l2ZW4gdGhlIGxlZnQsIHJpZ2h0LFxyXG4gICAgICogdG9wLCBib3R0b20sIG5lYXIgYW5kIGZhciBjbGlwcGluZyBwbGFuZXMuIFRoZSBhcmd1bWVudHMgZGVmaW5lIGEgZnJ1c3R1bVxyXG4gICAgICogZXh0ZW5kaW5nIGluIHRoZSBuZWdhdGl2ZSB6IGRpcmVjdGlvbi4gVGhlIGFyZ3VtZW50cyBuZWFyIGFuZCBmYXIgYXJlIHRoZVxyXG4gICAgICogZGlzdGFuY2VzIHRvIHRoZSBuZWFyIGFuZCBmYXIgY2xpcHBpbmcgcGxhbmVzLiBOb3RlIHRoYXQgbmVhciBhbmQgZmFyIGFyZSBub3RcclxuICAgICAqIHogY29vcmRpbmF0ZXMsIGJ1dCByYXRoZXIgdGhleSBhcmUgZGlzdGFuY2VzIGFsb25nIHRoZSBuZWdhdGl2ZSB6LWF4aXMuIFRoZVxyXG4gICAgICogbWF0cml4IGdlbmVyYXRlZCBzZW5kcyB0aGUgdmlld2luZyBmcnVzdHVtIHRvIHRoZSB1bml0IGJveC4gV2UgYXNzdW1lIGEgdW5pdFxyXG4gICAgICogYm94IGV4dGVuZGluZyBmcm9tIC0xIHRvIDEgaW4gdGhlIHggYW5kIHkgZGltZW5zaW9ucyBhbmQgZnJvbSAtMSB0byAxIGluIHRoZSB6XHJcbiAgICAgKiBkaW1lbnNpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVmdCBUaGUgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IHBsYW5lIG9mIHRoZSBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgVGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgcmlnaHQgcGxhbmUgb2YgdGhlIGJveC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gVGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIHBsYW5lIG9mIHRoZSBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9wIFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IHBsYW5lIG9mIHRoZSBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmVhciBUaGUgbmVnYXRpdmUgeiBjb29yZGluYXRlIG9mIHRoZSBuZWFyIHBsYW5lIG9mIHRoZSBib3guXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmFyIFRoZSBuZWdhdGl2ZSB6IGNvb3JkaW5hdGUgb2YgdGhlIGZhciBwbGFuZSBvZiB0aGUgYm94LlxyXG4gICAgICogQHBhcmFtIHtNYXRyaXg0fSBbZHN0XSBvcHRpb25hbCBtYXRyaXggdG8gc3RvcmUgcmVzdWx0XHJcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXg0fSBkc3Qgb3IgYSBuZXcgbWF0cml4IGlmIG5vbmUgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0ZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgZHN0ID0gbWF0cml4LmRhdGE7XHJcbiAgICAgICAgdmFyIGR4ID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgICAgIHZhciBkeSA9IHRvcCAtIGJvdHRvbTtcclxuICAgICAgICB2YXIgZHogPSBmYXIgLSBuZWFyO1xyXG4gICAgICAgIGRzdFswXSA9ICgyICogbmVhcikgLyBkeDtcclxuICAgICAgICBkc3RbMV0gPSAwO1xyXG4gICAgICAgIGRzdFsyXSA9IDA7XHJcbiAgICAgICAgZHN0WzNdID0gMDtcclxuICAgICAgICBkc3RbNF0gPSAwO1xyXG4gICAgICAgIGRzdFs1XSA9ICgyICogbmVhcikgLyBkeTtcclxuICAgICAgICBkc3RbNl0gPSAwO1xyXG4gICAgICAgIGRzdFs3XSA9IDA7XHJcbiAgICAgICAgZHN0WzhdID0gKGxlZnQgKyByaWdodCkgLyBkeDtcclxuICAgICAgICBkc3RbOV0gPSAodG9wICsgYm90dG9tKSAvIGR5O1xyXG4gICAgICAgIGRzdFsxMF0gPSAtKGZhciArIG5lYXIpIC8gZHo7XHJcbiAgICAgICAgZHN0WzExXSA9IC0xO1xyXG4gICAgICAgIGRzdFsxMl0gPSAwO1xyXG4gICAgICAgIGRzdFsxM10gPSAwO1xyXG4gICAgICAgIGRzdFsxNF0gPSAoLTIgKiBuZWFyICogZmFyKSAvIGR6O1xyXG4gICAgICAgIGRzdFsxNV0gPSAwO1xyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3VHJhbnNsYXRpb24odHgsIHR5LCB0eikge1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4NChbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMV0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld1hSb3RhdGlvbihhbmdsZUluUmFkaWFucykge1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTWF0cml4NChbMSwgMCwgMCwgMCwgMCwgYywgLXMsIDAsIDAsIHMsIGMsIDAsIDAsIDAsIDAsIDFdKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdZUm90YXRpb24oYW5nbGVJblJhZGlhbnMpIHtcclxuICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlSW5SYWRpYW5zKTtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeDQoW2MsIDAsIHMsIDAsIDAsIDEsIDAsIDAsIC1zLCAwLCBjLCAwLCAwLCAwLCAwLCAxXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3WlJvdGF0aW9uKGFuZ2xlSW5SYWRpYW5zKSB7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgbGV0IGRzdCA9IG1hdHJpeC5kYXRhO1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIGRzdFswXSA9IGM7XHJcbiAgICAgICAgZHN0WzFdID0gcztcclxuICAgICAgICBkc3RbMl0gPSAwO1xyXG4gICAgICAgIGRzdFszXSA9IDA7XHJcbiAgICAgICAgZHN0WzRdID0gLXM7XHJcbiAgICAgICAgZHN0WzVdID0gYztcclxuICAgICAgICBkc3RbNl0gPSAwO1xyXG4gICAgICAgIGRzdFs3XSA9IDA7XHJcbiAgICAgICAgZHN0WzhdID0gMDtcclxuICAgICAgICBkc3RbOV0gPSAwO1xyXG4gICAgICAgIGRzdFsxMF0gPSAxO1xyXG4gICAgICAgIGRzdFsxMV0gPSAwO1xyXG4gICAgICAgIGRzdFsxMl0gPSAwO1xyXG4gICAgICAgIGRzdFsxM10gPSAwO1xyXG4gICAgICAgIGRzdFsxNF0gPSAwO1xyXG4gICAgICAgIGRzdFsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIGFuIHJvdGF0aW9uIG1hdHJpeCBhcm91bmQgYW4gYXJiaXRyYXJ5IGF4aXNcclxuICAgICAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBhbW91bnQgdG8gcm90YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtNYXRyaXg0fSBkc3Qgb3IgYSBuZXcgbWF0cml4IGlmIG5vbmUgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG5ld0F4aXNSb3RhdGlvbihheGlzLCBhbmdsZUluUmFkaWFucykge1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG4gICAgICAgIGxldCBkc3QgPSBtYXRyaXguZGF0YTtcclxuICAgICAgICBsZXQgeCA9IGF4aXMueDtcclxuICAgICAgICBsZXQgeSA9IGF4aXMueTtcclxuICAgICAgICBsZXQgeiA9IGF4aXMuejtcclxuICAgICAgICBsZXQgbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xyXG4gICAgICAgIHggLz0gbjtcclxuICAgICAgICB5IC89IG47XHJcbiAgICAgICAgeiAvPSBuO1xyXG4gICAgICAgIGxldCB4eCA9IHggKiB4O1xyXG4gICAgICAgIGxldCB5eSA9IHkgKiB5O1xyXG4gICAgICAgIGxldCB6eiA9IHogKiB6O1xyXG4gICAgICAgIGxldCBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIGxldCBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIGxldCBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xyXG4gICAgICAgIGRzdFswXSA9IHh4ICsgKDEgLSB4eCkgKiBjO1xyXG4gICAgICAgIGRzdFsxXSA9IHggKiB5ICogb25lTWludXNDb3NpbmUgKyB6ICogcztcclxuICAgICAgICBkc3RbMl0gPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XHJcbiAgICAgICAgZHN0WzNdID0gMDtcclxuICAgICAgICBkc3RbNF0gPSB4ICogeSAqIG9uZU1pbnVzQ29zaW5lIC0geiAqIHM7XHJcbiAgICAgICAgZHN0WzVdID0geXkgKyAoMSAtIHl5KSAqIGM7XHJcbiAgICAgICAgZHN0WzZdID0geSAqIHogKiBvbmVNaW51c0Nvc2luZSArIHggKiBzO1xyXG4gICAgICAgIGRzdFs3XSA9IDA7XHJcbiAgICAgICAgZHN0WzhdID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xyXG4gICAgICAgIGRzdFs5XSA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgLSB4ICogcztcclxuICAgICAgICBkc3RbMTBdID0genogKyAoMSAtIHp6KSAqIGM7XHJcbiAgICAgICAgZHN0WzExXSA9IDA7XHJcbiAgICAgICAgZHN0WzEyXSA9IDA7XHJcbiAgICAgICAgZHN0WzEzXSA9IDA7XHJcbiAgICAgICAgZHN0WzE0XSA9IDA7XHJcbiAgICAgICAgZHN0WzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgYnkgYW4gYXhpcyByb3RhdGlvbiBtYXRyaXhcclxuICAgICAqIEBwYXJhbSB7TWF0cml4NH0gbSBtYXRyaXggdG8gbXVsdGlwbHlcclxuICAgICAqIEBwYXJhbSB7VmVjdG9yM30gYXhpcyBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZUluUmFkaWFucyBhbW91bnQgdG8gcm90YXRlXHJcbiAgICAgKiBAcGFyYW0ge01hdHJpeDR9IFtkc3RdIG9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSByZXN1bHRcclxuICAgICAqIEByZXR1cm4ge01hdHJpeDR9IGRzdCBvciBhIG5ldyBtYXRyaXggaWYgbm9uZSBwcm92aWRlZFxyXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp3ZWJnbC0zZC1tYXRoXHJcbiAgICAgKi9cclxuICAgIGF4aXNSb3RhdGUoYXhpcywgYW5nbGVJblJhZGlhbnMpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBvcHRpbWl6ZWQgdmVyc2lvbiBvZlxyXG4gICAgICAgIC8vIHJldHVybiBtdWx0aXBseShtLCBheGlzUm90YXRpb24oYXhpcywgYW5nbGVJblJhZGlhbnMpLCBkc3QpO1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG4gICAgICAgIGxldCBkc3QgPSBtYXRyaXguZGF0YTtcclxuICAgICAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgeCA9IGF4aXMueDtcclxuICAgICAgICB2YXIgeSA9IGF4aXMueTtcclxuICAgICAgICB2YXIgeiA9IGF4aXMuejtcclxuICAgICAgICB2YXIgbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xyXG4gICAgICAgIHggLz0gbjtcclxuICAgICAgICB5IC89IG47XHJcbiAgICAgICAgeiAvPSBuO1xyXG4gICAgICAgIHZhciB4eCA9IHggKiB4O1xyXG4gICAgICAgIHZhciB5eSA9IHkgKiB5O1xyXG4gICAgICAgIHZhciB6eiA9IHogKiB6O1xyXG4gICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpO1xyXG4gICAgICAgIHZhciBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xyXG4gICAgICAgIHZhciByMDAgPSB4eCArICgxIC0geHgpICogYztcclxuICAgICAgICB2YXIgcjAxID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZSArIHogKiBzO1xyXG4gICAgICAgIHZhciByMDIgPSB4ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geSAqIHM7XHJcbiAgICAgICAgdmFyIHIxMCA9IHggKiB5ICogb25lTWludXNDb3NpbmUgLSB6ICogcztcclxuICAgICAgICB2YXIgcjExID0geXkgKyAoMSAtIHl5KSAqIGM7XHJcbiAgICAgICAgdmFyIHIxMiA9IHkgKiB6ICogb25lTWludXNDb3NpbmUgKyB4ICogcztcclxuICAgICAgICB2YXIgcjIwID0geCAqIHogKiBvbmVNaW51c0Nvc2luZSArIHkgKiBzO1xyXG4gICAgICAgIHZhciByMjEgPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lIC0geCAqIHM7XHJcbiAgICAgICAgdmFyIHIyMiA9IHp6ICsgKDEgLSB6eikgKiBjO1xyXG4gICAgICAgIHZhciBtMDAgPSBtWzBdO1xyXG4gICAgICAgIHZhciBtMDEgPSBtWzFdO1xyXG4gICAgICAgIHZhciBtMDIgPSBtWzJdO1xyXG4gICAgICAgIHZhciBtMDMgPSBtWzNdO1xyXG4gICAgICAgIHZhciBtMTAgPSBtWzRdO1xyXG4gICAgICAgIHZhciBtMTEgPSBtWzVdO1xyXG4gICAgICAgIHZhciBtMTIgPSBtWzZdO1xyXG4gICAgICAgIHZhciBtMTMgPSBtWzddO1xyXG4gICAgICAgIHZhciBtMjAgPSBtWzhdO1xyXG4gICAgICAgIHZhciBtMjEgPSBtWzldO1xyXG4gICAgICAgIHZhciBtMjIgPSBtWzEwXTtcclxuICAgICAgICB2YXIgbTIzID0gbVsxMV07XHJcbiAgICAgICAgZHN0WzBdID0gcjAwICogbTAwICsgcjAxICogbTEwICsgcjAyICogbTIwO1xyXG4gICAgICAgIGRzdFsxXSA9IHIwMCAqIG0wMSArIHIwMSAqIG0xMSArIHIwMiAqIG0yMTtcclxuICAgICAgICBkc3RbMl0gPSByMDAgKiBtMDIgKyByMDEgKiBtMTIgKyByMDIgKiBtMjI7XHJcbiAgICAgICAgZHN0WzNdID0gcjAwICogbTAzICsgcjAxICogbTEzICsgcjAyICogbTIzO1xyXG4gICAgICAgIGRzdFs0XSA9IHIxMCAqIG0wMCArIHIxMSAqIG0xMCArIHIxMiAqIG0yMDtcclxuICAgICAgICBkc3RbNV0gPSByMTAgKiBtMDEgKyByMTEgKiBtMTEgKyByMTIgKiBtMjE7XHJcbiAgICAgICAgZHN0WzZdID0gcjEwICogbTAyICsgcjExICogbTEyICsgcjEyICogbTIyO1xyXG4gICAgICAgIGRzdFs3XSA9IHIxMCAqIG0wMyArIHIxMSAqIG0xMyArIHIxMiAqIG0yMztcclxuICAgICAgICBkc3RbOF0gPSByMjAgKiBtMDAgKyByMjEgKiBtMTAgKyByMjIgKiBtMjA7XHJcbiAgICAgICAgZHN0WzldID0gcjIwICogbTAxICsgcjIxICogbTExICsgcjIyICogbTIxO1xyXG4gICAgICAgIGRzdFsxMF0gPSByMjAgKiBtMDIgKyByMjEgKiBtMTIgKyByMjIgKiBtMjI7XHJcbiAgICAgICAgZHN0WzExXSA9IHIyMCAqIG0wMyArIHIyMSAqIG0xMyArIHIyMiAqIG0yMztcclxuICAgICAgICBpZiAobSAhPT0gZHN0KSB7XHJcbiAgICAgICAgICAgIGRzdFsxMl0gPSBtWzEyXTtcclxuICAgICAgICAgICAgZHN0WzEzXSA9IG1bMTNdO1xyXG4gICAgICAgICAgICBkc3RbMTRdID0gbVsxNF07XHJcbiAgICAgICAgICAgIGRzdFsxNV0gPSBtWzE1XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8vIG1ha2UgYSBzY2FsaW5nIG1hdHJpeFxyXG4gICAgc3RhdGljIG5ld1NjYWxlcihzeCwgc3ksIHN6KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KFtzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGx5IGJ5IGEgc2NhbGluZyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSB7TWF0cml4NH0gbSBtYXRyaXggdG8gbXVsdGlwbHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCB4IHNjYWxlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN5IHkgc2NhbGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3ogeiBzY2FsZS5cclxuICAgICAqIEBwYXJhbSB7TWF0cml4NH0gW2RzdF0gb3B0aW9uYWwgbWF0cml4IHRvIHN0b3JlIHJlc3VsdFxyXG4gICAgICogQHJldHVybiB7TWF0cml4NH0gZHN0IG9yIGEgbmV3IG1hdHJpeCBpZiBub25lIHByb3ZpZGVkXHJcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOndlYmdsLTNkLW1hdGhcclxuICAgICAqL1xyXG4gICAgc2NhbGUoc3gsIHN5LCBzeikge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG9wdGltaXplZCB2ZXJzaW9uIG9mXHJcbiAgICAgICAgLy8gcmV0dXJuIG11bHRpcGx5KG0sIHNjYWxpbmcoc3gsIHN5LCBzeiksIGRzdCk7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgbGV0IGRzdCA9IG1hdHJpeC5kYXRhO1xyXG4gICAgICAgIGxldCBtID0gdGhpcy5kYXRhO1xyXG4gICAgICAgIGRzdFswXSA9IHN4ICogbVswICogNCArIDBdO1xyXG4gICAgICAgIGRzdFsxXSA9IHN4ICogbVswICogNCArIDFdO1xyXG4gICAgICAgIGRzdFsyXSA9IHN4ICogbVswICogNCArIDJdO1xyXG4gICAgICAgIGRzdFszXSA9IHN4ICogbVswICogNCArIDNdO1xyXG4gICAgICAgIGRzdFs0XSA9IHN5ICogbVsxICogNCArIDBdO1xyXG4gICAgICAgIGRzdFs1XSA9IHN5ICogbVsxICogNCArIDFdO1xyXG4gICAgICAgIGRzdFs2XSA9IHN5ICogbVsxICogNCArIDJdO1xyXG4gICAgICAgIGRzdFs3XSA9IHN5ICogbVsxICogNCArIDNdO1xyXG4gICAgICAgIGRzdFs4XSA9IHN6ICogbVsyICogNCArIDBdO1xyXG4gICAgICAgIGRzdFs5XSA9IHN6ICogbVsyICogNCArIDFdO1xyXG4gICAgICAgIGRzdFsxMF0gPSBzeiAqIG1bMiAqIDQgKyAyXTtcclxuICAgICAgICBkc3RbMTFdID0gc3ogKiBtWzIgKiA0ICsgM107XHJcbiAgICAgICAgaWYgKG0gIT09IGRzdCkge1xyXG4gICAgICAgICAgICBkc3RbMTJdID0gbVsxMl07XHJcbiAgICAgICAgICAgIGRzdFsxM10gPSBtWzEzXTtcclxuICAgICAgICAgICAgZHN0WzE0XSA9IG1bMTRdO1xyXG4gICAgICAgICAgICBkc3RbMTVdID0gbVsxNV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZXMgYSBtYXRyaXggZnJvbSB0cmFuc2xhdGlvbiwgcXVhdGVybmlvbiwgc2NhbGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IHRyYW5zbGF0aW9uIFt4LCB5LCB6XSB0cmFuc2xhdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gcXVhdGVybmlvbiBbeCwgeSwgeiwgel0gcXVhdGVybmlvbiByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gc2NhbGUgW3gsIHksIHpdIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0ge01hdHJpeDR9IFtkc3RdIG9wdGlvbmFsIG1hdHJpeCB0byBzdG9yZSByZXN1bHRcclxuICAgICAqIEByZXR1cm4ge01hdHJpeDR9IGRzdCBvciBhIG5ldyBtYXRyaXggaWYgbm9uZSBwcm92aWRlZFxyXG4gICAgICovXHJcbiAgICBuZXdDb21wb3NlKHRyYW5zbGF0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xyXG4gICAgICAgIGxldCBkc3QgPSBtYXRyaXguZGF0YTtcclxuICAgICAgICBjb25zdCB4ID0gcXVhdGVybmlvbi54O1xyXG4gICAgICAgIGNvbnN0IHkgPSBxdWF0ZXJuaW9uLnk7XHJcbiAgICAgICAgY29uc3QgeiA9IHF1YXRlcm5pb24uejtcclxuICAgICAgICBjb25zdCB3ID0gcXVhdGVybmlvbi53O1xyXG4gICAgICAgIGNvbnN0IHgyID0geCArIHg7XHJcbiAgICAgICAgY29uc3QgeTIgPSB5ICsgeTtcclxuICAgICAgICBjb25zdCB6MiA9IHogKyB6O1xyXG4gICAgICAgIGNvbnN0IHh4ID0geCAqIHgyO1xyXG4gICAgICAgIGNvbnN0IHh5ID0geCAqIHkyO1xyXG4gICAgICAgIGNvbnN0IHh6ID0geCAqIHoyO1xyXG4gICAgICAgIGNvbnN0IHl5ID0geSAqIHkyO1xyXG4gICAgICAgIGNvbnN0IHl6ID0geSAqIHoyO1xyXG4gICAgICAgIGNvbnN0IHp6ID0geiAqIHoyO1xyXG4gICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyO1xyXG4gICAgICAgIGNvbnN0IHd5ID0gdyAqIHkyO1xyXG4gICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyO1xyXG4gICAgICAgIGNvbnN0IHN4ID0gc2NhbGUueDtcclxuICAgICAgICBjb25zdCBzeSA9IHNjYWxlLnk7XHJcbiAgICAgICAgY29uc3Qgc3ogPSBzY2FsZS56O1xyXG4gICAgICAgIGRzdFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xyXG4gICAgICAgIGRzdFsxXSA9ICh4eSArIHd6KSAqIHN4O1xyXG4gICAgICAgIGRzdFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xyXG4gICAgICAgIGRzdFszXSA9IDA7XHJcbiAgICAgICAgZHN0WzRdID0gKHh5IC0gd3opICogc3k7XHJcbiAgICAgICAgZHN0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XHJcbiAgICAgICAgZHN0WzZdID0gKHl6ICsgd3gpICogc3k7XHJcbiAgICAgICAgZHN0WzddID0gMDtcclxuICAgICAgICBkc3RbOF0gPSAoeHogKyB3eSkgKiBzejtcclxuICAgICAgICBkc3RbOV0gPSAoeXogLSB3eCkgKiBzejtcclxuICAgICAgICBkc3RbMTBdID0gKDEgLSAoeHggKyB5eSkpICogc3o7XHJcbiAgICAgICAgZHN0WzExXSA9IDA7XHJcbiAgICAgICAgZHN0WzEyXSA9IHRyYW5zbGF0aW9uLng7XHJcbiAgICAgICAgZHN0WzEzXSA9IHRyYW5zbGF0aW9uLnk7XHJcbiAgICAgICAgZHN0WzE0XSA9IHRyYW5zbGF0aW9uLno7XHJcbiAgICAgICAgZHN0WzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIC8vIHF1YXRGcm9tUm90YXRpb25NYXRyaXgoKSB7XHJcbiAgICAvLyAgICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cclxuICAgIC8vICAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG4gICAgLy8gICAgIGNvbnN0IG0xMSA9IG1bMF07XHJcbiAgICAvLyAgICAgY29uc3QgbTEyID0gbVs0XTtcclxuICAgIC8vICAgICBjb25zdCBtMTMgPSBtWzhdO1xyXG4gICAgLy8gICAgIGNvbnN0IG0yMSA9IG1bMV07XHJcbiAgICAvLyAgICAgY29uc3QgbTIyID0gbVs1XTtcclxuICAgIC8vICAgICBjb25zdCBtMjMgPSBtWzldO1xyXG4gICAgLy8gICAgIGNvbnN0IG0zMSA9IG1bMl07XHJcbiAgICAvLyAgICAgY29uc3QgbTMyID0gbVs2XTtcclxuICAgIC8vICAgICBjb25zdCBtMzMgPSBtWzEwXTtcclxuICAgIC8vICAgICBjb25zdCB0cmFjZSA9IG0xMSArIG0yMiArIG0zMztcclxuICAgIC8vICAgICBpZiAodHJhY2UgPiAwKSB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IHMgPSAwLjUgLyBNYXRoLnNxcnQodHJhY2UgKyAxKTtcclxuICAgIC8vICAgICAgICAgZHN0WzNdID0gMC4yNSAvIHM7XHJcbiAgICAvLyAgICAgICAgIGRzdFswXSA9IChtMzIgLSBtMjMpICogcztcclxuICAgIC8vICAgICAgICAgZHN0WzFdID0gKG0xMyAtIG0zMSkgKiBzO1xyXG4gICAgLy8gICAgICAgICBkc3RbMl0gPSAobTIxIC0gbTEyKSAqIHM7XHJcbiAgICAvLyAgICAgfSBlbHNlIGlmIChtMTEgPiBtMjIgJiYgbTExID4gbTMzKSB7XHJcbiAgICAvLyAgICAgICAgIGNvbnN0IHMgPSAyICogTWF0aC5zcXJ0KDEgKyBtMTEgLSBtMjIgLSBtMzMpO1xyXG4gICAgLy8gICAgICAgICBkc3RbM10gPSAobTMyIC0gbTIzKSAvIHM7XHJcbiAgICAvLyAgICAgICAgIGRzdFswXSA9IDAuMjUgKiBzO1xyXG4gICAgLy8gICAgICAgICBkc3RbMV0gPSAobTEyICsgbTIxKSAvIHM7XHJcbiAgICAvLyAgICAgICAgIGRzdFsyXSA9IChtMTMgKyBtMzEpIC8gcztcclxuICAgIC8vICAgICB9IGVsc2UgaWYgKG0yMiA+IG0zMykge1xyXG4gICAgLy8gICAgICAgICBjb25zdCBzID0gMiAqIE1hdGguc3FydCgxICsgbTIyIC0gbTExIC0gbTMzKTtcclxuICAgIC8vICAgICAgICAgZHN0WzNdID0gKG0xMyAtIG0zMSkgLyBzO1xyXG4gICAgLy8gICAgICAgICBkc3RbMF0gPSAobTEyICsgbTIxKSAvIHM7XHJcbiAgICAvLyAgICAgICAgIGRzdFsxXSA9IDAuMjUgKiBzO1xyXG4gICAgLy8gICAgICAgICBkc3RbMl0gPSAobTIzICsgbTMyKSAvIHM7XHJcbiAgICAvLyAgICAgfSBlbHNlIHtcclxuICAgIC8vICAgICAgICAgY29uc3QgcyA9IDIgKiBNYXRoLnNxcnQoMSArIG0zMyAtIG0xMSAtIG0yMik7XHJcbiAgICAvLyAgICAgICAgIGRzdFszXSA9IChtMjEgLSBtMTIpIC8gcztcclxuICAgIC8vICAgICAgICAgZHN0WzBdID0gKG0xMyArIG0zMSkgLyBzO1xyXG4gICAgLy8gICAgICAgICBkc3RbMV0gPSAobTIzICsgbTMyKSAvIHM7XHJcbiAgICAvLyAgICAgICAgIGRzdFsyXSA9IDAuMjUgKiBzO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vIH1cclxuICAgIC8vIGRlY29tcG9zZShtYXQsIHRyYW5zbGF0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSkge1xyXG4gICAgLy8gICAgIGxldCBzeCA9IG00Lmxlbmd0aChtYXQuc2xpY2UoMCwgMykpO1xyXG4gICAgLy8gICAgIGNvbnN0IHN5ID0gbTQubGVuZ3RoKG1hdC5zbGljZSg0LCA3KSk7XHJcbiAgICAvLyAgICAgY29uc3Qgc3ogPSBtNC5sZW5ndGgobWF0LnNsaWNlKDgsIDExKSk7XHJcbiAgICAvLyAgICAgLy8gaWYgZGV0ZXJtaW5hdGUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxyXG4gICAgLy8gICAgIGNvbnN0IGRldCA9IGRldGVybWluYXRlKG1hdCk7XHJcbiAgICAvLyAgICAgaWYgKGRldCA8IDApIHtcclxuICAgIC8vICAgICAgICAgc3ggPSAtc3g7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHRyYW5zbGF0aW9uWzBdID0gbWF0WzEyXTtcclxuICAgIC8vICAgICB0cmFuc2xhdGlvblsxXSA9IG1hdFsxM107XHJcbiAgICAvLyAgICAgdHJhbnNsYXRpb25bMl0gPSBtYXRbMTRdO1xyXG4gICAgLy8gICAgIC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XHJcbiAgICAvLyAgICAgY29uc3QgbWF0cml4ID0gbTQuY29weShtYXQpO1xyXG4gICAgLy8gICAgIGNvbnN0IGludlNYID0gMSAvIHN4O1xyXG4gICAgLy8gICAgIGNvbnN0IGludlNZID0gMSAvIHN5O1xyXG4gICAgLy8gICAgIGNvbnN0IGludlNaID0gMSAvIHN6O1xyXG4gICAgLy8gICAgIG1hdHJpeFswXSAqPSBpbnZTWDtcclxuICAgIC8vICAgICBtYXRyaXhbMV0gKj0gaW52U1g7XHJcbiAgICAvLyAgICAgbWF0cml4WzJdICo9IGludlNYO1xyXG4gICAgLy8gICAgIG1hdHJpeFs0XSAqPSBpbnZTWTtcclxuICAgIC8vICAgICBtYXRyaXhbNV0gKj0gaW52U1k7XHJcbiAgICAvLyAgICAgbWF0cml4WzZdICo9IGludlNZO1xyXG4gICAgLy8gICAgIG1hdHJpeFs4XSAqPSBpbnZTWjtcclxuICAgIC8vICAgICBtYXRyaXhbOV0gKj0gaW52U1o7XHJcbiAgICAvLyAgICAgbWF0cml4WzEwXSAqPSBpbnZTWjtcclxuICAgIC8vICAgICBxdWF0RnJvbVJvdGF0aW9uTWF0cml4KG1hdHJpeCwgcXVhdGVybmlvbik7XHJcbiAgICAvLyAgICAgc2NhbGVbMF0gPSBzeDtcclxuICAgIC8vICAgICBzY2FsZVsxXSA9IHN5O1xyXG4gICAgLy8gICAgIHNjYWxlWzJdID0gc3o7XHJcbiAgICAvLyB9XHJcbiAgICBkZXRlcm1pbmF0ZSgpIHtcclxuICAgICAgICBsZXQgbSA9IHRoaXMuZGF0YTtcclxuICAgICAgICB2YXIgbTAwID0gbVswICogNCArIDBdO1xyXG4gICAgICAgIHZhciBtMDEgPSBtWzAgKiA0ICsgMV07XHJcbiAgICAgICAgdmFyIG0wMiA9IG1bMCAqIDQgKyAyXTtcclxuICAgICAgICB2YXIgbTAzID0gbVswICogNCArIDNdO1xyXG4gICAgICAgIHZhciBtMTAgPSBtWzEgKiA0ICsgMF07XHJcbiAgICAgICAgdmFyIG0xMSA9IG1bMSAqIDQgKyAxXTtcclxuICAgICAgICB2YXIgbTEyID0gbVsxICogNCArIDJdO1xyXG4gICAgICAgIHZhciBtMTMgPSBtWzEgKiA0ICsgM107XHJcbiAgICAgICAgdmFyIG0yMCA9IG1bMiAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgbTIxID0gbVsyICogNCArIDFdO1xyXG4gICAgICAgIHZhciBtMjIgPSBtWzIgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIG0yMyA9IG1bMiAqIDQgKyAzXTtcclxuICAgICAgICB2YXIgbTMwID0gbVszICogNCArIDBdO1xyXG4gICAgICAgIHZhciBtMzEgPSBtWzMgKiA0ICsgMV07XHJcbiAgICAgICAgdmFyIG0zMiA9IG1bMyAqIDQgKyAyXTtcclxuICAgICAgICB2YXIgbTMzID0gbVszICogNCArIDNdO1xyXG4gICAgICAgIHZhciB0bXBfMCA9IG0yMiAqIG0zMztcclxuICAgICAgICB2YXIgdG1wXzEgPSBtMzIgKiBtMjM7XHJcbiAgICAgICAgdmFyIHRtcF8yID0gbTEyICogbTMzO1xyXG4gICAgICAgIHZhciB0bXBfMyA9IG0zMiAqIG0xMztcclxuICAgICAgICB2YXIgdG1wXzQgPSBtMTIgKiBtMjM7XHJcbiAgICAgICAgdmFyIHRtcF81ID0gbTIyICogbTEzO1xyXG4gICAgICAgIHZhciB0bXBfNiA9IG0wMiAqIG0zMztcclxuICAgICAgICB2YXIgdG1wXzcgPSBtMzIgKiBtMDM7XHJcbiAgICAgICAgdmFyIHRtcF84ID0gbTAyICogbTIzO1xyXG4gICAgICAgIHZhciB0bXBfOSA9IG0yMiAqIG0wMztcclxuICAgICAgICB2YXIgdG1wXzEwID0gbTAyICogbTEzO1xyXG4gICAgICAgIHZhciB0bXBfMTEgPSBtMTIgKiBtMDM7XHJcbiAgICAgICAgdmFyIHQwID0gdG1wXzAgKiBtMTEgKyB0bXBfMyAqIG0yMSArIHRtcF80ICogbTMxIC0gKHRtcF8xICogbTExICsgdG1wXzIgKiBtMjEgKyB0bXBfNSAqIG0zMSk7XHJcbiAgICAgICAgdmFyIHQxID0gdG1wXzEgKiBtMDEgKyB0bXBfNiAqIG0yMSArIHRtcF85ICogbTMxIC0gKHRtcF8wICogbTAxICsgdG1wXzcgKiBtMjEgKyB0bXBfOCAqIG0zMSk7XHJcbiAgICAgICAgdmFyIHQyID0gdG1wXzIgKiBtMDEgKyB0bXBfNyAqIG0xMSArIHRtcF8xMCAqIG0zMSAtICh0bXBfMyAqIG0wMSArIHRtcF82ICogbTExICsgdG1wXzExICogbTMxKTtcclxuICAgICAgICB2YXIgdDMgPSB0bXBfNSAqIG0wMSArIHRtcF84ICogbTExICsgdG1wXzExICogbTIxIC0gKHRtcF80ICogbTAxICsgdG1wXzkgKiBtMTEgKyB0bXBfMTAgKiBtMjEpO1xyXG4gICAgICAgIHJldHVybiAxLjAgLyAobTAwICogdDAgKyBtMTAgKiB0MSArIG0yMCAqIHQyICsgbTMwICogdDMpO1xyXG4gICAgfVxyXG4gICAgaW52ZXJzZSgpIHtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcclxuICAgICAgICBsZXQgZHN0ID0gbWF0cml4LmRhdGE7XHJcbiAgICAgICAgbGV0IG0gPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgdmFyIG0wMCA9IG1bMCAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgbTAxID0gbVswICogNCArIDFdO1xyXG4gICAgICAgIHZhciBtMDIgPSBtWzAgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIG0wMyA9IG1bMCAqIDQgKyAzXTtcclxuICAgICAgICB2YXIgbTEwID0gbVsxICogNCArIDBdO1xyXG4gICAgICAgIHZhciBtMTEgPSBtWzEgKiA0ICsgMV07XHJcbiAgICAgICAgdmFyIG0xMiA9IG1bMSAqIDQgKyAyXTtcclxuICAgICAgICB2YXIgbTEzID0gbVsxICogNCArIDNdO1xyXG4gICAgICAgIHZhciBtMjAgPSBtWzIgKiA0ICsgMF07XHJcbiAgICAgICAgdmFyIG0yMSA9IG1bMiAqIDQgKyAxXTtcclxuICAgICAgICB2YXIgbTIyID0gbVsyICogNCArIDJdO1xyXG4gICAgICAgIHZhciBtMjMgPSBtWzIgKiA0ICsgM107XHJcbiAgICAgICAgdmFyIG0zMCA9IG1bMyAqIDQgKyAwXTtcclxuICAgICAgICB2YXIgbTMxID0gbVszICogNCArIDFdO1xyXG4gICAgICAgIHZhciBtMzIgPSBtWzMgKiA0ICsgMl07XHJcbiAgICAgICAgdmFyIG0zMyA9IG1bMyAqIDQgKyAzXTtcclxuICAgICAgICB2YXIgdG1wXzAgPSBtMjIgKiBtMzM7XHJcbiAgICAgICAgdmFyIHRtcF8xID0gbTMyICogbTIzO1xyXG4gICAgICAgIHZhciB0bXBfMiA9IG0xMiAqIG0zMztcclxuICAgICAgICB2YXIgdG1wXzMgPSBtMzIgKiBtMTM7XHJcbiAgICAgICAgdmFyIHRtcF80ID0gbTEyICogbTIzO1xyXG4gICAgICAgIHZhciB0bXBfNSA9IG0yMiAqIG0xMztcclxuICAgICAgICB2YXIgdG1wXzYgPSBtMDIgKiBtMzM7XHJcbiAgICAgICAgdmFyIHRtcF83ID0gbTMyICogbTAzO1xyXG4gICAgICAgIHZhciB0bXBfOCA9IG0wMiAqIG0yMztcclxuICAgICAgICB2YXIgdG1wXzkgPSBtMjIgKiBtMDM7XHJcbiAgICAgICAgdmFyIHRtcF8xMCA9IG0wMiAqIG0xMztcclxuICAgICAgICB2YXIgdG1wXzExID0gbTEyICogbTAzO1xyXG4gICAgICAgIHZhciB0bXBfMTIgPSBtMjAgKiBtMzE7XHJcbiAgICAgICAgdmFyIHRtcF8xMyA9IG0zMCAqIG0yMTtcclxuICAgICAgICB2YXIgdG1wXzE0ID0gbTEwICogbTMxO1xyXG4gICAgICAgIHZhciB0bXBfMTUgPSBtMzAgKiBtMTE7XHJcbiAgICAgICAgdmFyIHRtcF8xNiA9IG0xMCAqIG0yMTtcclxuICAgICAgICB2YXIgdG1wXzE3ID0gbTIwICogbTExO1xyXG4gICAgICAgIHZhciB0bXBfMTggPSBtMDAgKiBtMzE7XHJcbiAgICAgICAgdmFyIHRtcF8xOSA9IG0zMCAqIG0wMTtcclxuICAgICAgICB2YXIgdG1wXzIwID0gbTAwICogbTIxO1xyXG4gICAgICAgIHZhciB0bXBfMjEgPSBtMjAgKiBtMDE7XHJcbiAgICAgICAgdmFyIHRtcF8yMiA9IG0wMCAqIG0xMTtcclxuICAgICAgICB2YXIgdG1wXzIzID0gbTEwICogbTAxO1xyXG4gICAgICAgIHZhciB0MCA9IHRtcF8wICogbTExICsgdG1wXzMgKiBtMjEgKyB0bXBfNCAqIG0zMSAtICh0bXBfMSAqIG0xMSArIHRtcF8yICogbTIxICsgdG1wXzUgKiBtMzEpO1xyXG4gICAgICAgIHZhciB0MSA9IHRtcF8xICogbTAxICsgdG1wXzYgKiBtMjEgKyB0bXBfOSAqIG0zMSAtICh0bXBfMCAqIG0wMSArIHRtcF83ICogbTIxICsgdG1wXzggKiBtMzEpO1xyXG4gICAgICAgIHZhciB0MiA9IHRtcF8yICogbTAxICsgdG1wXzcgKiBtMTEgKyB0bXBfMTAgKiBtMzEgLSAodG1wXzMgKiBtMDEgKyB0bXBfNiAqIG0xMSArIHRtcF8xMSAqIG0zMSk7XHJcbiAgICAgICAgdmFyIHQzID0gdG1wXzUgKiBtMDEgKyB0bXBfOCAqIG0xMSArIHRtcF8xMSAqIG0yMSAtICh0bXBfNCAqIG0wMSArIHRtcF85ICogbTExICsgdG1wXzEwICogbTIxKTtcclxuICAgICAgICB2YXIgZCA9IDEuMCAvIChtMDAgKiB0MCArIG0xMCAqIHQxICsgbTIwICogdDIgKyBtMzAgKiB0Myk7XHJcbiAgICAgICAgZHN0WzBdID0gZCAqIHQwO1xyXG4gICAgICAgIGRzdFsxXSA9IGQgKiB0MTtcclxuICAgICAgICBkc3RbMl0gPSBkICogdDI7XHJcbiAgICAgICAgZHN0WzNdID0gZCAqIHQzO1xyXG4gICAgICAgIGRzdFs0XSA9XHJcbiAgICAgICAgICAgIGQgKlxyXG4gICAgICAgICAgICAgICAgKHRtcF8xICogbTEwICsgdG1wXzIgKiBtMjAgKyB0bXBfNSAqIG0zMCAtICh0bXBfMCAqIG0xMCArIHRtcF8zICogbTIwICsgdG1wXzQgKiBtMzApKTtcclxuICAgICAgICBkc3RbNV0gPVxyXG4gICAgICAgICAgICBkICpcclxuICAgICAgICAgICAgICAgICh0bXBfMCAqIG0wMCArIHRtcF83ICogbTIwICsgdG1wXzggKiBtMzAgLSAodG1wXzEgKiBtMDAgKyB0bXBfNiAqIG0yMCArIHRtcF85ICogbTMwKSk7XHJcbiAgICAgICAgZHN0WzZdID1cclxuICAgICAgICAgICAgZCAqXHJcbiAgICAgICAgICAgICAgICAodG1wXzMgKiBtMDAgKyB0bXBfNiAqIG0xMCArIHRtcF8xMSAqIG0zMCAtICh0bXBfMiAqIG0wMCArIHRtcF83ICogbTEwICsgdG1wXzEwICogbTMwKSk7XHJcbiAgICAgICAgZHN0WzddID1cclxuICAgICAgICAgICAgZCAqXHJcbiAgICAgICAgICAgICAgICAodG1wXzQgKiBtMDAgKyB0bXBfOSAqIG0xMCArIHRtcF8xMCAqIG0yMCAtICh0bXBfNSAqIG0wMCArIHRtcF84ICogbTEwICsgdG1wXzExICogbTIwKSk7XHJcbiAgICAgICAgZHN0WzhdID1cclxuICAgICAgICAgICAgZCAqXHJcbiAgICAgICAgICAgICAgICAodG1wXzEyICogbTEzICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMTUgKiBtMjMgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcF8xNiAqIG0zMyAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHRtcF8xMyAqIG0xMyArIHRtcF8xNCAqIG0yMyArIHRtcF8xNyAqIG0zMykpO1xyXG4gICAgICAgIGRzdFs5XSA9XHJcbiAgICAgICAgICAgIGQgKlxyXG4gICAgICAgICAgICAgICAgKHRtcF8xMyAqIG0wMyArXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wXzE4ICogbTIzICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMjEgKiBtMzMgLVxyXG4gICAgICAgICAgICAgICAgICAgICh0bXBfMTIgKiBtMDMgKyB0bXBfMTkgKiBtMjMgKyB0bXBfMjAgKiBtMzMpKTtcclxuICAgICAgICBkc3RbMTBdID1cclxuICAgICAgICAgICAgZCAqXHJcbiAgICAgICAgICAgICAgICAodG1wXzE0ICogbTAzICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMTkgKiBtMTMgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcF8yMiAqIG0zMyAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHRtcF8xNSAqIG0wMyArIHRtcF8xOCAqIG0xMyArIHRtcF8yMyAqIG0zMykpO1xyXG4gICAgICAgIGRzdFsxMV0gPVxyXG4gICAgICAgICAgICBkICpcclxuICAgICAgICAgICAgICAgICh0bXBfMTcgKiBtMDMgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcF8yMCAqIG0xMyArXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wXzIzICogbTIzIC1cclxuICAgICAgICAgICAgICAgICAgICAodG1wXzE2ICogbTAzICsgdG1wXzIxICogbTEzICsgdG1wXzIyICogbTIzKSk7XHJcbiAgICAgICAgZHN0WzEyXSA9XHJcbiAgICAgICAgICAgIGQgKlxyXG4gICAgICAgICAgICAgICAgKHRtcF8xNCAqIG0yMiArXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wXzE3ICogbTMyICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMTMgKiBtMTIgLVxyXG4gICAgICAgICAgICAgICAgICAgICh0bXBfMTYgKiBtMzIgKyB0bXBfMTIgKiBtMTIgKyB0bXBfMTUgKiBtMjIpKTtcclxuICAgICAgICBkc3RbMTNdID1cclxuICAgICAgICAgICAgZCAqXHJcbiAgICAgICAgICAgICAgICAodG1wXzIwICogbTMyICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMTIgKiBtMDIgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcF8xOSAqIG0yMiAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHRtcF8xOCAqIG0yMiArIHRtcF8yMSAqIG0zMiArIHRtcF8xMyAqIG0wMikpO1xyXG4gICAgICAgIGRzdFsxNF0gPVxyXG4gICAgICAgICAgICBkICpcclxuICAgICAgICAgICAgICAgICh0bXBfMTggKiBtMTIgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRtcF8yMyAqIG0zMiArXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wXzE1ICogbTAyIC1cclxuICAgICAgICAgICAgICAgICAgICAodG1wXzIyICogbTMyICsgdG1wXzE0ICogbTAyICsgdG1wXzE5ICogbTEyKSk7XHJcbiAgICAgICAgZHN0WzE1XSA9XHJcbiAgICAgICAgICAgIGQgKlxyXG4gICAgICAgICAgICAgICAgKHRtcF8yMiAqIG0yMiArXHJcbiAgICAgICAgICAgICAgICAgICAgdG1wXzE2ICogbTAyICtcclxuICAgICAgICAgICAgICAgICAgICB0bXBfMjEgKiBtMTIgLVxyXG4gICAgICAgICAgICAgICAgICAgICh0bXBfMjAgKiBtMTIgKyB0bXBfMjMgKiBtMjIgKyB0bXBfMTcgKiBtMDIpKTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgbXVsdGlwbHlWZWN0b3Iodikge1xyXG4gICAgICAgIGxldCBkYXRhID0gbmV3IEFycmF5KDMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgKytpKSB7XHJcbiAgICAgICAgICAgIGRhdGFbaV0gPSAwLjA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhW2ldICs9IHYuaXRlbShqKSAqIHRoaXMuZ2V0KGosIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyhkYXRhWzBdLCBkYXRhWzFdLCBkYXRhWzJdKTtcclxuICAgIH1cclxuICAgIG11bHRpcGx5VmVjdG9ycyhvdGhlcikge1xyXG4gICAgICAgIC8vIGR1bWIgd2F5XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmVjID0gb3RoZXIuZ2V0VmVjdG9yKGkpO1xyXG4gICAgICAgICAgICB2ZWMgPSB0aGlzLm11bHRpcGx5VmVjdG9yKHZlYyk7XHJcbiAgICAgICAgICAgIG90aGVyLnNldFZlY3RvcihpLCB2ZWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICAgICAgLy8gc21hcnQgd2F5XHJcbiAgICAgICAgLy8gbGV0IG1hdHJpeCA9IG5ldyBWZWN0b3IzQXJyYXkob3RoZXIuY291bnQoKSk7XHJcbiAgICAgICAgLy8gLy8gZm9yIGV2ZXJ5IHJvd1xyXG4gICAgICAgIC8vIGZvciAodmFyIHIgPSAwOyByIDwgb3RoZXIuY291bnQoKTsgcisrKSB7XHJcbiAgICAgICAgLy8gICAgIC8vIGZvciBldmVyeSBpdGVtIGluIHJvd1xyXG4gICAgICAgIC8vICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDM7ICsrYykge1xyXG4gICAgICAgIC8vICAgICAgICAgbGV0IGl0ZW0gPSAwLjA7XHJcbiAgICAgICAgLy8gICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7ICsraikge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGl0ZW0gKz0gb3RoZXIuZ2V0KHIsIGMpICogdGhpcy5nZXQoaiwgYyk7XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICBtYXRyaXguc2V0KHIsIGMsIGl0ZW0pO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIG90aGVyLmRhdGEgPSBtYXRyaXguZGF0YTtcclxuICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIFV0aWwge1xyXG4gICAgc3RhdGljIHJhbmdlKG4pIHtcclxuICAgICAgICBsZXQgYXJyYXkgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBhcnJheS5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gYXV0aG9yOiBcdEpvcyBGZWVuc3RyYVxyXG4vLyBpbnNwaXJhdGlvbiBmcm9tIFRocmVlLmpzXHJcbi8vIG5vdGU6IFx0cmVjeWNsZSB0aGUgY2xhc3MgYXMgbXVjaCBhcyBwb3NzYmxlLCBidWlsZGluZyBhIG5ldyBjbGFzcyBpcyBleHBlbnNpdmUsXHJcbi8vIFx0XHRcdGVzcGVjaWFsbHkgaW4gamF2YXNjcmlwdFxyXG4vLyB0b2RvOiBcdEJJSiBOQURFUiBJTlpJRU46IGRvbnQgZ28gdGhlIGNvcHkgcm91dGUuIHJld3JpdGUgdGhpcyBpbiBhIG1vcmUgZnVuY3Rpb25hbCB3YXkgY3JlYXRpbmcgbmV3IGNsYXNzZXMgaXMgZXhwZW5zaXZlLCBidXQgd2UgcmVhbGx5IG5lZWQgaW1tdXRhYmxlIHZlY3RvcnMuXHJcbi8vIFx0XHRcdHRoZXNlIHR5cGVzIG9mIGNvbnNpc3RlbnQgdmVjdG9ycyBhcmUgb25seSB1c2VmdWwgaW4gbmljaGUgY2FzZXMsIGFuZCBjb21wbGl0YXRlIGEgbG90IG9mIGNvbW1vbiBjYXNlcy5cclxuaW1wb3J0IHsgQ29uc3QgfSBmcm9tIFwiLi9jb25zdFwiO1xyXG5pbXBvcnQgeyBHZW9uTWF0aCB9IGZyb20gXCIuL21hdGhcIjtcclxuaW1wb3J0IHsgTWF0cml4NCB9IGZyb20gXCIuL21hdHJpeFwiO1xyXG5pbXBvcnQgeyBVdGlsIH0gZnJvbSBcIi4vdXRpbFwiO1xyXG5leHBvcnQgY2xhc3MgVmVjdG9yMyB7XHJcbiAgICAvLyAjcmVnaW9uIGNvbnN0cnVjdG9yc1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgeikge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyh4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHgsIHksIHopO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNhbGN1bGF0ZVdoZWVsT3JkZXIodmVjdG9ycywgaWhhdCwgamhhdCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwid2hlZWwgb3JkZXJcIik7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJoYXRzXCIsIGloYXQsIGpoYXQpXHJcbiAgICAgICAgbGV0IGFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIHZlY3RvcnMuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICBhbmdsZXMucHVzaChuZXcgVmVjdG9yMih2LmRvdChpaGF0KSwgdi5kb3QoamhhdCkpLmFuZ2xlKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYW5nbGVzXCIsIGFuZ2xlcyk7XHJcbiAgICAgICAgbGV0IGlkcyA9IFV0aWwucmFuZ2UodmVjdG9ycy5sZW5ndGgpO1xyXG4gICAgICAgIGlkcy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmdsZXNbYV0gLSBhbmdsZXNbYl07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGlkcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTGVycCh2MSwgdjIsIGFscGhhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHYxLnggKyAodjIueCAtIHYxLngpICogYWxwaGEsIHYxLnkgKyAodjIueSAtIHYxLnkpICogYWxwaGEsIHYxLnogKyAodjIueiAtIHYxLnopICogYWxwaGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21BcnJheShhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKGFbMF0sIGFbMV0sIGFbMl0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21SYW5kb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21TcGhlcmUocmFkaXVzLCB0aGV0YSwgcGhpKSB7XHJcbiAgICAgICAgY29uc3Qgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4ocGhpKSAqIHJhZGl1cztcclxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbih0aGV0YSksIE1hdGguY29zKHBoaSkgKiByYWRpdXMsIHNpblBoaVJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUN5bGluZGVyKHJhZGl1cywgdGhldGEsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKSwgaGVpZ2h0LCByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21MZXJwV2VpZ2h0cyhwMSwgcDIsIHRQMSwgdFAyLCB0KSB7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHQgLSB0UDEpIDwgMC4wMDAwMSlcclxuICAgICAgICAgICAgcmV0dXJuIHAxO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyh0IC0gdFAyKSA8IDAuMDAwMDEpXHJcbiAgICAgICAgICAgIHJldHVybiBwMjtcclxuICAgICAgICBpZiAoTWF0aC5hYnModFAxIC0gdFAyKSA8IDAuMDAwMDEpXHJcbiAgICAgICAgICAgIHJldHVybiBwMTtcclxuICAgICAgICBsZXQgbXUgPSAodCAtIHRQMSkgLyAodFAyIC0gdFAxKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMocDEueCArIG11ICogKHAyLnggLSBwMS54KSwgcDEueSArIG11ICogKHAyLnkgLSBwMS55KSwgcDEueiArIG11ICogKHAyLnogLSBwMS56KSk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvLyAjcmVnaW9uIGRlZmF1bHRzXHJcbiAgICBzdGF0aWMgemVybygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdW5pdFgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKDEsIDAsIDApO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVuaXRZKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMygwLCAxLCAwKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1bml0WigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMCwgMCwgMSk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvLyAjcmVnaW9uIGJhc2ljc1xyXG4gICAgdG9BcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbdGhpcy54LCB0aGlzLnksIHRoaXMuel0pO1xyXG4gICAgfVxyXG4gICAgc2V0KHgsIHksIHopIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy56ID0gejtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGVxdWFscyh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHYueCA9PT0gdGhpcy54ICYmIHYueSA9PT0gdGhpcy55ICYmIHYueiA9PT0gdGhpcy56O1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBWZWN0b3IzKCR7dGhpcy54fSwgJHt0aGlzLnl9LCAke3RoaXMuen0pYDtcclxuICAgIH1cclxuICAgIHRvVmVjdG9yMigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xyXG4gICAgfVxyXG4gICAgY29weSh2KSB7XHJcbiAgICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICAgIHRoaXMueSA9IHYueTtcclxuICAgICAgICB0aGlzLnogPSB2Lno7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB0bzJEKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvLyAjcmVnaW9uIG1hdGggbGlrZSB2ZWN0b3IyXHJcbiAgICBsYXJnZXN0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMueCwgdGhpcy55LCB0aGlzLnopO1xyXG4gICAgfVxyXG4gICAgYWRkZWQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSwgdGhpcy56ICsgdi56KTtcclxuICAgIH1cclxuICAgIGFkZCh2KSB7XHJcbiAgICAgICAgdGhpcy54ICs9IHYueDtcclxuICAgICAgICB0aGlzLnkgKz0gdi55O1xyXG4gICAgICAgIHRoaXMueiArPSB2Lno7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzdWJiZWQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSwgdGhpcy56IC0gdi56KTtcclxuICAgIH1cclxuICAgIHN1Yih2KSB7XHJcbiAgICAgICAgKHRoaXMueCAtPSB2LngpLCAodGhpcy55IC09IHYueSksICh0aGlzLnogLT0gdi56KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGl0ZW0oaSkge1xyXG4gICAgICAgIHN3aXRjaCAoaSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy56O1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IFwibm9wZVwiO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNjYWxlZCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCAqIHYsIHRoaXMueSAqIHYsIHRoaXMueiAqIHYpO1xyXG4gICAgfVxyXG4gICAgc2NhbGUodikge1xyXG4gICAgICAgIHRoaXMueCAqPSB2O1xyXG4gICAgICAgIHRoaXMueSAqPSB2O1xyXG4gICAgICAgIHRoaXMueiAqPSB2O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbXVsKHYpIHtcclxuICAgICAgICB0aGlzLnggKj0gdi54O1xyXG4gICAgICAgIHRoaXMueSAqPSB2Lnk7XHJcbiAgICAgICAgdGhpcy56ICo9IHYuejtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG11bHRpcGxpZWQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnggKiB2LngsIHRoaXMueSAqIHYueSwgdGhpcy56ICogdi56KTtcclxuICAgIH1cclxuICAgIGRpdlZlY3Rvcih2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueCAvIHYueCwgdGhpcy55IC8gdi55LCB0aGlzLnogLyB2LnopO1xyXG4gICAgfVxyXG4gICAgZGl2aWRlZCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnggLyB2YWx1ZSwgdGhpcy55IC8gdmFsdWUsIHRoaXMueiAvIHZhbHVlKTtcclxuICAgIH1cclxuICAgIGRpdih2YWx1ZSkge1xyXG4gICAgICAgICh0aGlzLnggLz0gdmFsdWUpLCAodGhpcy55IC89IHZhbHVlKSwgKHRoaXMueiAvPSB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtaW5pbXVtZWQob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoTWF0aC5taW4odGhpcy54LCBvdGhlci54KSwgTWF0aC5taW4odGhpcy55LCBvdGhlci55KSwgTWF0aC5taW4odGhpcy56LCBvdGhlci56KSk7XHJcbiAgICB9XHJcbiAgICBtYXhpbXVtZWQob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoTWF0aC5tYXgodGhpcy54LCBvdGhlci54KSwgTWF0aC5tYXgodGhpcy55LCBvdGhlci55KSwgTWF0aC5tYXgodGhpcy56LCBvdGhlci56KSk7XHJcbiAgICB9XHJcbiAgICBjbGFtcGVkKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKE1hdGgubWF4KG1pbi54LCBNYXRoLm1pbihtYXgueCwgdGhpcy54KSksIE1hdGgubWF4KG1pbi55LCBNYXRoLm1pbihtYXgueSwgdGhpcy55KSksIE1hdGgubWF4KG1pbi56LCBNYXRoLm1pbihtYXgueiwgdGhpcy56KSkpO1xyXG4gICAgfVxyXG4gICAgY2xhbXBTY2FsYXJlZChtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyhHZW9uTWF0aC5jbGFtcCh0aGlzLngsIG1pbiwgbWF4KSwgR2Vvbk1hdGguY2xhbXAodGhpcy55LCBtaW4sIG1heCksIEdlb25NYXRoLmNsYW1wKHRoaXMueiwgbWluLCBtYXgpKTtcclxuICAgIH1cclxuICAgIGNsYW1wTGVuZ3RoZWQobWluLCBtYXgpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdihsZW5ndGggfHwgMSkuc2NhbGUoTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIGxlbmd0aCkpKTtcclxuICAgIH1cclxuICAgIGZsb29yZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKE1hdGguZmxvb3IodGhpcy54KSwgTWF0aC5mbG9vcih0aGlzLnkpLCBNYXRoLmZsb29yKHRoaXMueikpO1xyXG4gICAgfVxyXG4gICAgY2VpbGVkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyhNYXRoLmNlaWwodGhpcy54KSwgTWF0aC5jZWlsKHRoaXMueSksIE1hdGguY2VpbCh0aGlzLnopKTtcclxuICAgIH1cclxuICAgIHJvdW5kZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKE1hdGgucm91bmQodGhpcy54KSwgTWF0aC5yb3VuZCh0aGlzLnkpLCBNYXRoLnJvdW5kKHRoaXMueikpO1xyXG4gICAgfVxyXG4gICAgcm91bmRlZFRvWmVybygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54IDwgMCA/IE1hdGguY2VpbCh0aGlzLngpIDogTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPCAwID8gTWF0aC5jZWlsKHRoaXMueSkgOiBNYXRoLmZsb29yKHRoaXMueSksIHRoaXMueiA8IDAgPyBNYXRoLmNlaWwodGhpcy56KSA6IE1hdGguZmxvb3IodGhpcy56KSk7XHJcbiAgICB9XHJcbiAgICBuZWdhdGUoKSB7XHJcbiAgICAgICAgdGhpcy54ID0gLXRoaXMueDtcclxuICAgICAgICB0aGlzLnkgPSAtdGhpcy55O1xyXG4gICAgICAgIHRoaXMueiA9IC10aGlzLno7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBuZWdhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMygtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56KTtcclxuICAgIH1cclxuICAgIGFuZ2xlKG90aGVyLCBub3JtYWwpIHtcclxuICAgICAgICBsZXQgdGhpc1Byb2plY3RlZCA9IHRoaXMuc3ViYmVkKG5vcm1hbC5zY2FsZWQodGhpcy5kb3Qobm9ybWFsKSkpO1xyXG4gICAgICAgIGxldCBvdGhlclByb2plY3RlZCA9IG90aGVyLnN1YmJlZChub3JtYWwuc2NhbGVkKG90aGVyLmRvdChub3JtYWwpKSk7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpc1Byb2plY3RlZCk7XHJcbiAgICAgICAgY29uc29sZS5sb2cob3RoZXJQcm9qZWN0ZWQpO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZG90KHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xyXG4gICAgfVxyXG4gICAgY3Jvc3Mob3RoZXIpIHtcclxuICAgICAgICBjb25zdCBheCA9IHRoaXMueCwgYXkgPSB0aGlzLnksIGF6ID0gdGhpcy56O1xyXG4gICAgICAgIGNvbnN0IGJ4ID0gb3RoZXIueCwgYnkgPSBvdGhlci55LCBieiA9IG90aGVyLno7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKGF5ICogYnogLSBheiAqIGJ5LCBheiAqIGJ4IC0gYXggKiBieiwgYXggKiBieSAtIGF5ICogYngpO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVuZ3RoU3F1YXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xyXG4gICAgfVxyXG4gICAgbGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5nZXRMZW5ndGhTcXVhcmVkKCkpO1xyXG4gICAgfVxyXG4gICAgbWFuaGF0KCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueik7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KHRoaXMubGVuZ3RoKCkgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZWQodGhpcy5sZW5ndGgoKSB8fCAxKTtcclxuICAgIH1cclxuICAgIGlzTm9ybWFsKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmxlbmd0aCgpIC0gMSkgPCBDb25zdC5UT0xFUkFOQ0U7XHJcbiAgICB9XHJcbiAgICBkaXNUbyh2KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc1RvU3F1YXJlZCh2KSk7XHJcbiAgICB9XHJcbiAgICBkaXNUb1NxdWFyZWQodikge1xyXG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueSwgZHogPSB0aGlzLnogLSB2Lno7XHJcbiAgICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcclxuICAgIH1cclxuICAgIGRpc1RvTWFuaGF0KHYpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdi54KSArIE1hdGguYWJzKHRoaXMueSAtIHYueSkgKyBNYXRoLmFicyh0aGlzLnogLSB2LnopO1xyXG4gICAgfVxyXG4gICAgc2V0TGVuZ3RoKGxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKGxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBsZXJwKG90aGVyLCBhbHBoYSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMygob3RoZXIueCAtIHRoaXMueCkgKiBhbHBoYSwgKG90aGVyLnkgLSB0aGlzLnkpICogYWxwaGEsIChvdGhlci56IC0gdGhpcy56KSAqIGFscGhhKTtcclxuICAgIH1cclxuICAgIC8vICNlbmRyZWdpb25cclxuICAgIC8vICNyZWdpb24gbWF0aCBzcGVjaWZpY1xyXG4gICAgcHJvamVjdE9uVmVjdG9yKG90aGVyKSB7XHJcbiAgICAgICAgLy8gdXNlIGRvdCBwcm9kdWN0IHRvIHByb2plY3QgdGhpcyB2ZWN0b3Igb24gdGhlIG90aGVyIHZlY3RvclxyXG4gICAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gb3RoZXIuZ2V0TGVuZ3RoU3F1YXJlZCgpO1xyXG4gICAgICAgIGlmIChkZW5vbWluYXRvciA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IHNjYWxhciA9IG90aGVyLmRvdCh0aGlzKSAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkob3RoZXIpLnNjYWxlKHNjYWxhcik7XHJcbiAgICB9XHJcbiAgICBwcm9qZWN0ZWRPblBsYW5lKG5vcm1hbCkge1xyXG4gICAgICAgIC8vIHByb2plY3QgYSB2ZWN0b3JcclxuICAgICAgICBfdmVjdG9yLmNvcHkodGhpcykucHJvamVjdE9uVmVjdG9yKG5vcm1hbCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bWVkKF92ZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgbWlycm9yZWQobm9ybWFsKSB7XHJcbiAgICAgICAgLy8gbWlycm9yIGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcclxuICAgICAgICAvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluaW11bWVkKF92ZWN0b3IuY29weShub3JtYWwpLnNjYWxlKDIgKiB0aGlzLmRvdChub3JtYWwpKSk7XHJcbiAgICB9XHJcbiAgICByb3RhdGVkKGF4aXMsIGFuZ2xlKSB7XHJcbiAgICAgICAgbGV0IG1hdCA9IE1hdHJpeDQubmV3QXhpc1JvdGF0aW9uKGF4aXMsIGFuZ2xlKTtcclxuICAgICAgICByZXR1cm4gbWF0Lm11bHRpcGx5VmVjdG9yKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IF92ZWN0b3IgPSBuZXcgVmVjdG9yMygwLCAwLCAwKTtcclxuZXhwb3J0IGNsYXNzIFZlY3RvcjIge1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuICAgIC8vIC0tLSBmYWN0b3JpZXMgJiBvdGhlciBzdGF0aWNzXHJcbiAgICBzdGF0aWMgZnJvbUFycmF5KGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoYVswXSwgYVsxXSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUxlcnAodjEsIHYyLCBhbHBoYSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih2MS54ICsgKHYyLnggLSB2MS54KSAqIGFscGhhLCB2MS55ICsgKHYyLnkgLSB2MS55KSAqIGFscGhhKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUmFuZG9tKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUmFuZG9tQW5nbGUoKSB7XHJcbiAgICAgICAgbGV0IGFscGhhID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihNYXRoLmNvcyhhbHBoYSksIE1hdGguc2luKGFscGhhKSk7XHJcbiAgICB9XHJcbiAgICAvLyBzdGF0aWMgZnJvbTJQdChmcm9tOiBWZWN0b3IyLCB0bzogVmVjdG9yMikgOiBWZWN0b3IyIHtcclxuICAgIC8vIFx0cmV0dXJuIG5ldyBWZWN0b3IyKFxyXG4gICAgLy8gXHRcdGZyb20ueCAtIHRvLngsXHJcbiAgICAvLyBcdFx0ZnJvbS55IC0gdG8ueVxyXG4gICAgLy8gXHQpXHJcbiAgICAvLyB9XHJcbiAgICBzdGF0aWMgZnJvbUNpcmNsZShjZW50ZXIsIHJhZGl1cywgdGhldGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSksIGNlbnRlci55ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQ29weShvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnplcm8oKS5jb3B5KG90aGVyKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB6ZXJvKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigwLCAwKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBOYU4oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKE5hTiwgTmFOKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQ2lyY3VtY2VudGVyKGEsIGIsIGMpIHtcclxuICAgICAgICBjb25zdCBhc3VtID0gYS5zcXVhcmVTdW0oKTtcclxuICAgICAgICBjb25zdCBic3VtID0gYi5zcXVhcmVTdW0oKTtcclxuICAgICAgICBjb25zdCBjc3VtID0gYy5zcXVhcmVTdW0oKTtcclxuICAgICAgICAvLyBzb3J0IG9mIGNyb3NzIHByb2R1Y3RcclxuICAgICAgICBsZXQgZCA9IDIgKiAoYS54ICogKGIueSAtIGMueSkgKyBiLnggKiAoYy55IC0gYS55KSArIGMueCAqIChhLnkgLSBiLnkpKTtcclxuICAgICAgICAvLyBpZiB0aGlzIHRyaWFuZ2xlIGhhcyBubyBjaXJjdW1jZW50ZXI/XHJcbiAgICAgICAgaWYgKGQgPCAwLjAwMDAwMSlcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuTmFOKCk7XHJcbiAgICAgICAgbGV0IHggPSAoYXN1bSAqIChiLnkgLSBjLnkpICsgYnN1bSAqIChjLnkgLSBhLnkpICsgY3N1bSAqIChhLnkgLSBiLnkpKSAvIGQ7XHJcbiAgICAgICAgbGV0IHkgPSAoYXN1bSAqIChjLnggLSBiLngpICsgYnN1bSAqIChhLnggLSBjLngpICsgY3N1bSAqIChiLnggLSBhLngpKSAvIGQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFNpZ24oYSwgYiwgYykge1xyXG4gICAgICAgIC8vIHRlc3QgaGFsZiBwbGFuZSByZWxhdGlvbnNoaXBcclxuICAgICAgICAvLyA8MCA6IHBvaW50IG9uIGZpcnN0IGhhbGZcclxuICAgICAgICAvLyAwICA6IHBvaW50cyBjb2xsaW5lYXJcclxuICAgICAgICAvLyA+MCA6IHBvaW50IG9uIHNlY29uZCBoYWxmXHJcbiAgICAgICAgcmV0dXJuIChhLnggLSBjLngpICogKGIueSAtIGMueSkgLSAoYi54IC0gYy54KSAqIChhLnkgLSBjLnkpO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tIGJhc2ljc1xyXG4gICAgdG8zRCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModGhpcy54LCB0aGlzLnksIDApO1xyXG4gICAgfVxyXG4gICAgc2V0KHgsIHkpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByb3VnaGx5RXF1YWxzKHYsIHRvbCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSB2LngpIDwgdG9sICYmIE1hdGguYWJzKHRoaXMueSAtIHYueSkgPCB0b2w7XHJcbiAgICB9XHJcbiAgICBlcXVhbHModikge1xyXG4gICAgICAgIHJldHVybiB2LnggPT09IHRoaXMueCAmJiB2LnkgPT09IHRoaXMueTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgVmVjdG9yMigke3RoaXMueH0sICR7dGhpcy55fSlgO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuICAgIGNvcHkodikge1xyXG4gICAgICAgIHRoaXMueCA9IHYueDtcclxuICAgICAgICB0aGlzLnkgPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyAtLS0gbWF0aFxyXG4gICAgYWRkKHYpIHtcclxuICAgICAgICB0aGlzLnggKz0gdi54O1xyXG4gICAgICAgIHRoaXMueSArPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRlZCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcclxuICAgIH1cclxuICAgIGFkZG4oYXJnMCwgYXJnMSkge1xyXG4gICAgICAgIHRoaXMueCArPSBhcmcwO1xyXG4gICAgICAgIHRoaXMueSArPSBhcmcxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc3ViKHYpIHtcclxuICAgICAgICB0aGlzLnggLT0gdi54O1xyXG4gICAgICAgIHRoaXMueSAtPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzdWJiZWQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSk7XHJcbiAgICB9XHJcbiAgICBtdWwodikge1xyXG4gICAgICAgIHRoaXMueCAqPSB2Lng7XHJcbiAgICAgICAgdGhpcy55ICo9IHYueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNjYWxlKHYpIHtcclxuICAgICAgICB0aGlzLnggKj0gdjtcclxuICAgICAgICB0aGlzLnkgKj0gdjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNjYWxlZCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCAqIHYsIHRoaXMueSAqIHYpO1xyXG4gICAgfVxyXG4gICAgZGl2VmVjdG9yKHYpIHtcclxuICAgICAgICB0aGlzLnggLz0gdi54O1xyXG4gICAgICAgIHRoaXMueSAvPSB2Lnk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkaXYodikge1xyXG4gICAgICAgIHRoaXMueCAvPSB2O1xyXG4gICAgICAgIHRoaXMueSAvPSB2O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZGl2ZWQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnggLyB2LCB0aGlzLnkgLyB2KTtcclxuICAgIH1cclxuICAgIG1pbmltdW0ob3RoZXIpIHtcclxuICAgICAgICB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIG90aGVyLngpO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgb3RoZXIueSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtYXhpbXVtKG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCBvdGhlci54KTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIG90aGVyLnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2xhbXAobWluLCBtYXgpIHtcclxuICAgICAgICAvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxyXG4gICAgICAgIHRoaXMueCA9IE1hdGgubWF4KG1pbi54LCBNYXRoLm1pbihtYXgueCwgdGhpcy54KSk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5tYXgobWluLnksIE1hdGgubWluKG1heC55LCB0aGlzLnkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGNsYW1wU2NhbGFyKG1pblZhbCwgbWF4VmFsKSB7XHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5tYXgobWluVmFsLCBNYXRoLm1pbihtYXhWYWwsIHRoaXMueCkpO1xyXG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KG1pblZhbCwgTWF0aC5taW4obWF4VmFsLCB0aGlzLnkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGNsYW1wTGVuZ3RoKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXYobGVuZ3RoIHx8IDEpLnNjYWxlKE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCBsZW5ndGgpKSk7XHJcbiAgICB9XHJcbiAgICBmbG9vcigpIHtcclxuICAgICAgICB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2VpbCgpIHtcclxuICAgICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJvdW5kKCkge1xyXG4gICAgICAgIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KTtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByb3VuZFRvWmVybygpIHtcclxuICAgICAgICB0aGlzLnggPSB0aGlzLnggPCAwID8gTWF0aC5jZWlsKHRoaXMueCkgOiBNYXRoLmZsb29yKHRoaXMueCk7XHJcbiAgICAgICAgdGhpcy55ID0gdGhpcy55IDwgMCA/IE1hdGguY2VpbCh0aGlzLnkpIDogTWF0aC5mbG9vcih0aGlzLnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbmVnYXRlKCkge1xyXG4gICAgICAgIHRoaXMueCA9IC10aGlzLng7XHJcbiAgICAgICAgdGhpcy55ID0gLXRoaXMueTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRvdCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuICAgIH1cclxuICAgIGNyb3NzKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54OyAvLyA/Pz8/XHJcbiAgICB9XHJcbiAgICBzcXVhcmVTdW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuICAgIH1cclxuICAgIGxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKTtcclxuICAgIH1cclxuICAgIGxlbmd0aFNxdWFyZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuICAgIH1cclxuICAgIG1hbmhhdCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54KSArIE1hdGguYWJzKHRoaXMueSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2KHRoaXMubGVuZ3RoKCkgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpdmVkKHRoaXMubGVuZ3RoKCkgfHwgMSk7XHJcbiAgICB9XHJcbiAgICBhbmdsZSgpIHtcclxuICAgICAgICAvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMigtdGhpcy55LCAtdGhpcy54KSArIE1hdGguUEk7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlO1xyXG4gICAgfVxyXG4gICAgZGlzVG8odikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXNUb1NxdWFyZWQodikpO1xyXG4gICAgfVxyXG4gICAgZGlzVG9TcXVhcmVkKHYpIHtcclxuICAgICAgICBsZXQgZHggPSB0aGlzLnggLSB2Lng7XHJcbiAgICAgICAgbGV0IGR5ID0gdGhpcy55IC0gdi55O1xyXG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgIH1cclxuICAgIGRpc1RvTWFuaGF0KHYpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdi54KSArIE1hdGguYWJzKHRoaXMueSAtIHYueSk7XHJcbiAgICB9XHJcbiAgICBzZXRMZW5ndGgobGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkuc2NhbGUobGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGxlcnAob3RoZXIsIGFscGhhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCArIChvdGhlci54IC0gdGhpcy54KSAqIGFscGhhLCB0aGlzLnkgKyAob3RoZXIueSAtIHRoaXMueSkgKiBhbHBoYSk7XHJcbiAgICB9XHJcbiAgICAvLyBjYWxjdWxhdGUgdGhlICd0cmlhbmdsZSBzaWduJyBvZiB0aHJlZSBwb2ludHMuIENhbiBiZSB1c2VkIHRvIGRldGVybWluZSBjbG9ja3dpc2UgJiBjb3VudGVyIGNsb2Nrd2lzZVxyXG4gICAgc2lnbihiLCBjKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnggLSBjLngpICogKGIueSAtIGMueSkgLSAoYi54IC0gYy54KSAqICh0aGlzLnkgLSBjLnkpO1xyXG4gICAgfVxyXG4gICAgLy8gdXNlIGRvdCBwcm9kdWN0IHRvIHByb2plY3QgdGhpcyB2ZWN0b3Igb24gdGhlIG90aGVyIHZlY3RvclxyXG4gICAgcHJvamVjdE9uVmVjdG9yKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgZGVub21pbmF0b3IgPSBvdGhlci5sZW5ndGhTcXVhcmVkKCk7XHJcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gb3RoZXIuZG90KHRoaXMpIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weShvdGhlcikuc2NhbGUoc2NhbGFyKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBhcnJheS50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogU21hbGwgd3JhcHBlciBhcm91bmQgRmxvYXQzMkFycmF5IC8gRmxvYXRNYXRyaXggdG8gYWRkIGludGVyb3BlcmFiaWxpdHkgd2l0aCBWZWN0b3IyICYgVmVjdG9yMyxcclxuLy8gICAgICAgICAgd2hpbGUgcmVtYWluaW5nIGEgZGF0YXN0cnVjdHVyZSB0aGF0cyBlYXN5IHRvIHBhc3Mgb3ZlciB0byB3ZWJnbFxyXG4vL1xyXG4vLyBOT1RFOiAgICBhbGwgdGhlc2Ugc21hbGwgd3JhcHBlcnMgbWlnaHQgbm90IGJlIGdvb2QgcHJhdGljZSwgYnV0IElcclxuLy8gICAgICAgICAgbGlrZSB0byBleHRyYWN0IHNpbXBsZSBsb2dpYyBsaWtlIHRoaXMgdG8gbm90IGNsdXR0ZXIgdGhlIGNvZGUgdG9vIG11Y2hcclxuaW1wb3J0IHsgVmVjdG9yMywgVmVjdG9yMiB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBGbG9hdE1hdHJpeCB9IGZyb20gXCIuL2Zsb2F0LW1hdHJpeFwiO1xyXG5leHBvcnQgY2xhc3MgVmVjdG9yMkFycmF5IGV4dGVuZHMgRmxvYXRNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoY291bnQpIHtcclxuICAgICAgICBzdXBlcihjb3VudCwgMik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUxpc3QodmVjcykge1xyXG4gICAgICAgIGxldCBsZW5ndGggPSB2ZWNzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYXJyYXkgPSBuZXcgVmVjdG9yMkFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycmF5LmRhdGFbaSAqIDJdID0gdmVjc1tpXS54O1xyXG4gICAgICAgICAgICBhcnJheS5kYXRhW2kgKiAyICsgMV0gPSB2ZWNzW2ldLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIGZvckVhY2goY2FsbGJhY2tmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHZlYyA9IHRoaXMuZ2V0VmVjdG9yKGkpO1xyXG4gICAgICAgICAgICBjYWxsYmFja2ZuKHZlYywgaSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmVjdG9yKGksIHZlYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbWFwKGNhbGxiYWNrZm4pIHtcclxuICAgICAgICBsZXQgY2xvbmUgPSB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmVjID0gdGhpcy5nZXRWZWN0b3IoaSk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBjYWxsYmFja2ZuKHZlYywgaSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5zZXRWZWN0b3IoaSwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLnNldFZlY3RvcihpLCB2ZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIHNldFZlY3RvcihpLCB2ZWMpIHtcclxuICAgICAgICB0aGlzLmRhdGFbaSAqIHRoaXMuX3dpZHRoICsgMF0gPSB2ZWMueDtcclxuICAgICAgICB0aGlzLmRhdGFbaSAqIHRoaXMuX3dpZHRoICsgMV0gPSB2ZWMueTtcclxuICAgIH1cclxuICAgIGdldFZlY3RvcihpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMuZGF0YVtpICogdGhpcy5fd2lkdGggKyAwXSwgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIDFdKTtcclxuICAgIH1cclxuICAgIHRvTGlzdCgpIHtcclxuICAgICAgICBsZXQgdmVjcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgdmVjcy5wdXNoKHRoaXMuZ2V0VmVjdG9yKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlY3M7XHJcbiAgICB9XHJcbiAgICB0bzNEKCkge1xyXG4gICAgICAgIGxldCBhcnJheSA9IG5ldyBWZWN0b3IzQXJyYXkodGhpcy5jb3VudCgpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSB0aGlzLmdldFJvdyhpKTtcclxuICAgICAgICAgICAgYXJyYXkuc2V0Um93KGksIFtyb3dbMF0sIHJvd1sxXSwgMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBsZXQgY2xvbmUgPSBuZXcgVmVjdG9yMkFycmF5KHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY2xvbmUuZGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBWZWN0b3IzQXJyYXkgZXh0ZW5kcyBGbG9hdE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb3VudCkge1xyXG4gICAgICAgIHN1cGVyKGNvdW50LCAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTGlzdCh2ZWNzKSB7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IHZlY3MubGVuZ3RoO1xyXG4gICAgICAgIGxldCBhcnJheSA9IG5ldyBWZWN0b3IzQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJyYXkuZGF0YVtpICogM10gPSB2ZWNzW2ldLng7XHJcbiAgICAgICAgICAgIGFycmF5LmRhdGFbaSAqIDMgKyAxXSA9IHZlY3NbaV0ueTtcclxuICAgICAgICAgICAgYXJyYXkuZGF0YVtpICogMyArIDJdID0gdmVjc1tpXS56O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbU5hdGl2ZShuYXRpdmUpIHtcclxuICAgICAgICAvLyBhc3N1bWUgYWxsIHN1YmFycmF5cyBoYXZlIHRoZSBzYW1lIHNoYXBlISFcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gbmF0aXZlLmxlbmd0aDtcclxuICAgICAgICBsZXQgbWF0cml4ID0gbmV3IFZlY3RvcjNBcnJheShoZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF0aXZlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmF0aXZlWzBdLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0KGksIGosIG5hdGl2ZVtpXVtqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIGZpbGxGcm9tTGlzdCh2ZWNzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogM10gPSB2ZWNzW2ldLng7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogMyArIDFdID0gdmVjc1tpXS55O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGFbaSAqIDMgKyAyXSA9IHZlY3NbaV0uejtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2ZWMgPSB0aGlzLmdldFZlY3RvcihpKTtcclxuICAgICAgICAgICAgdmVjID0gY2FsbGJhY2tmbih2ZWMsIGkpO1xyXG4gICAgICAgICAgICBpZiAodmVjIGluc3RhbmNlb2YgVmVjdG9yMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWZWN0b3IoaSwgdmVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHRha2UoaW5kaWNlcykge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBmbG9hdGFycmF5XHJcbiAgICAgICAgY29uc3QgY291bnQgPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICBsZXQgYXJyYXkgPSBuZXcgVmVjdG9yM0FycmF5KGNvdW50KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGdldEluZGV4ID0gaW5kaWNlc1tpXTtcclxuICAgICAgICAgICAgYXJyYXkuc2V0VmVjdG9yKGksIHRoaXMuZ2V0VmVjdG9yKGdldEluZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIG1hcChjYWxsYmFja2ZuKSB7XHJcbiAgICAgICAgbGV0IGNsb25lID0gdGhpcy5jbG9uZSgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHZlYyA9IHRoaXMuZ2V0VmVjdG9yKGkpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gY2FsbGJhY2tmbih2ZWMsIGkpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgVmVjdG9yMykge1xyXG4gICAgICAgICAgICAgICAgY2xvbmUuc2V0VmVjdG9yKGksIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5zZXRWZWN0b3IoaSwgdmVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICB9XHJcbiAgICBtYXBXaXRoKG90aGVyLCBjYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5tYXBXaXRoKG90aGVyLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBzZXRWZWN0b3IoaSwgdmVjKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIDBdID0gdmVjLng7XHJcbiAgICAgICAgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIDFdID0gdmVjLnk7XHJcbiAgICAgICAgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIDJdID0gdmVjLno7XHJcbiAgICB9XHJcbiAgICBnZXRWZWN0b3IoaSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLmRhdGFbaSAqIHRoaXMuX3dpZHRoICsgMF0sIHRoaXMuZGF0YVtpICogdGhpcy5fd2lkdGggKyAxXSwgdGhpcy5kYXRhW2kgKiB0aGlzLl93aWR0aCArIDJdKTtcclxuICAgIH1cclxuICAgIHRvTGlzdCgpIHtcclxuICAgICAgICBsZXQgdmVjcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgdmVjcy5wdXNoKHRoaXMuZ2V0VmVjdG9yKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlY3M7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm0obSkge1xyXG4gICAgICAgIC8vIFRISVMgQ0FOIEJFIFNQRUVEIFVQOiBCT1RIIE1BVFJJWCA0ICYgVkVDVE9SM0FSUkFZIEFSRSBKVVNUIEZMT0FULU1BVFJJQ0VTXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9oZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmVjID0gdGhpcy5nZXRWZWN0b3IoaSk7XHJcbiAgICAgICAgICAgIHZlYyA9IG0ubXVsdGlwbHlWZWN0b3IodmVjKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRWZWN0b3IoaSwgdmVjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcy5kYXRhID0gbS5NdWx0aXBseU0odGhpcykuZGF0YTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHRvMkQoKSB7XHJcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IFZlY3RvcjJBcnJheSh0aGlzLl9oZWlnaHQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IFZlY3RvcjNBcnJheSh0aGlzLl9oZWlnaHQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsb25lLmRhdGFbaV0gPSB0aGlzLmRhdGFbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgIH1cclxuICAgIG1lYW4oKSB7XHJcbiAgICAgICAgLy8gdGhlIG1lYW4gdmVjdG9yIG9mIGEgc2VyaWVzIG9mIHZlY3RvcnNcclxuICAgICAgICBsZXQgc3VtID0gVmVjdG9yMy56ZXJvKCk7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0ueCArPSB0aGlzLmRhdGFbaSAqIDNdO1xyXG4gICAgICAgICAgICBzdW0ueSArPSB0aGlzLmRhdGFbaSAqIDMgKyAxXTtcclxuICAgICAgICAgICAgc3VtLnogKz0gdGhpcy5kYXRhW2kgKiAzICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW0uc2NhbGUoMSAvIGNvdW50KTtcclxuICAgIH1cclxuICAgIGF2ZXJhZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVhbigpO1xyXG4gICAgfVxyXG4gICAgY2xvc2VzdElkKHBvaW50KSB7XHJcbiAgICAgICAgbGV0IGxvd1Njb3JlID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IGlkID0gLTE7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkaXNTcXVhcmVkID0gcG9pbnQuZGlzVG9TcXVhcmVkKHYpO1xyXG4gICAgICAgICAgICBpZiAoZGlzU3F1YXJlZCA8IGxvd1Njb3JlKSB7XHJcbiAgICAgICAgICAgICAgICBsb3dTY29yZSA9IGRpc1NxdWFyZWQ7XHJcbiAgICAgICAgICAgICAgICBpZCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9XHJcbiAgICBjbG9zZXN0SWRzKHBvaW50LCBuKSB7XHJcbiAgICAgICAgLy8gTyhtKm4pLi4uIFRPRE8gaW1wbGVtZW50IHF1aWNrc29ydFxyXG4gICAgICAgIGxldCBpZHMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbG93U2NvcmUgPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgbGV0IGlkID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkcy5pbmNsdWRlcyhpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpc1NxdWFyZWQgPSBwb2ludC5kaXNUb1NxdWFyZWQodik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzU3F1YXJlZCA8IGxvd1Njb3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93U2NvcmUgPSBkaXNTcXVhcmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlkcy5wdXNoKGlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlkcztcclxuICAgIH1cclxufVxyXG4vLyBUT0RPIDogdG8gRmxvYXRNYXRyaXhcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEdlbmVyYWxGbG9hdE1hdHJpeCh2ZWN0b3JzKSB7XHJcbiAgICBpZiAodmVjdG9ycyBpbnN0YW5jZW9mIFZlY3RvcjJBcnJheSkge1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3JzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmVjdG9ycyBpbnN0YW5jZW9mIFZlY3RvcjNBcnJheSkge1xyXG4gICAgICAgIHJldHVybiB2ZWN0b3JzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmVjdG9yc1swXSBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMkFycmF5LmZyb21MaXN0KHZlY3RvcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFZlY3RvcjNBcnJheS5mcm9tTGlzdCh2ZWN0b3JzKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBOYW1lOiByZW5kZXItbWVzaC50c1xyXG4vLyBBdXRob3I6IEpvcyBGZWVuc3RyYVxyXG4vLyBQdXJwb3NlOlxyXG4vLyBhIG1lc2ggcmVwcmVzZW50YXRpb24gd2l0aCB0aGUgc29sZSBwdXJwb3NlIG9mIHRvIGJlIHJlbmRlcmVyLlxyXG4vLyAtIGZpeGVkIGxlbmd0aCBhdHRyaWJ1dGVzXHJcbi8vIC0gY2FuIHJlcHJlc2VudDpcclxuLy8gICAtIHBvaW50Y2xvdWQgKGxpbmtzID0gbnVsbClcclxuLy8gICAtIGdyYXBoIChsaW5rcy53aWR0aCA9IDIpXHJcbi8vICAgLSB0cmlhbmdsZXMgKGxpbmtzLndpZHRoID0gMylcclxuLy8gICAtIHF1YWRzIChsaW5rcy53aWR0aCA9IDQuIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gdHJpYW5nbGVzKVxyXG5pbXBvcnQgeyBWZWN0b3IyQXJyYXksIFZlY3RvcjNBcnJheSB9IGZyb20gXCIuLi9kYXRhL3ZlY3Rvci1hcnJheVwiO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi9tZXNoXCI7XHJcbmV4cG9ydCB2YXIgTWVzaFR5cGU7XHJcbihmdW5jdGlvbiAoTWVzaFR5cGUpIHtcclxuICAgIE1lc2hUeXBlW01lc2hUeXBlW1wiSW52YWxpZFwiXSA9IDBdID0gXCJJbnZhbGlkXCI7XHJcbiAgICBNZXNoVHlwZVtNZXNoVHlwZVtcIlBvaW50c1wiXSA9IDFdID0gXCJQb2ludHNcIjtcclxuICAgIE1lc2hUeXBlW01lc2hUeXBlW1wiTGluZXNcIl0gPSAyXSA9IFwiTGluZXNcIjtcclxuICAgIE1lc2hUeXBlW01lc2hUeXBlW1wiVHJpYW5nbGVzXCJdID0gM10gPSBcIlRyaWFuZ2xlc1wiO1xyXG4gICAgTWVzaFR5cGVbTWVzaFR5cGVbXCJRdWFkc1wiXSA9IDRdID0gXCJRdWFkc1wiO1xyXG59KShNZXNoVHlwZSB8fCAoTWVzaFR5cGUgPSB7fSkpO1xyXG5leHBvcnQgdmFyIE5vcm1hbEtpbmQ7XHJcbihmdW5jdGlvbiAoTm9ybWFsS2luZCkge1xyXG4gICAgTm9ybWFsS2luZFtOb3JtYWxLaW5kW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICBOb3JtYWxLaW5kW05vcm1hbEtpbmRbXCJWZXJ0ZXhcIl0gPSAxXSA9IFwiVmVydGV4XCI7XHJcbiAgICBOb3JtYWxLaW5kW05vcm1hbEtpbmRbXCJGYWNlXCJdID0gMl0gPSBcIkZhY2VcIjtcclxuICAgIE5vcm1hbEtpbmRbTm9ybWFsS2luZFtcIk11bHRpVmVydGV4XCJdID0gM10gPSBcIk11bHRpVmVydGV4XCI7XHJcbn0pKE5vcm1hbEtpbmQgfHwgKE5vcm1hbEtpbmQgPSB7fSkpO1xyXG5leHBvcnQgY2xhc3MgUmVuZGVyYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0Q291bnQsIG5vcm1Db3VudCwgdXZDb3VudCwgZmFjZUNvdW50LCB0ZXh0dXJlID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5fbm9ybUtpbmQgPSBOb3JtYWxLaW5kLk5vbmU7XHJcbiAgICAgICAgLy8gcmVuZGVyIHNwZWVkXHJcbiAgICAgICAgLy8gc2hhZGVyXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFsxLCAxLCAxLCAxXTtcclxuICAgICAgICB0aGlzLmxpbmVjb2xvciA9IFsxLCAxLCAxLCAxXTtcclxuICAgICAgICBsZXQgcGVyRmFjZUNvdW50ID0gMztcclxuICAgICAgICB0aGlzLm1lc2ggPSBNZXNoLm5ld0VtcHR5KHZlcnRDb3VudCwgZmFjZUNvdW50LCBwZXJGYWNlQ291bnQpO1xyXG4gICAgICAgIHRoaXMubm9ybXMgPSBuZXcgVmVjdG9yM0FycmF5KG5vcm1Db3VudCk7XHJcbiAgICAgICAgdGhpcy51dnMgPSBuZXcgVmVjdG9yMkFycmF5KHV2Q291bnQpO1xyXG4gICAgICAgIHRoaXMuYW1iaSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydENvdW50KTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBNYXRyaXg0Lm5ld0lkZW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KHZlcnRDb3VudCwgbm9ybUNvdW50LCB1dkNvdW50LCBmYWNlQ291bnQsIHRleHR1cmUgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlcmFibGUodmVydENvdW50LCBub3JtQ291bnQsIHV2Q291bnQsIGZhY2VDb3VudCwgdGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbU1lc2gobWVzaCkge1xyXG4gICAgICAgIGxldCByID0gbmV3IFJlbmRlcmFibGUobWVzaC52ZXJ0cy5jb3VudCgpLCAwLCAwLCBtZXNoLmxpbmtzLmNvdW50KCkpO1xyXG4gICAgICAgIHIubWVzaC52ZXJ0cy5kYXRhID0gbWVzaC52ZXJ0cy5kYXRhO1xyXG4gICAgICAgIHIubWVzaC5saW5rcy5kYXRhID0gbWVzaC5saW5rcy5kYXRhO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21EYXRhKHZlcnRzLCBub3JtcywgdXZzLCBmYWNlcykge1xyXG4gICAgICAgIC8vIE5PVEUgOiB0aGlzIHR5cGUgb2YgcGFyc2luZyBtYWtlcyBteSBsaWZlIGVhc3ksIGJ1dCBpcyBkYW5nZXJvdXMuIFRoaXMgaXMgd2h5IGkgY3JlYXRlZCB0aGVcclxuICAgICAgICAvLyBBcnJheSBjbGFzcy5cclxuICAgICAgICBsZXQgciA9IG5ldyBSZW5kZXJhYmxlKHZlcnRzLmxlbmd0aCAvIDMsIG5vcm1zLmxlbmd0aCAvIDMsIHV2cy5sZW5ndGggLyAyLCBmYWNlcy5sZW5ndGggLyAzKTtcclxuICAgICAgICByLm1lc2gudmVydHMuZmlsbFdpdGgodmVydHMpO1xyXG4gICAgICAgIHIubWVzaC5saW5rcy5maWxsV2l0aChmYWNlcyk7XHJcbiAgICAgICAgci5ub3Jtcy5maWxsV2l0aChub3Jtcyk7XHJcbiAgICAgICAgci51dnMuZmlsbFdpdGgodXZzKTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tR3JhcGgoZ3JhcGgpIHtcclxuICAgICAgICBsZXQgbWVzaCA9IGdyYXBoLnRvTWVzaCgpO1xyXG4gICAgICAgIGxldCByID0gUmVuZGVyYWJsZS5mcm9tTWVzaChtZXNoKTtcclxuICAgICAgICByLm5vcm1zID0gVmVjdG9yM0FycmF5LmZyb21MaXN0KGdyYXBoLmFsbE5vcm1zKCkpO1xyXG4gICAgICAgIHIuX25vcm1LaW5kID0gTm9ybWFsS2luZC5WZXJ0ZXg7IC8vIGZpeCB0aGlzISFcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuICAgIC8vIGdlb21ldHJ5IHRyYWl0XHJcbiAgICB0cmFuc2Zvcm0obWF0cml4KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lc2gudmVydHMuY291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2ID0gdGhpcy5tZXNoLnZlcnRzLmdldFZlY3RvcihpKTtcclxuICAgICAgICAgICAgbGV0IG4gPSB0aGlzLm5vcm1zLmdldFZlY3RvcihpKTtcclxuICAgICAgICAgICAgdGhpcy5tZXNoLnZlcnRzLnNldFZlY3RvcihpLCBtYXRyaXgubXVsdGlwbHlWZWN0b3IodikpO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1zLnNldFZlY3RvcihpLCBtYXRyaXgubXVsdGlwbHlWZWN0b3IobikpOyAvLyBUT0RPLCBFWFRSQUNUIE9OTFkgUk9UQVRJT04gUEFSVCBGUk9NIFRIRSBNQVRSSVhcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBnZXR0ZXJzICYgc2VsZWN0b3JzXHJcbiAgICAvLyBWRVJZIFBPT1JMWSBPUFRJTUlaRURcclxuICAgIGdldEFkamFjZW50RmFjZXModikge1xyXG4gICAgICAgIGxldCBmYWNlcyA9IFtdO1xyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMubWVzaC5saW5rcy5jb3VudCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tZXNoLmxpbmtzLmdldFJvdyhpKS5pbmNsdWRlcyh2KSkge1xyXG4gICAgICAgICAgICAgICAgZmFjZXMucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFjZXM7XHJcbiAgICB9XHJcbiAgICBnZXRGYWNlVmVydGljZXMoZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc2guZ2V0TGlua1ZlcnRzKGYpO1xyXG4gICAgfVxyXG4gICAgZ2V0VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNoLmdldFR5cGUoKTtcclxuICAgIH1cclxuICAgIGdldE5vcm1hbFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1LaW5kO1xyXG4gICAgfVxyXG4gICAgLy8gc2V0dGVyc1xyXG4gICAgc2V0VGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICAvLyByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgbmVlZGVkXHJcbiAgICB9XHJcbiAgICBzZXRVdnModXZzKSB7XHJcbiAgICAgICAgaWYgKHV2cyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xyXG4gICAgICAgICAgICB0aGlzLnV2cy5kYXRhID0gdXZzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51dnMgPSB1dnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIGlmIG5lZWRlZFxyXG4gICAgfVxyXG4gICAgLy8gY29udmVydFxyXG4gICAgZXhwb3J0VG9PYmoocGF0aCkge1xyXG4gICAgICAgIHRocm93IFwidG9kb1wiO1xyXG4gICAgfVxyXG4gICAgLy8gLS0tLS0tIG5vcm1hbHMgLS0tLS0tXHJcbiAgICAvLyBzZXQgMSBub3JtYWwgcGVyIGZhY2VcclxuICAgIGNhbGN1bGF0ZUZhY2VOb3JtYWxzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldFR5cGUoKSAhPSBNZXNoVHlwZS5UcmlhbmdsZXMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNhbiBvbmx5IGNhbGN1bGF0ZSBub3JtYWxzIGZyb20gdHJpYW5ndWxhciBtZXNoZXNcIik7XHJcbiAgICAgICAgICAgIHRoaXMubm9ybXMgPSBuZXcgVmVjdG9yM0FycmF5KDApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub3JtcyA9IHRoaXMubWVzaC5jYWxjdWxhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgICAgIHRoaXMubm9ybXMgPSBWZWN0b3IzQXJyYXkuZnJvbUxpc3Qobm9ybXMpO1xyXG4gICAgICAgIHRoaXMuX25vcm1LaW5kID0gTm9ybWFsS2luZC5GYWNlO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlVmVydGV4Tm9ybWFscygpIHtcclxuICAgICAgICBsZXQgbm9ybXMgPSB0aGlzLm1lc2guY2FsY3VsYXRlVmVydGV4Tm9ybWFscygpO1xyXG4gICAgICAgIHRoaXMubm9ybXMgPSBWZWN0b3IzQXJyYXkuZnJvbUxpc3Qobm9ybXMpO1xyXG4gICAgICAgIHRoaXMuX25vcm1LaW5kID0gTm9ybWFsS2luZC5WZXJ0ZXg7XHJcbiAgICB9XHJcbiAgICBjYWxjdWxhdGVNdWx0aVZlcnRleE5vcm1hbHMoKSB7XHJcbiAgICAgICAgLy8gc2V0IHR5cGVcclxuICAgICAgICB0aGlzLl9ub3JtS2luZCA9IE5vcm1hbEtpbmQuTXVsdGlWZXJ0ZXg7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlXHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVGYWNlTm9ybWFscygpO1xyXG4gICAgICAgIGxldCB2ZXJ0Tm9ybWFscyA9IG5ldyBWZWN0b3IzQXJyYXkodGhpcy5tZXNoLnZlcnRzLmNvdW50KCkpO1xyXG4gICAgICAgIHRoaXMubWVzaC52ZXJ0cy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhZGpGYWNlcyA9IHRoaXMuZ2V0QWRqYWNlbnRGYWNlcyhpKTtcclxuICAgICAgICAgICAgdmVydE5vcm1hbHMuc2V0VmVjdG9yKGksIHRoaXMubm9ybXMudGFrZShhZGpGYWNlcykuYXZlcmFnZSgpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm5vcm1zID0gdmVydE5vcm1hbHM7XHJcbiAgICB9XHJcbn1cclxuLy8gPT09PT09PT09PT09PT09PSBPYmogPT09PT09PT09PT09PT09PT09PVxyXG5leHBvcnQgZnVuY3Rpb24gbWVzaEZyb21PYmoodGV4dCkge1xyXG4gICAgLy8gVGhpcyBpcyBub3QgYSBmdWxsIC5vYmogcGFyc2VyLlxyXG4gICAgLy8gc2VlIGh0dHA6Ly9wYXVsYm91cmtlLm5ldC9kYXRhZm9ybWF0cy9vYmovXHJcbiAgICAvLyBJTkRFWEVTIE9SSUdJTkFMTFkgUkVGRVIgVE8gTElORVMsIHNvIC0xIGlzIG5lZWRlZFxyXG4gICAgLy8gcnVuIHRocm91Z2ggYWxsIGxpbmVzLCBhbmQgdGVtcG9yYXJlbHkgc3RvcmVcclxuICAgIC8vIGFsbCBkYXRhIGluIHJhdyBudW1iZXIgbGlzdHMsIHNpbmNlIHdlIGRvbnQga25vdyBob3dcclxuICAgIC8vIG1hbnkgdmVydGljZXMgb3IgZmFjZXMgd2VsbCBnZXQuXHJcbiAgICBsZXQgdmVydHMgPSBbXTsgLy8gMyBsb25nIGZsb2F0XHJcbiAgICBsZXQgbm9ybXMgPSBbXTsgLy8gMyBsb25nIGZsb2F0XHJcbiAgICBsZXQgdXZzID0gW107IC8vIDIgbG9uZyBmbG9hdFxyXG4gICAgbGV0IGZhY2VzID0gW107IC8vIDkgbG9uZyBpbnRzLCB1MTYncyBzaG91bGQgc3VmZmljZS5cclxuICAgIC8vIG5vdGUgOiB0aGlzIGlzIHZlcnkgaW5lZmZpY2llbnQsIGJ1dCBpdCdsbCBoYXZlIHRvIGRvIGZvciBub3cuLi5cclxuICAgIGNvbnN0IGtleXdvcmRSRSA9IC8oXFx3KikoPzogKSooLiopLztcclxuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV0udHJpbSgpO1xyXG4gICAgICAgIC8vIGZpbHRlciBvdXQgY29tbWVudHNcclxuICAgICAgICBpZiAobGluZSA9PT0gXCJcIiB8fCBsaW5lLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtID0ga2V5d29yZFJFLmV4ZWMobGluZSk7XHJcbiAgICAgICAgaWYgKCFtKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBbLCBrZXl3b3JkLCB1bnBhcnNlZEFyZ3NdID0gbTtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTtcclxuICAgICAgICBzd2l0Y2ggKGtleXdvcmQpIHtcclxuICAgICAgICAgICAgY2FzZSBcInZcIjpcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocGFyc2VGbG9hdChwYXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInZuXCI6XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBub3Jtcy5wdXNoKHBhcnNlRmxvYXQocGFydCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2dFwiOlxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXZzLnB1c2gocGFyc2VGbG9hdChwYXJ0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImZcIjpcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgUHJvY2Vzc09iakZhY2UocGFydHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuaGFuZGxlZCBrZXl3b3JkOlwiLCBrZXl3b3JkKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIm51bWJlciBvZiB2ZXJ0aWNlczogXCIgKyB2ZXJ0cy5sZW5ndGggLyAzKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwibnVtYmVyIG9mIGZhY2VzOiBcIiArIGZhY2VzLmxlbmd0aCAvIDMpO1xyXG4gICAgLy8gY29uc29sZS5sb2coXCJudW1iZXIgb2YgdXZzOiBcIiArIHV2cy5sZW5ndGggLyAyKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKFwibnVtYmVyIG9mIG5vcm1zOiBcIiArIG5vcm1zLmxlbmd0aCAvIDMpO1xyXG4gICAgbGV0IG1lc2ggPSBSZW5kZXJhYmxlLmZyb21EYXRhKHZlcnRzLCBub3JtcywgdXZzLCBmYWNlcyk7XHJcbiAgICByZXR1cm4gbWVzaDtcclxufVxyXG4vLyBOT1RFOiBmb3Igbm93LCB1diBhbmQgbm9ybWFscyBhcmUgY29tcGxldGVseSBpZ25vcmVkISEhXHJcbi8vIHdlIGFzc3VtZSB0aGUgaW5kaWNlcyBhcmUgdGhlIHNhbWUgYWxzIHRoZSB2ZXJ0aWNlcyEhIVxyXG4vLyB2ZXJib3NlIHdheSBvZiBwcm9jZXNzaW5nIG9uZSBzaW5nbGUgdmVydGV4L25vcm1hbC91diBjb21iaW5hdGlvbiBpbiBhIGZhY2UuXHJcbmZ1bmN0aW9uIFByb2Nlc3NPYmpGYWNlVmVydGV4KHBhcnQpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBkYXRhIGFsd2F5cyBoYXMgbGVuZ3RoOiAzXHJcbiAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgLy8gY3V0IHN0cmluZyBhcGFydCBhbmQgcHJvY2VzcyBpdFxyXG4gICAgbGV0IHN1YnBhcnRzID0gcGFydC5zcGxpdChcIi9cIik7XHJcbiAgICBpZiAoc3VicGFydHMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICBkYXRhLnB1c2gocGFyc2VJbnQoc3VicGFydHNbMF0pIC0gMSk7XHJcbiAgICAgICAgLy8gZGF0YS5wdXNoKDApO1xyXG4gICAgICAgIC8vIGRhdGEucHVzaCgwKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN1YnBhcnRzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgZGF0YS5wdXNoKHBhcnNlSW50KHN1YnBhcnRzWzBdKSAtIDEpO1xyXG4gICAgICAgIC8vIGRhdGEucHVzaChwYXJzZUludChzdWJwYXJ0c1sxXSktMSk7XHJcbiAgICAgICAgLy8gZGF0YS5wdXNoKHBhcnNlSW50KHN1YnBhcnRzWzJdKS0xKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IFwiaW52YWxpZCBmYWNlIGZvdW5kIHdoZW4gcHJvY2Vzc2luZ1wiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuLy8gcHJvY2VzcyBhIGZhY2UgZW50cnkgaW4gYW4gb2JqIGZpbGVcclxuZnVuY3Rpb24gUHJvY2Vzc09iakZhY2UocGFydHMpIHtcclxuICAgIGxldCBkYXRhID0gW107XHJcbiAgICBpZiAocGFydHMubGVuZ3RoID09IDQpIHtcclxuICAgICAgICAvLyBpIGRvbnQgd2FudCB0byBkZWFsIHdpdGggcXVhZHMgZm9yIG5vdywgY3JlYXRlIDIgZmFjZXMgZnJvbSBhIHF1YWRcclxuICAgICAgICBsZXQgYSA9IFByb2Nlc3NPYmpGYWNlVmVydGV4KHBhcnRzWzBdKTtcclxuICAgICAgICBsZXQgYiA9IFByb2Nlc3NPYmpGYWNlVmVydGV4KHBhcnRzWzFdKTtcclxuICAgICAgICBsZXQgYyA9IFByb2Nlc3NPYmpGYWNlVmVydGV4KHBhcnRzWzJdKTtcclxuICAgICAgICBsZXQgZCA9IFByb2Nlc3NPYmpGYWNlVmVydGV4KHBhcnRzWzNdKTtcclxuICAgICAgICBkYXRhLnB1c2goLi4uYSwgLi4uYiwgLi4uYywgLi4uYSwgLi4uYywgLi4uZCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT0gMykge1xyXG4gICAgICAgIC8vIGFzIG5vcm1hbFxyXG4gICAgICAgIGxldCBhID0gUHJvY2Vzc09iakZhY2VWZXJ0ZXgocGFydHNbMF0pO1xyXG4gICAgICAgIGxldCBiID0gUHJvY2Vzc09iakZhY2VWZXJ0ZXgocGFydHNbMV0pO1xyXG4gICAgICAgIGxldCBjID0gUHJvY2Vzc09iakZhY2VWZXJ0ZXgocGFydHNbMl0pO1xyXG4gICAgICAgIGRhdGEucHVzaCguLi5hLCAuLi5iLCAuLi5jKTtcclxuICAgIH1cclxuICAgIC8vIGRhdGEgYWx3YXlzIGhhcyBsZW5ndGggOSBvciAxOFxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuIiwiLy8gbmFtZTogICAgc3RhdGlzdGljcy50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogZnVuY3Rpb25hbGl0eSBhbmQgZG9jdW1lbnRhdGlvbiBvZiB2YXJpYW5jZSxcclxuLy8gICAgICAgICAgY292YXJpYW5jZSwgZWlnZW4gdmVjdG9ycywgbGVhc3Qgc3F1YXJlcywgYW5kIG90aGVyXHJcbi8vICAgICAgICAgIHN0YXRpc3RpY2FsIG9wZXJhdGlvbnMuXHJcbi8vIHNvdXJjZTogIGJlZW4gYSB3aGlsZSBzaW5jZSBJIGRpZCB0aGlzLFxyXG4vLyAgICAgICAgICBodHRwczovL2RhdGFzY2llbmNlcGx1cy5jb20vdW5kZXJzdGFuZGluZy10aGUtY292YXJpYW5jZS1tYXRyaXgvXHJcbi8vICAgICAgICAgIGh0dHBzOi8vd2lraS5wYXRobWluZC5jb20vZWlnZW52ZWN0b3JcclxuLy8gICAgICAgICAgdXNlZCB0byBtYWtlIHN1cmUgdGhlIGJhc2ljcyBhcmUgY29ycmVjdCA6KS5cclxuLy8gbm90ZXM6ICAgV2hhdHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhIFByaW5jaXBhbCBDb21wb25lbnQgYW5kIGFuIEVpZ2VuIHZlY3Rvcj9cclxuLy8gICAgICAgICAgXCJCZWNhdXNlIGVpZ2VudmVjdG9ycyB0cmFjZSB0aGUgcHJpbmNpcGFsIGxpbmVzIG9mIGZvcmNlLCBhbmQgdGhlIGF4ZXMgb2YgZ3JlYXRlc3QgdmFyaWFuY2UgYW5kIGNvdmFyaWFuY2UgaWxsdXN0cmF0ZSB3aGVyZSB0aGUgZGF0YSBpcyBtb3N0IHN1c2NlcHRpYmxlIHRvIGNoYW5nZS5cIlxyXG5pbXBvcnQgeyBGbG9hdE1hdHJpeCB9IGZyb20gXCIuLi9kYXRhL2Zsb2F0LW1hdHJpeFwiO1xyXG5leHBvcnQgY2xhc3MgU3RhdCB7XHJcbiAgICAvLyBjYWxjdWxhdGUgc3VtXHJcbiAgICBzdGF0aWMgc3VtKHgpIHtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtICs9IHhbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICB9XHJcbiAgICAvLyBjYWxjdWxhdGUgYXZlcmFnZVxyXG4gICAgc3RhdGljIG1lYW4oeCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN1bSh4KSAvIHgubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLy8gY2FsY3VsYXRlIHZhcmlhbmNlXHJcbiAgICBzdGF0aWMgdmFyaWFuY2UoeCkge1xyXG4gICAgICAgIC8vz4NeMnggPSAoMS9u4oiSMSkgKiBu4oiRaT0xICh4W2ldIOKAkyB4QXZyKV4yXHJcbiAgICAgICAgbGV0IG4gPSB4Lmxlbmd0aDtcclxuICAgICAgICBsZXQgYXZyID0gdGhpcy5tZWFuKHgpO1xyXG4gICAgICAgIGxldCBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdygoeFtpXSAtIGF2ciksIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtIC8gKG4gLSAxKTtcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uXHJcbiAgICBzdGF0aWMgZGV2aWF0aW9uKHgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy52YXJpYW5jZSh4KSwgMC41KTtcclxuICAgIH1cclxuICAgIC8vIGNhbGN1bGF0ZSBjb3ZhcmlhbmNlXHJcbiAgICBzdGF0aWMgY292YXJpYW5jZSh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHgubGVuZ3RoICE9IHkubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBcInRoaXMgaXMgbm90IGhvdyBjb3ZhcmlhbmNlIHdvcmtzLi4uXCI7XHJcbiAgICAgICAgbGV0IG4gPSB4Lmxlbmd0aDtcclxuICAgICAgICBsZXQgeEF2ciA9IHRoaXMubWVhbih4KTtcclxuICAgICAgICBsZXQgeUF2ciA9IHRoaXMubWVhbih5KTtcclxuICAgICAgICBsZXQgc3VtID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gKz0gKHhbaV0gLSB4QXZyKSAqICh5W2ldIC0geUF2cik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdW0gLyAobiAtIDEpOyAvLyBsb3Npbmcgb25lIGRlZ3JlZSBvZiBmcmVlZG9tXHJcbiAgICB9XHJcbiAgICAvLyBjYWxjdWxhdGUgdmFyaWFuY2UgLyBjb3ZhcmlhbmNlIG1hdHJpeFxyXG4gICAgc3RhdGljIGNvdihtYXRyaXgpIHtcclxuICAgICAgICBsZXQgc2l6ZSA9IG1hdHJpeC5fd2lkdGg7XHJcbiAgICAgICAgbGV0IGNvdiA9IG5ldyBGbG9hdE1hdHJpeChzaXplLCBzaXplKTtcclxuICAgICAgICBsZXQgY29sdW1ucyA9IEFycmF5KHNpemUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbnNbaV0gPSBtYXRyaXguZ2V0Q29sdW1uKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYXRyaXggaXMgc3ltbWVydGljYWwsIHNvIG9ubHkgcnVuIHRocm91Z2ggb25lIGhhbGZcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IHNpemU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5jb3ZhcmlhbmNlKGNvbHVtbnNbaV0sIGNvbHVtbnNbal0pO1xyXG4gICAgICAgICAgICAgICAgY292LnNldChpLCBqLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb3Yuc2V0KGosIGksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY292O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVpZyhBKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSB0aGlzLnN2ZChBKTtcclxuICAgICAgICByZXR1cm4gW3Jlc3VsdHNbMV0sIHJlc3VsdHNbMl1dO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW5nbGUgVmFsdWUgRGVjb21wb3NpdGlvbi5cclxuICAgICAqIENhbiBiZSB1c2VkIGZvciBFaWdlbiBWYWx1ZSBEZWNvbXBvc2l0aW9uXHJcbiAgICAgKiBmcm9tIEcuIEguIEdvbHViIGFuZCBDLiBSZWluc2NoLCBOdW1lci4gTWF0aC4gMTQsIDQwMy00MjAgKDE5NzApLlxyXG4gICAgICogVGFrZW4gZnJvbSBudW1lcmljLmpzLiBub3QgeWV0IGNsZWFuZWQgJiBvcHRpbWl6ZWQuXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW5ndWxhcl92YWx1ZV9kZWNvbXBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gIHtGbG9hdE1hdHJpeH0gQSBtYXRyaXggdG8gZGVjb21wb3NlLCBzdWNoIGFzIGEgY292YXJpYW5jZSBtYXRyaXhcclxuICAgICAqIEByZXR1cm5zIFtVLCDiiJEsIFZdXHJcbiAgICAgKiBVIC0+IGR1cmluZyBFVkQsIHRoZXNlIGFyZSB0aGUgZWlnZW4gdmVjdG9ycyBvZiBBIHRyYW5zcG9zZWQsIGlmIGltIG5vdCBtaXN0YWtlblxyXG4gICAgICog4oiRIC0+IGR1cmluZyBFVkQsIHRoaXMgYXJlIHRoZSBlaWdlbiB2YWx1ZXNcclxuICAgICAqIFYgLT4gZHVyaW5nIEVWRCwgdGhlIGNvbHVtbnMgYXJlIGVpZ2VuIHZlY3RvcnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHN2ZChBKSB7XHJcbiAgICAgICAgdmFyIHByZWMgPSBNYXRoLnBvdygyLCAtNTIpOyAvLyBhc3N1bWVzIGRvdWJsZSBwcmVjXHJcbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IDFlLTY0IC8gcHJlYztcclxuICAgICAgICB2YXIgaXRtYXggPSA1MDtcclxuICAgICAgICB2YXIgYyA9IDA7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICB2YXIgayA9IDA7XHJcbiAgICAgICAgdmFyIGwgPSAwO1xyXG4gICAgICAgIHZhciB1ID0gQS5jbG9uZSgpLnRvTmF0aXZlKCk7XHJcbiAgICAgICAgdmFyIG0gPSB1Lmxlbmd0aDtcclxuICAgICAgICB2YXIgbiA9IHVbMF0ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChtIDwgbilcclxuICAgICAgICAgICAgdGhyb3cgXCJOZWVkIG1vcmUgcm93cyB0aGFuIGNvbHVtbnNcIjtcclxuICAgICAgICB2YXIgZSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICB2YXIgcSA9IG5ldyBBcnJheShuKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKVxyXG4gICAgICAgICAgICBlW2ldID0gcVtpXSA9IDAuMDtcclxuICAgICAgICB2YXIgdiA9IHJlcChbbiwgbl0sIDApO1xyXG4gICAgICAgIGZ1bmN0aW9uIHB5dGhhZyhhLCBiKSB7XHJcbiAgICAgICAgICAgIGEgPSBNYXRoLmFicyhhKTtcclxuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICBpZiAoYSA+IGIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSAqIE1hdGguc3FydCgxLjAgKyAoYiAqIGIpIC8gYSAvIGEpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChiID09IDAuMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgICAgICByZXR1cm4gYiAqIE1hdGguc3FydCgxLjAgKyAoYSAqIGEpIC8gYiAvIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlcCBmdW5jdGlvbiwgW0pGXSA6IGRvbnQga25vdyB3aGF0IHRoaXMgZG9lcyBleGFjdGx5Li4uXHJcbiAgICAgICAgZnVuY3Rpb24gcmVwKHMsIHYsIGsgPSAwKSB7XHJcbiAgICAgICAgICAgIGxldCBuID0gc1trXTtcclxuICAgICAgICAgICAgbGV0IHJldCA9IEFycmF5KG4pO1xyXG4gICAgICAgICAgICBsZXQgaTtcclxuICAgICAgICAgICAgaWYgKGsgPT09IHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2kgKyAxXSA9IHY7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gdjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldFswXSA9IHY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gcmVwKHMsIHYsIGsgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0hvdXNlaG9sZGVyJ3MgcmVkdWN0aW9uIHRvIGJpZGlhZ29uYWwgZm9ybVxyXG4gICAgICAgIHZhciBmID0gMC4wO1xyXG4gICAgICAgIHZhciBnID0gMC4wO1xyXG4gICAgICAgIHZhciBoID0gMC4wO1xyXG4gICAgICAgIHZhciB4ID0gMC4wO1xyXG4gICAgICAgIHZhciB5ID0gMC4wO1xyXG4gICAgICAgIHZhciB6ID0gMC4wO1xyXG4gICAgICAgIHZhciBzID0gMC4wO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgZVtpXSA9IGc7XHJcbiAgICAgICAgICAgIHMgPSAwLjA7XHJcbiAgICAgICAgICAgIGwgPSBpICsgMTtcclxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8IG07IGorKylcclxuICAgICAgICAgICAgICAgIHMgKz0gdVtqXVtpXSAqIHVbal1baV07XHJcbiAgICAgICAgICAgIGlmIChzIDw9IHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgIGcgPSAwLjA7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZiA9IHVbaV1baV07XHJcbiAgICAgICAgICAgICAgICBnID0gTWF0aC5zcXJ0KHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPj0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAtZztcclxuICAgICAgICAgICAgICAgIGggPSBmICogZyAtIHM7XHJcbiAgICAgICAgICAgICAgICB1W2ldW2ldID0gZiAtIGc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBpOyBrIDwgbTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHVba11baV0gKiB1W2tdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBzIC8gaDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBpOyBrIDwgbTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1W2tdW2pdICs9IGYgKiB1W2tdW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHFbaV0gPSBnO1xyXG4gICAgICAgICAgICBzID0gMC4wO1xyXG4gICAgICAgICAgICBmb3IgKGogPSBsOyBqIDwgbjsgaisrKVxyXG4gICAgICAgICAgICAgICAgcyA9IHMgKyB1W2ldW2pdICogdVtpXVtqXTtcclxuICAgICAgICAgICAgaWYgKHMgPD0gdG9sZXJhbmNlKVxyXG4gICAgICAgICAgICAgICAgZyA9IDAuMDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmID0gdVtpXVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBnID0gTWF0aC5zcXJ0KHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPj0gMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAtZztcclxuICAgICAgICAgICAgICAgIGggPSBmICogZyAtIHM7XHJcbiAgICAgICAgICAgICAgICB1W2ldW2kgKyAxXSA9IGYgLSBnO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gbDsgaiA8IG47IGorKylcclxuICAgICAgICAgICAgICAgICAgICBlW2pdID0gdVtpXVtqXSAvIGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDwgbTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBsOyBrIDwgbjsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHVbal1ba10gKiB1W2ldW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IGw7IGsgPCBuOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVbal1ba10gKz0gcyAqIGVba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeSA9IE1hdGguYWJzKHFbaV0pICsgTWF0aC5hYnMoZVtpXSk7XHJcbiAgICAgICAgICAgIGlmICh5ID4geClcclxuICAgICAgICAgICAgICAgIHggPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY2N1bXVsYXRpb24gb2YgcmlnaHQgaGFuZCBndHJhbnNmb3JtYXRpb25zXHJcbiAgICAgICAgZm9yIChpID0gbiAtIDE7IGkgIT0gLTE7IGkgKz0gLTEpIHtcclxuICAgICAgICAgICAgaWYgKGcgIT0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gZyAqIHVbaV1baSArIDFdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gbDsgaiA8IG47IGorKylcclxuICAgICAgICAgICAgICAgICAgICB2W2pdW2ldID0gdVtpXVtqXSAvIGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBsOyBrIDwgbjsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHVbaV1ba10gKiB2W2tdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IGw7IGsgPCBuOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZba11bal0gKz0gcyAqIHZba11baV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChqID0gbDsgaiA8IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgdltpXVtqXSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2W2pdW2ldID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2W2ldW2ldID0gMTtcclxuICAgICAgICAgICAgZyA9IGVbaV07XHJcbiAgICAgICAgICAgIGwgPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhY2N1bXVsYXRpb24gb2YgbGVmdCBoYW5kIHRyYW5zZm9ybWF0aW9uc1xyXG4gICAgICAgIGZvciAoaSA9IG4gLSAxOyBpICE9IC0xOyBpICs9IC0xKSB7XHJcbiAgICAgICAgICAgIGwgPSBpICsgMTtcclxuICAgICAgICAgICAgZyA9IHFbaV07XHJcbiAgICAgICAgICAgIGZvciAoaiA9IGw7IGogPCBuOyBqKyspXHJcbiAgICAgICAgICAgICAgICB1W2ldW2pdID0gMDtcclxuICAgICAgICAgICAgaWYgKGcgIT0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICBoID0gdVtpXVtpXSAqIGc7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSBsOyBqIDwgbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBsOyBrIDwgbTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzICs9IHVba11baV0gKiB1W2tdW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBzIC8gaDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSBpOyBrIDwgbTsgaysrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1W2tdW2pdICs9IGYgKiB1W2tdW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8IG07IGorKylcclxuICAgICAgICAgICAgICAgICAgICB1W2pdW2ldID0gdVtqXVtpXSAvIGc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8IG07IGorKylcclxuICAgICAgICAgICAgICAgICAgICB1W2pdW2ldID0gMDtcclxuICAgICAgICAgICAgdVtpXVtpXSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkaWFnb25hbGl6YXRpb24gb2YgdGhlIGJpZGlhZ29uYWwgZm9ybVxyXG4gICAgICAgIHByZWMgPSBwcmVjICogeDtcclxuICAgICAgICBmb3IgKGsgPSBuIC0gMTsgayAhPSAtMTsgayArPSAtMSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpdGVyYXRpb24gPSAwOyBpdGVyYXRpb24gPCBpdG1heDsgaXRlcmF0aW9uKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIHRlc3QgZiBzcGxpdHRpbmdcclxuICAgICAgICAgICAgICAgIHZhciB0ZXN0X2NvbnZlcmdlbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGwgPSBrOyBsICE9IC0xOyBsICs9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGVbbF0pIDw9IHByZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdF9jb252ZXJnZW5jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocVtsIC0gMV0pIDw9IHByZWMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0X2NvbnZlcmdlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuY2VsbGF0aW9uIG9mIGVbbF0gaWYgbD4wXHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IDAuMDtcclxuICAgICAgICAgICAgICAgICAgICBzID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsMSA9IGwgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGw7IGkgPCBrICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBzICogZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZVtpXSA9IGMgKiBlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZikgPD0gcHJlYylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnID0gcVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHB5dGhhZyhmLCBnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcVtpXSA9IGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSBnIC8gaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IC1mIC8gaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHVbal1bbDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9IHVbal1baV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1W2pdW2wxXSA9IHkgKiBjICsgeiAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1W2pdW2ldID0gLXkgKiBzICsgeiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGYgY29udmVyZ2VuY2VcclxuICAgICAgICAgICAgICAgIHogPSBxW2tdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGwgPT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29udmVyZ2VuY2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeiA8IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Fba10gaXMgbWFkZSBub24tbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgcVtrXSA9IC16O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdltqXVtrXSA9IC12W2pdW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy9icmVhayBvdXQgb2YgaXRlcmF0aW9uIGxvb3AgYW5kIG1vdmUgb24gdG8gbmV4dCBrIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0aW9uID49IGl0bWF4IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkVycm9yOiBubyBjb252ZXJnZW5jZS5cIjtcclxuICAgICAgICAgICAgICAgIC8vIHNoaWZ0IGZyb20gYm90dG9tIDJ4MiBtaW5vclxyXG4gICAgICAgICAgICAgICAgeCA9IHFbbF07XHJcbiAgICAgICAgICAgICAgICB5ID0gcVtrIC0gMV07XHJcbiAgICAgICAgICAgICAgICBnID0gZVtrIC0gMV07XHJcbiAgICAgICAgICAgICAgICBoID0gZVtrXTtcclxuICAgICAgICAgICAgICAgIGYgPSAoKHkgLSB6KSAqICh5ICsgeikgKyAoZyAtIGgpICogKGcgKyBoKSkgLyAoMi4wICogaCAqIHkpO1xyXG4gICAgICAgICAgICAgICAgZyA9IHB5dGhhZyhmLCAxLjApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPCAwLjApXHJcbiAgICAgICAgICAgICAgICAgICAgZiA9ICgoeCAtIHopICogKHggKyB6KSArIGggKiAoeSAvIChmIC0gZykgLSBoKSkgLyB4O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGYgPSAoKHggLSB6KSAqICh4ICsgeikgKyBoICogKHkgLyAoZiArIGcpIC0gaCkpIC8geDtcclxuICAgICAgICAgICAgICAgIC8vIG5leHQgUVIgdHJhbnNmb3JtYXRpb25cclxuICAgICAgICAgICAgICAgIGMgPSAxLjA7XHJcbiAgICAgICAgICAgICAgICBzID0gMS4wO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gbCArIDE7IGkgPCBrICsgMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZyA9IGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHFbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IHMgKiBnO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSBjICogZztcclxuICAgICAgICAgICAgICAgICAgICB6ID0gcHl0aGFnKGYsIGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVbaSAtIDFdID0gejtcclxuICAgICAgICAgICAgICAgICAgICBjID0gZiAvIHo7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IGggLyB6O1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSB4ICogYyArIGcgKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgIGcgPSAteCAqIHMgKyBnICogYztcclxuICAgICAgICAgICAgICAgICAgICBoID0geSAqIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHZbal1baSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6ID0gdltqXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdltqXVtpIC0gMV0gPSB4ICogYyArIHogKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2W2pdW2ldID0gLXggKiBzICsgeiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHogPSBweXRoYWcoZiwgaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcVtpIC0gMV0gPSB6O1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBmIC8gejtcclxuICAgICAgICAgICAgICAgICAgICBzID0gaCAvIHo7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGMgKiBnICsgcyAqIHk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IC1zICogZyArIGMgKiB5O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IHVbal1baSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB6ID0gdVtqXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdVtqXVtpIC0gMV0gPSB5ICogYyArIHogKiBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1W2pdW2ldID0gLXkgKiBzICsgeiAqIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZVtsXSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIGVba10gPSBmO1xyXG4gICAgICAgICAgICAgICAgcVtrXSA9IHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChxW2ldIDwgcHJlYylcclxuICAgICAgICAgICAgICAgIHFbaV0gPSAwO1xyXG4gICAgICAgIC8vc29ydCBlaWdlbnZhbHVlc1xyXG4gICAgICAgIHZhciB0ZW1wO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocVtqXSA8IHFbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gcVtqXTtcclxuICAgICAgICAgICAgICAgICAgICBxW2pdID0gcVtpXTtcclxuICAgICAgICAgICAgICAgICAgICBxW2ldID0gYztcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdVtrXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdVtrXVtpXSA9IHVba11bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVba11bal0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgdi5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gdltrXVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdltrXVtpXSA9IHZba11bal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZba11bal0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpID0gajtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW0Zsb2F0TWF0cml4LmZyb21OYXRpdmUodSksIG5ldyBGbG9hdDMyQXJyYXkocSksIEZsb2F0TWF0cml4LmZyb21OYXRpdmUodildO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIG5hbWU6ICAgIHBsYW5lLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBkZWZpbml0aW9uIG9mIGEgM2QgcGxhbmUuXHJcbi8vIHRvZG86ICAgIHR1cm4gQ2VudGVyLCBJaGF0LCBKaGF0LCBLaGF0IGNvbnN0cnVjdGlvbiB0byBhbiBhY3R1YWwgbWF0cml4XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgU3RhdCB9IGZyb20gXCIuLi9tYXRoL3N0YXRpc3RpY3NcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBDb25zdCB9IGZyb20gXCIuLi9tYXRoL2NvbnN0XCI7XHJcbmV4cG9ydCBjbGFzcyBQbGFuZSB7XHJcbiAgICAvLyBfaW52ZXJzZSE6IE1hdHJpeDQ7IC8vIE5PVEU6IGN1cnJlbnRseSBpbSBub3QgY2FjaGluZyB0aGlzLiBNaWdodCBiZSBuZWVkZWQuXHJcbiAgICAvLyBOT1RFIDogZCBpcyBub3QgcmVhbGx5IG5lZWRlZCBhbnltb3JlLi4uXHJcbiAgICBjb25zdHJ1Y3RvcihtKSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUE4oY2VudGVyLCBub3JtYWwpIHtcclxuICAgICAgICBsZXQgY3Jvc3MgPSBub3JtYWwuY3Jvc3MoVmVjdG9yMy51bml0WCgpKTtcclxuICAgICAgICBpZiAoY3Jvc3MubGVuZ3RoKCkgPCBDb25zdC5UT0xFUkFOQ0UpIHtcclxuICAgICAgICAgICAgY3Jvc3MgPSBub3JtYWwuY3Jvc3MoVmVjdG9yMy51bml0WSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGloYXQgPSBjcm9zcy5ub3JtYWxpemUoKTtcclxuICAgICAgICBsZXQgamhhdCA9IG5vcm1hbC5jcm9zcyhpaGF0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICBsZXQgbWF0ID0gUGxhbmUucGxhbmVNYXRyaXhGcm9tVmVjcyhjZW50ZXIsIGloYXQsIGpoYXQsIG5vcm1hbCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFuZShtYXQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21QVlYoYSwgdjEsIHYyKSB7XHJcbiAgICAgICAgLy8gVE9ETyBjaGVjayBpZiB3ZSBzdGlsbCBuZWVkIHRoaXMgLTEgdGhpbmdcclxuICAgICAgICBsZXQga2hhdCA9IHYxLmNsb25lKCkuY3Jvc3ModjIpLm5vcm1hbGl6ZSgpOyAvLy5zY2FsZSgtMSk7XHJcbiAgICAgICAgbGV0IGNlbnRlciA9IGEuY2xvbmUoKTtcclxuICAgICAgICBsZXQgaWhhdCA9IHYxLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGxldCBqaGF0ID0gdjEuY2xvbmUoKS5jcm9zcyhraGF0KTtcclxuICAgICAgICBsZXQgbWF0ID0gUGxhbmUucGxhbmVNYXRyaXhGcm9tVmVjcyhjZW50ZXIsIGloYXQsIGpoYXQsIGtoYXQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGxhbmUobWF0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tM3B0KGEsIGIsIGMpIHtcclxuICAgICAgICBsZXQgdjEgPSBiLmNsb25lKCkuc3ViKGEpO1xyXG4gICAgICAgIGxldCB2MiA9IGMuY2xvbmUoKS5zdWIoYSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVBWVihhLCB2MSwgdjIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIFdvcmxkWFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIFBsYW5lLmZyb20zcHQoVmVjdG9yMy56ZXJvKCksIFZlY3RvcjMudW5pdFgoKSwgVmVjdG9yMy51bml0WSgpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBXb3JsZFlaKCkge1xyXG4gICAgICAgIHJldHVybiBQbGFuZS5mcm9tM3B0KFZlY3RvcjMuemVybygpLCBWZWN0b3IzLnVuaXRZKCksIFZlY3RvcjMudW5pdFooKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgV29ybGRYWigpIHtcclxuICAgICAgICByZXR1cm4gUGxhbmUuZnJvbTNwdChWZWN0b3IzLnplcm8oKSwgVmVjdG9yMy51bml0WCgpLCBWZWN0b3IzLnVuaXRaKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21MZWFzdFNxdWFyZXMocHRzKSB7XHJcbiAgICAgICAgbGV0IG1lYW4gPSBwdHMubWVhbigpO1xyXG4gICAgICAgIGxldCBjb3YgPSBTdGF0LmNvdihwdHMpO1xyXG4gICAgICAgIGxldCBbZWlnVmFsdWVzLCBlaWdWZWN0b3JzXSA9IFN0YXQuZWlnKGNvdik7XHJcbiAgICAgICAgY29uc29sZS5sb2coZWlnVmFsdWVzKTtcclxuICAgICAgICBsZXQgYmlnZ2VzdEVpZ2VuVmVjdG9yID0gVmVjdG9yMy5mcm9tQXJyYXkoZWlnVmVjdG9ycy5nZXRDb2x1bW4oMCkpO1xyXG4gICAgICAgIGxldCBzZWNvbmRCaWdnZXN0RWlnZW5WZWN0b3IgPSBWZWN0b3IzLmZyb21BcnJheShlaWdWZWN0b3JzLmdldENvbHVtbigxKSk7XHJcbiAgICAgICAgcmV0dXJuIFBsYW5lLmZyb21QVlYobWVhbiwgYmlnZ2VzdEVpZ2VuVmVjdG9yLCBzZWNvbmRCaWdnZXN0RWlnZW5WZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21YWUxlYXN0U3F1YXJlcyhwdHMpIHtcclxuICAgICAgICAvLyBxdWl0ZSBzcGVjaWZpYywgYnV0IHRoaXMgd2FzIG5lZWRlZC5cclxuICAgICAgICBsZXQgbWVhbiA9IHB0cy5tZWFuKCk7XHJcbiAgICAgICAgcmV0dXJuIFBsYW5lLldvcmxkWFkoKS50cmFuc2Zvcm0oTWF0cml4NC5uZXdUcmFuc2xhdGlvbihtZWFuLngsIG1lYW4ueSwgbWVhbi56KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcGxhbmVNYXRyaXhGcm9tVmVjcyhjLCBpLCBqLCBrKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXg0KFtpLngsIGkueSwgaS56LCAwLCBqLngsIGoueSwgai56LCAwLCBrLngsIGsueSwgay56LCAwLCBjLngsIGMueSwgYy56LCAxXSk7XHJcbiAgICB9XHJcbiAgICBnZXQgaWhhdCgpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMy5mcm9tQXJyYXkodGhpcy5fbWF0cml4LmdldFJvdygwKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgamhhdCgpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMy5mcm9tQXJyYXkodGhpcy5fbWF0cml4LmdldFJvdygxKSk7XHJcbiAgICB9XHJcbiAgICBnZXQga2hhdCgpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMy5mcm9tQXJyYXkodGhpcy5fbWF0cml4LmdldFJvdygyKSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiBWZWN0b3IzLmZyb21BcnJheSh0aGlzLl9tYXRyaXguZ2V0Um93KDMpKTtcclxuICAgIH1cclxuICAgIGdldCBtYXRyaXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5vcm1hbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5raGF0O1xyXG4gICAgfVxyXG4gICAgZ2V0IGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VzdFBvaW50KFZlY3RvcjMuemVybygpKVsxXTtcclxuICAgIH1cclxuICAgIHNldCBpaGF0KHYpIHtcclxuICAgICAgICB0aGlzLl9tYXRyaXguc2V0Um93KDAsIFt2LngsIHYueSwgdi56LCAwXSk7XHJcbiAgICB9XHJcbiAgICBzZXQgamhhdCh2KSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4LnNldFJvdygxLCBbdi54LCB2LnksIHYueiwgMF0pO1xyXG4gICAgfVxyXG4gICAgc2V0IGtoYXQodikge1xyXG4gICAgICAgIHRoaXMuX21hdHJpeC5zZXRSb3coMiwgW3YueCwgdi55LCB2LnosIDBdKTtcclxuICAgIH1cclxuICAgIHNldCBjZW50ZXIodikge1xyXG4gICAgICAgIHRoaXMuX21hdHJpeC5zZXRSb3coMywgW3YueCwgdi55LCB2LnosIDFdKTtcclxuICAgIH1cclxuICAgIHNldCBtYXRyaXgobSkge1xyXG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG07XHJcbiAgICB9XHJcbiAgICBnZXQgaW52ZXJzZSgpIHtcclxuICAgICAgICAvLyBUT0RPIENBQ0hFIElOVkVSU0UgTUFUUklYXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeC5pbnZlcnNlKCk7XHJcbiAgICB9XHJcbiAgICBzZXRQb3NpdGlvbih2ZWMpIHtcclxuICAgICAgICB0aGlzLmNlbnRlciA9IHZlYztcclxuICAgIH1cclxuICAgIHNldE5vcm1hbCh2ZWMpIHtcclxuICAgICAgICB0aGlzLmtoYXQgPSB2ZWM7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBsYW5lKHRoaXMuX21hdHJpeC5jbG9uZSgpKTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybShtKSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gdGhpcy5fbWF0cml4Lm11bHRpcGx5KG0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvKG9yaWdpbikge1xyXG4gICAgICAgIHRoaXMuY2VudGVyID0gb3JpZ2luO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gTk9URTogcHVsbGluZyBpcyBpbmVmZmljaWVudCBzaW5jZSBpIGRvIG5vdCBjYWNoZSB0aGUgaW52ZXJzZS5cclxuICAgIHB1bGxUb1BsYW5lKHApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnZlcnNlLm11bHRpcGx5VmVjdG9yKHApO1xyXG4gICAgfVxyXG4gICAgcHVzaFRvV29ybGQocCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC5tdWx0aXBseVZlY3RvcihwKTtcclxuICAgIH1cclxuICAgIGNsb3Nlc3RQb2ludChwKSB7XHJcbiAgICAgICAgbGV0IHB1bGxlZCA9IHRoaXMucHVsbFRvUGxhbmUocCk7XHJcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gcHVsbGVkLno7XHJcbiAgICAgICAgcHVsbGVkLnogPSAwO1xyXG4gICAgICAgIGxldCB2ZWMgPSB0aGlzLnB1c2hUb1dvcmxkKHB1bGxlZCk7XHJcbiAgICAgICAgcmV0dXJuIFt2ZWMsIGRpc3RhbmNlXTtcclxuICAgIH1cclxuICAgIHJvdGF0ZVZlY3Rvcih2LCByYWRpYW5zKSB7XHJcbiAgICAgICAgbGV0IHB1bGxlZCA9IHRoaXMucHVsbFRvUGxhbmUodik7XHJcbiAgICAgICAgbGV0IHJvdGF0aW9uID0gTWF0cml4NC5uZXdBeGlzUm90YXRpb24odGhpcy5ub3JtYWwsIHJhZGlhbnMpO1xyXG4gICAgICAgIHB1bGxlZCA9IHJvdGF0aW9uLm11bHRpcGx5VmVjdG9yKHB1bGxlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaFRvV29ybGQocHVsbGVkKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBub3RlOiB0aGlzIHdvbnQgYWx3YXlzIHdvcmssIGJ1dCBpdCBkb2VzIGluIG1vc3QgY2FzZXNcclxuLy8gdG9kbzogaW1wbGVtZW50IHByb3BlciBoYXNodGFibGVcclxuZXhwb3J0IGNsYXNzIEhhc2hUYWJsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBzdHJpbmdpZnkoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGtleS50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLnNldCh0aGlzLnN0cmluZ2lmeShrZXkpLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oYXModGhpcy5zdHJpbmdpZnkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQodGhpcy5zdHJpbmdpZnkoa2V5KSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gbmFtZTogZ3JhcGgudHNcclxuLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IEhhbGZFZGdlIE1lc2ggaW4gM0QuXHJcbi8vIFRoaXMgZG9lcyBtZWFuIHRoYXQgdGhlIG9yZGVyIGFyb3VuZCBhIHZlcnRleCBpcyBub3Qgc3RhaWdodCBmb3J3YXJkLCBhbmQgbXVzdCBiZSBoYW5kbGVkIHVzaW5nIG5vcm1hbHMuXHJcbi8vIFRPRE9cclxuLy8gLSBncmFwaCBjbGVhblxyXG4vLyAtIGdyYXBoIGRlbGV0ZSB2ZXJ0XHJcbi8vIC0gdG8gbGluZSByZW5kZXJhYmxlXHJcbi8vIC0ga2VlcCB0cmFjayBvZiBmYWNlcywgZm9yIHF1aWNrIG1lc2hpZmljYXRpb25cclxuLy8gICAtIFRISVMgV0lMTCBTUEVFRCBVUCAnR0VUIEFMTCBGQUNFUyBUSFJFTUVORE9VU0xZLCBXSElDSCBXSUxMIFNQRUVEIFVQIFNVQkRJVklTT05TJ1xyXG4vLyAtIHJlbW92ZSBhbWJpZ3VpdHkgb2YgaGFsZmVkZ2VzICYgZWRnZXNcclxuLy8gICAtIGZpeCB0aGUgZmFjdCB0aGF0IHdlICdkb250JyByZWFsbGxseSB1c2UgaGFsZmVkZ2VzLCB3ZSBjb25zaXN0ZW50bHkgdXNlIHBhaXJzIG9mIHR3by5cclxuLy8gICAtIGFrYSwgdHdpbnMgYXJlIGltcGxpY2l0OiAwIC0+IDEgJiAxIC0+IDAgT1IgMjEgLT4gMjAgJiAyMCAtPiAyMVxyXG5pbXBvcnQgeyBIYXNoVGFibGUgfSBmcm9tIFwiLi4vZGF0YS9oYXNoLXRhYmxlXCI7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSBcIi4uL2dlby9wbGFuZVwiO1xyXG5pbXBvcnQgeyBDb25zdCB9IGZyb20gXCIuLi9tYXRoL2NvbnN0XCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gXCIuL21lc2hcIjtcclxuaW1wb3J0IHsgTWVzaFR5cGUsIFJlbmRlcmFibGUgfSBmcm9tIFwiLi9yZW5kZXItbWVzaFwiO1xyXG4vLyBGQUNFUyBNVVNUIEJFIENPTlZFWCwgT1IgQlVHUyBNSUdIVCBPQ0NVUiEhISFcclxuLy8gaW50ZXJmYWNlIEZhY2Uge1xyXG4vLyAgICBlZGdlOiBFZGdlSW5kZXgsXHJcbi8vIH1cclxuLy8gTk9URTogY3JlYXRlIGFuIGludGVyZmFjZSB3aGljaCBoaWRlcyB0aGUgRWRnZSwgVmVydCAmIEZhY2UgaW50ZXJmYWNlcy5cclxuLy8gTk9URTogaGFsZiBlZGdlIGlzIGltcGxpZWRcclxuZXhwb3J0IGNsYXNzIEdyYXBoIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudmVydHMgPSBbXTtcclxuICAgICAgICB0aGlzLmVkZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JhcGgoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTWVzaChtZXNoKSB7XHJcbiAgICAgICAgbGV0IGdyYXBoID0gR3JhcGgubmV3KCk7XHJcbiAgICAgICAgbGV0IG5vcm1hbHMgPSBtZXNoLmNhbGN1bGF0ZVZlcnRleE5vcm1hbHMoKTtcclxuICAgICAgICBtZXNoLnZlcnRzLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgZ3JhcGguYWRkVmVydCh2LCBub3JtYWxzW2ldKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgdHlwZSA9IG1lc2guZ2V0VHlwZSgpO1xyXG4gICAgICAgIGlmICh0eXBlID09IE1lc2hUeXBlLkludmFsaWQgfHwgdHlwZSA9PSBNZXNoVHlwZS5Qb2ludHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdyYXBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWFwID0gbmV3IEhhc2hUYWJsZSgpO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IG1lc2gubGlua3MuX3dpZHRoO1xyXG4gICAgICAgIG1lc2gubGlua3MuZm9yRWFjaFJvdygocm93LCBpKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggcGFpcnNcclxuICAgICAgICAgICAgLy8gTk9URTogdGhpcyBjYW4gYmUgZG9uZSB3YXkgZWFzaWVyIGJ5IGNyZWF0aW5nIDEgaGFsZiBlZGdlIHBlciBwYWlyXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlOZXh0ID0gKGkgKyAxKSAlIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgbGV0IGEgPSByb3dbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYiA9IHJvd1tpTmV4dF07XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhhLCBiKTtcclxuICAgICAgICAgICAgICAgIGlmIChhID09IC0xIHx8IGIgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlSWZOZXcoYSwgYik7XHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgbm9ybWFsID0gbm9ybWFsc1thXS5hZGQobm9ybWFsc1tiXSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiAobWFwLmhhcyhbYSwgYl0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJHT1QgSVQgQUxSRUFEWVwiKVxyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgLy8gZ3JhcGguYWRkRWRnZVdpdGhDdXN0b21Ob3JtYWwoYSwgYiwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgIC8vIG1hcC5zZXQoW2IsIGFdLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIGdyYXBoLmFkZEVkZ2UoYSwgYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZ3JhcGg7XHJcbiAgICB9XHJcbiAgICAvLyBnZW9tZXRyeSB0cmFpdFxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IHlldCBpbXBsZW1lbnRlZC4uLlwiKTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybShtYXRyaXgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHYgPSB0aGlzLnZlcnRzW2ldO1xyXG4gICAgICAgICAgICB2LnBvcyA9IG1hdHJpeC5tdWx0aXBseVZlY3Rvcih2LnBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVVRJTElUWVxyXG4gICAgcHJpbnQoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJncmFwaFwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGAke3RoaXMudmVydHMubGVuZ3RofSB2ZXJ0czogYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2ID0gdGhpcy52ZXJ0c1tpXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYHYoJHtpfSkgfCBlZGdlOiAke3YuZWRnZX0sIGRhdGE6ICR7di5wb3MudG9TdHJpbmcoKX0gbm9ybWFsOiAke3Yubm9ybWFsLnRvU3RyaW5nKCl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS1cIik7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCR7dGhpcy5lZGdlcy5sZW5ndGh9IGVkZ2VzOiAgYCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlID0gdGhpcy5lZGdlc1tpXTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYGUoJHtpfSkgfCB2ZXJ0OiAke2UudmVydH0sIHR3aW46ICR7ZS50d2lufSwgbmV4dDogJHtlLm5leHR9LCBkZWFkICR7ZS5kZWFkfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gQ09OVkVSVEVSU1xyXG4gICAgdG9NZXNoKCkge1xyXG4gICAgICAgIHJldHVybiBNZXNoLmZyb21HcmFwaCh0aGlzKTtcclxuICAgIH1cclxuICAgIHRvTGluZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1lc2gubmV3TGluZXModGhpcy5hbGxWZXJ0UG9zaXRpb25zKCksIHRoaXMuYWxsVW5pcXVlRWRnZVZlcnRzKCkpO1xyXG4gICAgfVxyXG4gICAgdG9SZW5kZXJhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiBSZW5kZXJhYmxlLmZyb21HcmFwaCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8vIHB1YmxpYyBnZXR0ZXJzXHJcbiAgICBhbGxOb3JtcygpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMudmVydHMuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2godi5ub3JtYWwpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgYWxsVmVydFBvc2l0aW9ucygpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMudmVydHMuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2godi5wb3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgYWxsVW5pcXVlRWRnZXMoKSB7XHJcbiAgICAgICAgbGV0IGVkZ2VzID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5lZGdlcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaTEgPSBpICogMjtcclxuICAgICAgICAgICAgbGV0IGkyID0gaSAqIDIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuZ2V0RWRnZShpMSk7XHJcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5nZXRFZGdlKGkyKTtcclxuICAgICAgICAgICAgaWYgKGEuZGVhZCB8fCBiLmRlYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVkZ2VzLnB1c2goaTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWRnZXM7XHJcbiAgICB9XHJcbiAgICBhbGxVbmlxdWVFZGdlVmVydHMoKSB7XHJcbiAgICAgICAgbGV0IGVkZ2VzID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5lZGdlcy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaTEgPSBpICogMjtcclxuICAgICAgICAgICAgbGV0IGkyID0gaSAqIDIgKyAxO1xyXG4gICAgICAgICAgICBsZXQgYSA9IHRoaXMuZ2V0RWRnZShpMSk7XHJcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5nZXRFZGdlKGkyKTtcclxuICAgICAgICAgICAgaWYgKGEuZGVhZCB8fCBiLmRlYWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVkZ2VzLnB1c2goYS52ZXJ0LCBiLnZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWRnZXM7XHJcbiAgICB9XHJcbiAgICBhbGxFZGdlVmVydHMoKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBbXTtcclxuICAgICAgICAvLyBsZXQgZWRnZXMgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpXHJcbiAgICAgICAgdGhpcy5lZGdlcy5mb3JFYWNoKChlLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlLmRlYWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGxldCBhID0gZS52ZXJ0O1xyXG4gICAgICAgICAgICBsZXQgYiA9IHRoaXMuZ2V0RWRnZShlLnR3aW4pLnZlcnQ7XHJcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGEpO1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICBhbGxWZXJ0TG9vcHMoKSB7XHJcbiAgICAgICAgdGhyb3cgXCJUT0RPXCI7XHJcbiAgICB9XHJcbiAgICBhbGxWZXJ0TG9vcHNBc0ludHMoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBzcGVlZCB0aGlzIHVwXHJcbiAgICAgICAgbGV0IGxvb3BzID0gW107XHJcbiAgICAgICAgbGV0IHVudmlzaXRlZCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLmVkZ2VzLmZvckVhY2goKGUsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGUuZGVhZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVudmlzaXRlZC5hZGQoaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5lZGdlcy5sZW5ndGg7IC8vIHdlIHdpbGwgbmV2ZXIgdmlzaXQgYW4gZWRnZSB0d2ljZSBpZiBhbGwgaXMgYWNjb3JkaW5nIHRvIHBsYW5cclxuICAgICAgICB3aGlsZSAodW52aXNpdGVkLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGxldCBsb29wID0gW107XHJcbiAgICAgICAgICAgIGxldCBlaSA9IHVudmlzaXRlZC5lbnRyaWVzKCkubmV4dCgpLnZhbHVlWzBdO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBlaTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPiBsaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMucHJpbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcInRvcG9sb2d5IGlzIGNvcnJ1cHQhXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgICAgICBsZXQgZSA9IHRoaXMuZ2V0RWRnZShlaSk7XHJcbiAgICAgICAgICAgICAgICB1bnZpc2l0ZWQuZGVsZXRlKGVpKTtcclxuICAgICAgICAgICAgICAgIGxvb3AucHVzaChlLnZlcnQpO1xyXG4gICAgICAgICAgICAgICAgZWkgPSBlLm5leHQ7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKGVpICE9IHN0YXJ0KTtcclxuICAgICAgICAgICAgbG9vcHMucHVzaChsb29wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvb3BzO1xyXG4gICAgfVxyXG4gICAgZ2V0TG9vcChlaSkge1xyXG4gICAgICAgIGxldCBsb29wID0gW107XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5lZGdlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gZWk7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoaSA+IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLnByaW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcInRvcG9sb2d5IGlzIGNvcnJ1cHQhXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICBsZXQgZSA9IHRoaXMuZ2V0RWRnZShlaSk7XHJcbiAgICAgICAgICAgIGxvb3AucHVzaChlaSk7XHJcbiAgICAgICAgICAgIGVpID0gZS5uZXh0O1xyXG4gICAgICAgIH0gd2hpbGUgKGVpICE9IHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gbG9vcDtcclxuICAgIH1cclxuICAgIGdldFZlcnRleFBvcyh2aSkge1xyXG4gICAgICAgIGlmICh2aSA8IDAgfHwgdmkgPj0gdGhpcy52ZXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJvdXQgb2YgcmFuZ2VcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydHNbdmldLnBvcztcclxuICAgIH1cclxuICAgIGdldFZlcnRleE5vcm1hbCh2aSkge1xyXG4gICAgICAgIGlmICh2aSA8IDAgfHwgdmkgPj0gdGhpcy52ZXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJvdXQgb2YgcmFuZ2VcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydHNbdmldLm5vcm1hbDtcclxuICAgIH1cclxuICAgIGdldFZlcnRleENvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGdldEhhbGZFZGdlQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRnZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY2hhbmdlVmVydGV4KHZpLCBwb3MsIG5vcm0pIHtcclxuICAgICAgICBsZXQgdiA9IHRoaXMudmVydHNbdmldO1xyXG4gICAgICAgIHYucG9zID0gcG9zO1xyXG4gICAgICAgIHYubm9ybWFsID0gbm9ybTtcclxuICAgIH1cclxuICAgIGdldFZlcnQodmkpIHtcclxuICAgICAgICBpZiAodmkgPCAwIHx8IHZpID49IHRoaXMudmVydHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IFwib3V0IG9mIHJhbmdlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRzW3ZpXTtcclxuICAgIH1cclxuICAgIGdldEVkZ2UoZWkpIHtcclxuICAgICAgICBpZiAoZWkgPCAwIHx8IGVpID49IHRoaXMuZWRnZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJvdXQgb2YgcmFuZ2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzW2VpXTtcclxuICAgIH1cclxuICAgIGdldEVkZ2VJbmRleEJldHdlZW4oYWksIGJpKSB7XHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuZ2V0RWRnZUJldHdlZW4oYWksIGJpKTtcclxuICAgICAgICBpZiAocmVzKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRFZGdlSW5kZXgocmVzKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0RWRnZUJldHdlZW4oYWksIGJpKSB7XHJcbiAgICAgICAgbGV0IGVkZ2VzID0gdGhpcy5nZXRWZXJ0RWRnZUZhbihhaSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRFZGdlKGVkZ2VzW2ldLnR3aW4pLnZlcnQgPT0gYmkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZ2V0VmVydEVkZ2VGYW4odmkpIHtcclxuICAgICAgICAvLyBnZXQgYWxsIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGlzIHZlcnRleC5cclxuICAgICAgICAvLyBOT1RFOiBhbGwgYXJlIG91dGdvaW5nIChlLnZlcnQgPT0gdmkpXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJnZXR0aW5nIGZhblwiKTtcclxuICAgICAgICBsZXQgZmFuID0gW107XHJcbiAgICAgICAgbGV0IHYgPSB0aGlzLnZlcnRzW3ZpXTtcclxuICAgICAgICBsZXQgZWkgPSB2LmVkZ2U7XHJcbiAgICAgICAgbGV0IHN0YXJ0ID0gZWk7XHJcbiAgICAgICAgaWYgKGVpID09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKGNvdW50ID4gdGhpcy52ZXJ0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFuOiBcIiwgZmFuKTtcclxuICAgICAgICAgICAgICAgIHRocm93IFwibm9wZVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwic3RlcFwiLCBjb3VudCwgXCJlaVwiLCBlaSk7XHJcbiAgICAgICAgICAgIGxldCBlID0gdGhpcy5nZXRFZGdlKGVpKTtcclxuICAgICAgICAgICAgbGV0IGVfdHdpbiA9IHRoaXMuZ2V0RWRnZVR3aW4oZWkpO1xyXG4gICAgICAgICAgICBmYW4ucHVzaChlKTtcclxuICAgICAgICAgICAgZWkgPSBlX3R3aW4ubmV4dDtcclxuICAgICAgICAgICAgaWYgKGVpID09IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJldHVybmluZyBmYW46IFwiLCBmYW4pO1xyXG4gICAgICAgIHJldHVybiBmYW47XHJcbiAgICB9XHJcbiAgICBnZXRMb29wc0FkamFjZW50VG9FZGdlKGVpKSB7XHJcbiAgICAgICAgbGV0IGxvb3BzID0gW107XHJcbiAgICAgICAgbG9vcHMucHVzaCh0aGlzLmdldExvb3AoZWkpKTtcclxuICAgICAgICBsb29wcy5wdXNoKHRoaXMuZ2V0TG9vcCh0aGlzLmdldEVkZ2UoZWkpLnR3aW4pKTtcclxuICAgICAgICByZXR1cm4gbG9vcHM7XHJcbiAgICB9XHJcbiAgICBnZXRWZXJ0TmVpZ2hib3JzKHZpKSB7XHJcbiAgICAgICAgbGV0IGlkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2V0VmVydEVkZ2VGYW4odmkpLmZvckVhY2goKGUpID0+IHtcclxuICAgICAgICAgICAgaWRzLnB1c2godGhpcy5nZXRFZGdlKGUudHdpbikudmVydCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGlkcztcclxuICAgIH1cclxuICAgIGdldEVkZ2VJbmRleChlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWRnZShlLnR3aW4pLnR3aW47XHJcbiAgICB9XHJcbiAgICBnZXRFZGdlVHdpbihlaSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzW3RoaXMuZWRnZXNbZWldLnR3aW5dO1xyXG4gICAgfVxyXG4gICAgaGFzRWRnZShhLCBiKSB7XHJcbiAgICAgICAgbGV0IG5icyA9IHRoaXMuZ2V0VmVydE5laWdoYm9ycyhhKTtcclxuICAgICAgICByZXR1cm4gbmJzLmluY2x1ZGVzKGIpO1xyXG4gICAgfVxyXG4gICAgYWRkVmVydCh2ZWN0b3IsIG5vcm1hbCkge1xyXG4gICAgICAgIHRoaXMudmVydHMucHVzaCh7IHBvczogdmVjdG9yLCBlZGdlOiAtMSwgbm9ybWFsOiBub3JtYWwsIGRlYWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRzLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcbiAgICByZW1vdmVWZXJ0KGEpIHtcclxuICAgICAgICB0aHJvdyBcIlRPRE8gRklHVVJFIE9VVCBOVUxMICYgUkVNT1ZBTFwiO1xyXG4gICAgfVxyXG4gICAgYWRkRWRnZUlmTmV3KGEsIGIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGFzRWRnZShhLCBiKSkge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5vdCB0aGVyZSFcIik7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZShhLCBiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFkZEVkZ2UodmlfMSwgdmlfMikge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGVpMVxyXG4gICAgICAgIC8vIC8gdmkxIFxcICAtLS0tLS0tLS0+IC8gdmkyIFxcXHJcbiAgICAgICAgLy8gXFwgICAgIC8gPC0tLS0tLS0tLSAgXFwgICAgIC9cclxuICAgICAgICAvLyAgICAgICAgICAgICBlaTJcclxuICAgICAgICBsZXQgZWlfMSA9IHRoaXMuZWRnZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBlaV8yID0gZWlfMSArIDE7XHJcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKHtcclxuICAgICAgICAgICAgbmV4dDogLTEsXHJcbiAgICAgICAgICAgIHR3aW46IGVpXzIsXHJcbiAgICAgICAgICAgIHZlcnQ6IHZpXzEsXHJcbiAgICAgICAgICAgIGRlYWQ6IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgIG5leHQ6IC0xLFxyXG4gICAgICAgICAgICB0d2luOiBlaV8xLFxyXG4gICAgICAgICAgICB2ZXJ0OiB2aV8yLFxyXG4gICAgICAgICAgICBkZWFkOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlICduZXh0JyB0aGluZ3MgYXJlIGZpeGVkLCBhbmQgbW9yZVxyXG4gICAgICAgIHRoaXMuYWRkRWRnZVRvRGlzayh2aV8xLCBlaV8xKTtcclxuICAgICAgICB0aGlzLmFkZEVkZ2VUb0Rpc2sodmlfMiwgZWlfMik7XHJcbiAgICB9XHJcbiAgICBkZWxldGVFZGdlQnlJbmRleChpZCkge1xyXG4gICAgICAgIC8vIGZsYWcgaXQgYXMgJ3RvIGJlIHJlbW92ZWQnXHJcbiAgICAgICAgdGhpcy5kZWxldGVFZGdlKHRoaXMuZ2V0RWRnZShpZCkpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlRWRnZShlZGdlKSB7XHJcbiAgICAgICAgLy8gZmxhZyBpdCBhcyAndG8gYmUgcmVtb3ZlZCdcclxuICAgICAgICBsZXQgdHdpbiA9IHRoaXMuZ2V0RWRnZShlZGdlLnR3aW4pO1xyXG4gICAgICAgIGVkZ2UuZGVhZCA9IHRydWU7XHJcbiAgICAgICAgdHdpbi5kZWFkID0gdHJ1ZTtcclxuICAgICAgICAvLyByZW1vdmUgYWxsIHBvaW50ZXJzXHJcbiAgICAgICAgdGhpcy5kZWxldGVFZGdlRnJvbURpc2soZWRnZSk7XHJcbiAgICAgICAgdGhpcy5kZWxldGVFZGdlRnJvbURpc2sodHdpbik7XHJcbiAgICB9XHJcbiAgICAvLyBTRVRURVJTXHJcbiAgICBnZXREaXNrUG9zaXRpb25zKGVpKSB7XHJcbiAgICAgICAgLy8gcmV0dXJucyBlZGdlSW5kZXggYmVmb3JlLCBlZGdlSW5kZXggYWZ0ZXJcclxuICAgICAgICBsZXQgZSA9IHRoaXMuZ2V0RWRnZShlaSk7XHJcbiAgICAgICAgbGV0IHYgPSB0aGlzLmdldFZlcnQoZS52ZXJ0KTtcclxuICAgICAgICBsZXQgdHdpbiA9IHRoaXMuZ2V0RWRnZVR3aW4oZWkpO1xyXG4gICAgICAgIGxldCB2X3R3aW4gPSB0aGlzLnZlcnRzW3R3aW4udmVydF07XHJcbiAgICAgICAgbGV0IG15VmVjdG9yID0gdi5wb3Muc3ViYmVkKHZfdHdpbi5wb3MpO1xyXG4gICAgICAgIC8vIGdldCBhbGwgdmVjdG9yc1xyXG4gICAgICAgIGxldCB2ZWN0b3JzID0gW107XHJcbiAgICAgICAgdmVjdG9ycy5wdXNoKG15VmVjdG9yKTtcclxuICAgICAgICAvLyBnZXQgbW9yZSB2ZWN0b3JzIGJ5IGdldHRpbmcgYWxsIGVkZ2VzIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gdmVydGV4IHZcclxuICAgICAgICAvLyBpZiB0aGlzIEVkZ2UgaXMgYWxyZWFkeSB3aXRoaW4gdGhlIGZhbiwgZmlsdGVyIGl0IG91dCwgc28gdGhpcyBhc3Nlc3NtZW50IGNhbiBiZSBjb3JyZWN0bHkgbWFkZVxyXG4gICAgICAgIGxldCBlZGdlc1BvdGVudGlhbGx5V2l0aEV4aXN0aW5nRWRnZSA9IHRoaXMuZ2V0VmVydEVkZ2VGYW4oZS52ZXJ0KTtcclxuICAgICAgICBsZXQgZWRnZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzUG90ZW50aWFsbHlXaXRoRXhpc3RpbmdFZGdlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlZGdlID0gZWRnZXNQb3RlbnRpYWxseVdpdGhFeGlzdGluZ0VkZ2VbaV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEVkZ2VJbmRleChlZGdlKSA9PSBlaSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJlZGdlIGlzIGluIHRoZSBmYW4hXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWRnZXMucHVzaChlZGdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtlaSwgZWldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEpIHtcclxuICAgICAgICAgICAgbGV0IGUgPSBlZGdlc1swXTtcclxuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLmdldEVkZ2VJbmRleChlKSwgdGhpcy5nZXRFZGdlSW5kZXgoZSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcImVkZ2VzXCIsIGVkZ2VzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlZGdlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgIGxldCB0d2luID0gdGhpcy5nZXRFZGdlKGVkZ2UudHdpbik7XHJcbiAgICAgICAgICAgIGxldCBuZWlnaGJvciA9IHRoaXMudmVydHNbdHdpbi52ZXJ0XTtcclxuICAgICAgICAgICAgbGV0IG5laWdoYm9yVmVjdG9yID0gdi5wb3Muc3ViYmVkKG5laWdoYm9yLnBvcyk7XHJcbiAgICAgICAgICAgIHZlY3RvcnMucHVzaChuZWlnaGJvclZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYWxsIHZlY3RvcnM6IFwiLCB2ZWN0b3JzKTtcclxuICAgICAgICAvLyBvcmRlciB0aGVtIGJ5ICd3aGVlbCdcclxuICAgICAgICBsZXQgcGxhbmUgPSBQbGFuZS5mcm9tUE4odi5wb3MsIHYubm9ybWFsKTtcclxuICAgICAgICBsZXQgaWhhdCA9IHBsYW5lLmloYXQ7XHJcbiAgICAgICAgbGV0IGpoYXQgPSBwbGFuZS5qaGF0O1xyXG4gICAgICAgIGxldCBvcmRlciA9IFZlY3RvcjMuY2FsY3VsYXRlV2hlZWxPcmRlcih2ZWN0b3JzLCBpaGF0LCBqaGF0KTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm9yZGVyXCIsIG9yZGVyKTtcclxuICAgICAgICAvLyBmaW5kIGluZGV4IDAgaW4gdGhlIG9yZGVyaW5nLiB0aGF0IGlzIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG5ldyBlZGdlLiBnZXQgdGhlIGVkZ2VzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhpcyBlZGdlXHJcbiAgICAgICAgbGV0IGlfYmVmb3JlID0gLTE7XHJcbiAgICAgICAgbGV0IGlfYWZ0ZXIgPSAtMTtcclxuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IG9yZGVyLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBiID0gKGEgKyAxKSAlIG9yZGVyLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGMgPSAoYSArIDIpICUgb3JkZXIubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAob3JkZXJbYl0gPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaV9iZWZvcmUgPSBvcmRlclthXTtcclxuICAgICAgICAgICAgICAgIGlfYWZ0ZXIgPSBvcmRlcltjXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBpY2suIE5PVEU6IElGIENDVyAvIENDIE9GIEdSQVBIIE5FRURTIFRPIEJFIENIQU5HRUQsIENIQU5HRSBUSElTIE9SREVSLCBCVVQgVVNFIFdJVEggQ0FVVElPTlxyXG4gICAgICAgIC8vIG1pbnVzIG9uZSwgc2luY2Ugd2UgaGF2ZSAxIHZlY3RvciBtb3JlIHRoYW4gdGhlIGVkZ2UgbGlzdFxyXG4gICAgICAgIGxldCBlX2JlZm9yZSA9IGVkZ2VzW2lfYWZ0ZXIgLSAxXTtcclxuICAgICAgICBsZXQgZV9hZnRlciA9IGVkZ2VzW2lfYmVmb3JlIC0gMV07XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmdldEVkZ2VJbmRleChlX2JlZm9yZSksIHRoaXMuZ2V0RWRnZUluZGV4KGVfYWZ0ZXIpXTtcclxuICAgIH1cclxuICAgIGFkZEVkZ2VUb0Rpc2sodmksIGVpKSB7XHJcbiAgICAgICAgbGV0IHYgPSB0aGlzLmdldFZlcnQodmkpO1xyXG4gICAgICAgIGxldCB0d2luID0gdGhpcy5nZXRFZGdlVHdpbihlaSk7XHJcbiAgICAgICAgaWYgKHYuZWRnZSA9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBzZXQgdHdvIHBvaW50ZXJzOlxyXG4gICAgICAgICAgICB2LmVkZ2UgPSBlaTsgLy8gSSBhbSB0aGUgdmVydGV4J3MgZmlyc3QgZWRnZVxyXG4gICAgICAgICAgICB0d2luLm5leHQgPSBlaTsgLy8gdGhhdCBtZWFucyBteSB0d2luIHBvaW50cyBiYWNrIHRvIG1lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgW2VpX2JlZm9yZSwgZWlfYWZ0ZXJdID0gdGhpcy5nZXREaXNrUG9zaXRpb25zKGVpKTtcclxuICAgICAgICAgICAgbGV0IFtlX2JlZm9yZSwgZV9hZnRlcl0gPSBbdGhpcy5nZXRFZGdlKGVpX2JlZm9yZSksIHRoaXMuZ2V0RWRnZShlaV9hZnRlcildO1xyXG4gICAgICAgICAgICAvLyBzZXQgdHdvIHBvaW50ZXJzOlxyXG4gICAgICAgICAgICB0aGlzLmdldEVkZ2UoZV9iZWZvcmUudHdpbikubmV4dCA9IGVpO1xyXG4gICAgICAgICAgICB0d2luLm5leHQgPSB0aGlzLmdldEVkZ2VJbmRleChlX2FmdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGVFZGdlRnJvbURpc2soZWRnZSkge1xyXG4gICAgICAgIGxldCBlaSA9IHRoaXMuZ2V0RWRnZUluZGV4KGVkZ2UpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZGVsZXRpbmcuLi5cIiwgZWkpO1xyXG4gICAgICAgIGxldCB2ZXJ0ID0gdGhpcy5nZXRWZXJ0KGVkZ2UudmVydCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJkZWxldGluZyBmcm9tIGRpc2suLi5cIik7XHJcbiAgICAgICAgbGV0IFtlaV9iZWZvcmUsIGVpX2FmdGVyXSA9IHRoaXMuZ2V0RGlza1Bvc2l0aW9ucyhlaSk7XHJcbiAgICAgICAgaWYgKGVpX2JlZm9yZSA9PSBlaSkge1xyXG4gICAgICAgICAgICB2ZXJ0LmVkZ2UgPSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXQgZmxvd2VyID0gdGhpcy5nZXRWZXJ0RWRnZUZhbihlZGdlLnZlcnQpO1xyXG4gICAgICAgIC8vIGZsb3dlci5mb3JFYWNoKChlKSA9PiB7Y29uc29sZS5sb2codGhpcy5nZXRFZGdlSW5kZXgoZSkpfSk7XHJcbiAgICAgICAgbGV0IFtlX2JlZm9yZSwgZV9hZnRlcl0gPSBbdGhpcy5nZXRFZGdlKGVpX2JlZm9yZSksIHRoaXMuZ2V0RWRnZShlaV9hZnRlcildO1xyXG4gICAgICAgIC8vIHNldCBvbmUgcG9pbnRlclxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhpcyBpcyBlZGdlXCIsIGVpKTtcclxuICAgICAgICAvLyAvLyBjb25zb2xlLmxvZyhcImJlZm9yZSBpc1wiLCBlaV9iZWZvcmUpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYWZ0ZXIgaXNcIiwgZWlfYWZ0ZXIpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiYmVmb3JlLnR3aW4ubmV4dCBpc1wiLCB0aGlzLmdldEVkZ2UoZV9iZWZvcmUudHdpbikubmV4dCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJhZnRlci50d2luLm5leHQgaXNcIiwgdGhpcy5nZXRFZGdlKGVfYWZ0ZXIudHdpbikubmV4dCk7XHJcbiAgICAgICAgdGhpcy5nZXRFZGdlKGVfYmVmb3JlLnR3aW4pLm5leHQgPSBlaV9hZnRlcjtcclxuICAgICAgICBpZiAodmVydC5lZGdlID09IGVpKSB7XHJcbiAgICAgICAgICAgIHZlcnQuZWRnZSA9IGVpX2FmdGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE1JU0NcclxuICAgIHNwbGl0RWRnZShhaSwgYmksIGFscGhhKSB7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBlZGdlXHJcbiAgICAgICAgbGV0IGVkZ2UgPSB0aGlzLmdldEVkZ2VCZXR3ZWVuKGFpLCBiaSk7XHJcbiAgICAgICAgaWYgKCFlZGdlKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIEVkZ2UgZm91bmQgYmV0d2VlbiAke2FpfSBhbmQgJHtiaX1gKTtcclxuICAgICAgICBsZXQgdHdpbiA9IHRoaXMuZ2V0RWRnZShlZGdlLnR3aW4pO1xyXG4gICAgICAgIGxldCBhID0gdGhpcy5nZXRWZXJ0KGFpKTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuZ2V0VmVydChiaSk7XHJcbiAgICAgICAgbGV0IHYgPSBWZWN0b3IzLmZyb21MZXJwKGEucG9zLCBiLnBvcywgYWxwaGEpO1xyXG4gICAgICAgIGxldCBuID0gVmVjdG9yMy5mcm9tTGVycChhLm5vcm1hbCwgYi5ub3JtYWwsIGFscGhhKTtcclxuICAgICAgICBsZXQgY2kgPSB0aGlzLmFkZFZlcnQodiwgbik7XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmdldFZlcnQoY2kpO1xyXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgZWRnZXNcclxuICAgICAgICAvLyBpZiAoYWkgPT0gMCkge1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICB0aGlzLmRlbGV0ZUVkZ2UoZWRnZSk7XHJcbiAgICAgICAgdGhpcy5hZGRFZGdlKGFpLCBjaSk7XHJcbiAgICAgICAgdGhpcy5hZGRFZGdlKGNpLCBiaSk7XHJcbiAgICAgICAgcmV0dXJuIGNpO1xyXG4gICAgfVxyXG4gICAgc3ViZGl2aWRlKCkge1xyXG4gICAgICAgIC8vIDEuIGdldCBhbGwgZWRnZXNcclxuICAgICAgICBsZXQgZWRnZXMgPSB0aGlzLmFsbEVkZ2VWZXJ0cygpO1xyXG4gICAgICAgIGxldCBmYWNlcyA9IHRoaXMuYWxsVmVydExvb3BzQXNJbnRzKCk7XHJcbiAgICAgICAgLy8gdGhpcyBtYXBzIG9sZCBlZGdlcyB0byBuZXcgdmVydGljZXNcclxuICAgICAgICBsZXQgZGVhZEVkZ2VNYXAgPSBuZXcgSGFzaFRhYmxlKCk7IC8vIHRoaXNcclxuICAgICAgICAvLyAyLiBzcGxpdCBhbGwgZWRnZXMsIG1hcFxyXG4gICAgICAgIGxldCBjb3VudCA9IGVkZ2VzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgbGV0IG1pZGRsZVBvaW50cyA9IG5ldyBBcnJheShjb3VudCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWkgPSBlZGdlc1tpICogMl07XHJcbiAgICAgICAgICAgIGxldCB2YmkgPSBlZGdlc1tpICogMiArIDFdO1xyXG4gICAgICAgICAgICAvLyBsZXQgZWRnZUkgPSB0aGlzLmdldEVkZ2VJbmRleEJldHdlZW4odmFpLCB2YmkpITtcclxuICAgICAgICAgICAgLy8gbGV0IGVkZ2VJSSA9IHRoaXMuZ2V0RWRnZUluZGV4QmV0d2Vlbih2YmksIHZhaSkhO1xyXG4gICAgICAgICAgICBsZXQgdmNpID0gdGhpcy5zcGxpdEVkZ2UodmFpLCB2YmksIDAuNSk7XHJcbiAgICAgICAgICAgIG1pZGRsZVBvaW50c1tpXSA9IHZjaTtcclxuICAgICAgICAgICAgZGVhZEVkZ2VNYXAuc2V0KFt2YWksIHZiaV0sIHZjaSk7XHJcbiAgICAgICAgICAgIGRlYWRFZGdlTWFwLnNldChbdmJpLCB2YWldLCB2Y2kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBwZXIgb2xkIGZhY2U6IGNvbm5lY3QgdGhlIGRvdHNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBmYWNlID0gZmFjZXNbaV07XHJcbiAgICAgICAgICAgIC8vIGdldCBhbGwgbWlkZGxlIHBvaW50c1xyXG4gICAgICAgICAgICBsZXQgbWlkZGxlUG9pbnRzID0gbmV3IEFycmF5KGZhY2UubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgak5leHQgPSAoaiArIDEpICUgZmFjZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmlhID0gZmFjZVtqXTtcclxuICAgICAgICAgICAgICAgIGxldCB2aWIgPSBmYWNlW2pOZXh0XTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZpYSwgdmliKTtcclxuICAgICAgICAgICAgICAgIG1pZGRsZVBvaW50c1tqXSA9IGRlYWRFZGdlTWFwLmdldChbdmlhLCB2aWJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhtaWRkbGVQb2ludHMpO1xyXG4gICAgICAgICAgICAvLyBjb25uZWN0IHRoZSBkb3RzXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGpOZXh0ID0gKGogKyAxKSAlIGZhY2UubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFZGdlKG1pZGRsZVBvaW50c1tqXSwgbWlkZGxlUG9pbnRzW2pOZXh0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdWJkaXZpZGVRdWFkKCkge1xyXG4gICAgICAgIC8vIDEuIGdldCBhbGwgZWRnZXNcclxuICAgICAgICBsZXQgZWRnZXMgPSB0aGlzLmFsbEVkZ2VWZXJ0cygpO1xyXG4gICAgICAgIGxldCBmYWNlcyA9IHRoaXMuYWxsVmVydExvb3BzQXNJbnRzKCk7XHJcbiAgICAgICAgLy8gdGhpcyBtYXBzIG9sZCBlZGdlcyB0byBuZXcgdmVydGljZXNcclxuICAgICAgICBsZXQgZGVhZEVkZ2VNYXAgPSBuZXcgSGFzaFRhYmxlKCk7IC8vIHRoaXNcclxuICAgICAgICAvLyAyLiBzcGxpdCBhbGwgZWRnZXMsIG1hcFxyXG4gICAgICAgIGxldCBjb3VudCA9IGVkZ2VzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWkgPSBlZGdlc1tpICogMl07XHJcbiAgICAgICAgICAgIGxldCB2YmkgPSBlZGdlc1tpICogMiArIDFdO1xyXG4gICAgICAgICAgICAvLyBsZXQgZWRnZUkgPSB0aGlzLmdldEVkZ2VJbmRleEJldHdlZW4odmFpLCB2YmkpITtcclxuICAgICAgICAgICAgLy8gbGV0IGVkZ2VJSSA9IHRoaXMuZ2V0RWRnZUluZGV4QmV0d2Vlbih2YmksIHZhaSkhO1xyXG4gICAgICAgICAgICBsZXQgdmNpID0gdGhpcy5zcGxpdEVkZ2UodmFpLCB2YmksIDAuNSk7XHJcbiAgICAgICAgICAgIGRlYWRFZGdlTWFwLnNldChbdmFpLCB2YmldLCB2Y2kpO1xyXG4gICAgICAgICAgICBkZWFkRWRnZU1hcC5zZXQoW3ZiaSwgdmFpXSwgdmNpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gMy4gcGVyIG9sZCBmYWNlOiBjb25uZWN0IHRoZSBkb3RzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZmFjZSA9IGZhY2VzW2ldO1xyXG4gICAgICAgICAgICAvLyBnZXQgY2VudGVyIHBvaW50XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSBWZWN0b3IzLnplcm8oKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBwb3MuYWRkKHRoaXMuZ2V0VmVydGV4UG9zKGZhY2Vbal0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3Muc2NhbGUoMSAvIGZhY2UubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGV0IG5vcm0gPSBjYWxjUGxhbmFyRmFjZU5vcm1hbChmYWNlLm1hcCgodikgPT4gdGhpcy5nZXRWZXJ0ZXhQb3ModikpKTtcclxuICAgICAgICAgICAgbGV0IHNpID0gdGhpcy5hZGRWZXJ0KHBvcywgbm9ybSk7XHJcbiAgICAgICAgICAgIC8vIHBlciBtaWRkbGUgcG9pbnQsIGNvbm5lY3QgdGhlIGRvdHNcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgak5leHQgPSAoaiArIDEpICUgZmFjZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBsZXQgdmlhID0gZmFjZVtqXTtcclxuICAgICAgICAgICAgICAgIGxldCB2aWIgPSBmYWNlW2pOZXh0XTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZpYSwgdmliKTtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gZGVhZEVkZ2VNYXAuZ2V0KFt2aWEsIHZpYl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFZGdlKHNpLCBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvckV2ZXJ5RWRnZVZlcnRzKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IGVkZ2VzID0gdGhpcy5hbGxVbmlxdWVFZGdlVmVydHMoKTtcclxuICAgICAgICBsZXQgZWRnZUNvdW50ID0gZWRnZXMubGVuZ3RoIC8gMjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBhID0gdGhpcy5nZXRWZXJ0KGVkZ2VzW2kgKiAyXSk7XHJcbiAgICAgICAgICAgIGxldCBiID0gdGhpcy5nZXRWZXJ0KGVkZ2VzW2kgKiAyICsgMV0pO1xyXG4gICAgICAgICAgICBjYWxsYmFjayhhLnBvcywgYi5wb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxjUGxhbmFyRmFjZU5vcm1hbChmYWNlKSB7XHJcbiAgICAvLyBBU1NVTUVTIDogRkFDRSA9IFBMQU5BUiAmIEZBQ0UgPSBOT1QgU0xJVkVSIFBPTFlHT04gKEFSRUEgPiAwKVxyXG4gICAgbGV0IGNvdW50ID0gZmFjZS5sZW5ndGg7XHJcbiAgICBpZiAoY291bnQgPCAzKSB7XHJcbiAgICAgICAgdGhyb3cgXCJjYW5ub3QgZ2V0IGZhY2UgcGxhbmFyIHdpdGggMiBvciBsZXNzIGVkZ2VzXCI7XHJcbiAgICB9XHJcbiAgICAvLyBnZXQgdGhlIG5vcm1hbCBvZiBhIHBsYW5hciBmYWNlXHJcbiAgICBsZXQgbm9ybWFsID0gVmVjdG9yMy56ZXJvKCk7XHJcbiAgICAvLyB0d28gZWRnZXMgY291bGQgYmUgcGFyYWxsZWwsIGJ1dCB0aGVyZSB3aWxsIGJlIHR3byBlZGdlcyBpbiB0aGUgZmFjZSB0aGF0IGFyZSBkaWZmZXJlbnQuXHJcbiAgICBsZXQgaWhhdCA9IGZhY2VbMV0uc3ViYmVkKGZhY2VbMF0pO1xyXG4gICAgbGV0IGpoYXQgPSBmYWNlWzJdLnN1YmJlZChmYWNlWzFdKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhpaGF0LmRvdChqaGF0KSkgPiBDb25zdC5UT0xFUkFOQ0UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGloYXQuY3Jvc3MoamhhdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cnkgYWdhaW4gd2l0aCBuZXh0IHBhaXIgb2ZcclxuICAgICAgICAgICAgbGV0IGkyID0gKGkgKyAxKSAlIGNvdW50O1xyXG4gICAgICAgICAgICBsZXQgaTMgPSAoaSArIDIpICUgY291bnQ7XHJcbiAgICAgICAgICAgIGpoYXQgPSBmYWNlW2kzXS5zdWJiZWQoZmFjZVtpMl0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IFwiZ2V0IHBsYW5hciBmYWNlIGZhaWxlZC4uLlwiO1xyXG59XHJcbiIsIi8vIG1lc2gudHNcclxuLy8gQXV0aG9yOiBKb3MgRmVlbnN0cmFcclxuLy8gUHVycG9zZTpcclxuLy8gYSB2ZXJ5IHB1cmUgaWRlYSBvZiBhIG1lc2ggOiBWZXJ0aWNlcyArIGxpbmtzIGJldHdlZW4gdmVydGljZXMuXHJcbi8vIENvdWxkIGJlIGFueXRoaW5nIHdpdGggdGhlc2UgcHJvcGVydGllczogbGluZXMsIHRyaWFuZ2xlLW1lc2gsIHF1YWRzXHJcbi8vIGlkZWE6IHNob3VsZCBub3JtYWxzIGJlIHBhcnQgb2YgdGhlIE1lc2g/XHJcbmltcG9ydCB7IEludE1hdHJpeCB9IGZyb20gXCIuLi9kYXRhL2ludC1tYXRyaXhcIjtcclxuaW1wb3J0IHsgVmVjdG9yM0FycmF5IH0gZnJvbSBcIi4uL2RhdGEvdmVjdG9yLWFycmF5XCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgUmVuZGVyYWJsZSwgTWVzaFR5cGUgYXMgTWVzaFR5cGUgfSBmcm9tIFwiLi9yZW5kZXItbWVzaFwiO1xyXG5pbXBvcnQgeyBQbGFuZSB9IGZyb20gXCIuLi9nZW8vcGxhbmVcIjtcclxuaW1wb3J0IHsgR3JhcGggfSBmcm9tIFwiLi9ncmFwaFwiO1xyXG5leHBvcnQgY2xhc3MgTWVzaCB7XHJcbiAgICAvLyBDT05TVFJVQ1RPUlNcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRzLCBsaW5rcykge1xyXG4gICAgICAgIHRoaXMudmVydHMgPSB2ZXJ0cztcclxuICAgICAgICB0aGlzLmxpbmtzID0gbGlua3M7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2godGhpcy52ZXJ0cy5jbG9uZSgpLCB0aGlzLmxpbmtzLmNsb25lKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyh2ZXJ0cywgbGlua3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2godmVydHMsIGxpbmtzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTGlzdHModmVydHMsIGZhY2VzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKFZlY3RvcjNBcnJheS5mcm9tTGlzdCh2ZXJ0cyksIEludE1hdHJpeC5mcm9tTGlzdChmYWNlcywgMykpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld0VtcHR5KHZlcnRDb3VudCwgbGlua0NvdW50LCBwZXJMaW5rQ291bnQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2gobmV3IFZlY3RvcjNBcnJheSh2ZXJ0Q291bnQpLCBuZXcgSW50TWF0cml4KGxpbmtDb3VudCwgcGVyTGlua0NvdW50KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3TGluZXMocG9zaXRpb25zLCBlZGdlcykge1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IFZlY3RvcjNBcnJheS5mcm9tTGlzdChwb3NpdGlvbnMpO1xyXG4gICAgICAgIGxldCBsaW5rcyA9IEludE1hdHJpeC5mcm9tTGlzdChlZGdlcywgMik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKHZlcnRzLCBsaW5rcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgemVybygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2gobmV3IFZlY3RvcjNBcnJheSgwKSwgbmV3IEludE1hdHJpeCgwLCAwKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpvaW4obWVzaGVzKSB7XHJcbiAgICAgICAgLy8gam9pbiBtZXNoZXMsIGRvbnQgdHJ5IHRvIGxvb2sgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlc1xyXG4gICAgICAgIC8vIFRPRE8gOiBtYWtlIHRoaXMgdGhlIHRyb3VibGUgb2YgTWF0cmljZXMgYW5kIEFycmF5c1xyXG4gICAgICAgIGxldCB2ZXJ0Q291bnQgPSAwO1xyXG4gICAgICAgIGxldCBmYWNlQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IG1lc2ggb2YgbWVzaGVzKSB7XHJcbiAgICAgICAgICAgIHZlcnRDb3VudCArPSBtZXNoLnZlcnRzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIGZhY2VDb3VudCArPSBtZXNoLmxpbmtzLmNvdW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkodmVydENvdW50KTtcclxuICAgICAgICBsZXQgbGlua3MgPSBuZXcgSW50TWF0cml4KGZhY2VDb3VudCwgMyk7XHJcbiAgICAgICAgbGV0IGFjY1ZlcnRzID0gMDtcclxuICAgICAgICBsZXQgYWNjRmFjZXMgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IG1lc2ggb2YgbWVzaGVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC52ZXJ0cy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnNldFZlY3RvcihhY2NWZXJ0cyArIGksIG1lc2gudmVydHMuZ2V0VmVjdG9yKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc2gubGlua3MuY291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmFjZSA9IG1lc2gubGlua3MuZ2V0Um93KGkpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZVtqXSA9IGZhY2Vbal0gKyBhY2NWZXJ0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpbmtzLnNldFJvdyhhY2NGYWNlcyArIGksIGZhY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY1ZlcnRzICs9IG1lc2gudmVydHMuY291bnQoKTtcclxuICAgICAgICAgICAgYWNjRmFjZXMgKz0gbWVzaC5saW5rcy5jb3VudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1lc2godmVydHMsIGxpbmtzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUmVjdChyZWN0KSB7XHJcbiAgICAgICAgbGV0IHZlcnRzID0gcmVjdC5nZXRDb3JuZXJzKCk7XHJcbiAgICAgICAgLy8gd2UgY2FudCBoYW5kbGUgcXVhZHMgeWV0XHJcbiAgICAgICAgbGV0IGZhY2VzID0gW107XHJcbiAgICAgICAgZmFjZXMucHVzaCguLi5xdWFkVG9UcmkoY3ViZUZhY2VzWzBdKSk7XHJcbiAgICAgICAgbGV0IHJlbmQgPSBuZXcgUmVuZGVyYWJsZSg0LCAwLCAwLCAyKTtcclxuICAgICAgICByZW5kLm1lc2gudmVydHMuZmlsbEZyb21MaXN0KHZlcnRzKTtcclxuICAgICAgICByZW5kLm1lc2gubGlua3Muc2V0RGF0YShmYWNlcyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWVzaC52ZXJ0cyk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWVzaC5saW5rcyk7XHJcbiAgICAgICAgcmVuZC5zZXRVdnMobmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDAuMCwgMS4wLCAxLjAsIDAuMCwgMS4wLCAxLjBdKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3UXVhZChjb3JuZXJzKSB7XHJcbiAgICAgICAgbGV0IGZhY2VzID0gWy4uLnF1YWRUb1RyaShjdWJlRmFjZXNbMF0pXTtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTGlzdHMoY29ybmVycywgZmFjZXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld09jdChjb3JuZXJzKSB7XHJcbiAgICAgICAgbGV0IGZhY2VzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZmFjZSBvZiBjdWJlRmFjZXMpIHtcclxuICAgICAgICAgICAgZmFjZXMucHVzaCguLi5xdWFkVG9UcmkoZmFjZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTGlzdHMoY29ybmVycywgZmFjZXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21DdWJlKGN1YmUpIHtcclxuICAgICAgICBsZXQgdmVydHMgPSBjdWJlLmdldENvcm5lcnMoKTtcclxuICAgICAgICByZXR1cm4gTWVzaC5uZXdPY3QodmVydHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld0ljb3NhaGVkcm9uKHNjYWxlID0gMSkge1xyXG4gICAgICAgIGxldCBncmFwaCA9IG5ldyBHcmFwaCgpO1xyXG4gICAgICAgIGxldCBhID0gc2NhbGU7XHJcbiAgICAgICAgbGV0IHBoaSA9ICgxICsgTWF0aC5wb3coNSwgMC41KSkgLyAyO1xyXG4gICAgICAgIGxldCBiID0gYSAqIHBoaTtcclxuICAgICAgICBsZXQgYWRkVmVydCA9ICh2KSA9PiB7XHJcbiAgICAgICAgICAgIGdyYXBoLmFkZFZlcnQodiwgdik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBhZGRWZXJ0KG5ldyBWZWN0b3IzKC1hLCAtYiwgMCkpO1xyXG4gICAgICAgIGFkZFZlcnQobmV3IFZlY3RvcjMoYSwgLWIsIDApKTtcclxuICAgICAgICBhZGRWZXJ0KG5ldyBWZWN0b3IzKC1hLCBiLCAwKSk7XHJcbiAgICAgICAgYWRkVmVydChuZXcgVmVjdG9yMyhhLCBiLCAwKSk7XHJcbiAgICAgICAgYWRkVmVydChuZXcgVmVjdG9yMygwLCAtYSwgLWIpKTtcclxuICAgICAgICBhZGRWZXJ0KG5ldyBWZWN0b3IzKDAsIGEsIC1iKSk7XHJcbiAgICAgICAgYWRkVmVydChuZXcgVmVjdG9yMygwLCAtYSwgYikpO1xyXG4gICAgICAgIGFkZFZlcnQobmV3IFZlY3RvcjMoMCwgYSwgYikpO1xyXG4gICAgICAgIGFkZFZlcnQobmV3IFZlY3RvcjMoLWIsIDAsIC1hKSk7XHJcbiAgICAgICAgYWRkVmVydChuZXcgVmVjdG9yMygtYiwgMCwgYSkpO1xyXG4gICAgICAgIGFkZFZlcnQobmV3IFZlY3RvcjMoYiwgMCwgLWEpKTtcclxuICAgICAgICBhZGRWZXJ0KG5ldyBWZWN0b3IzKGIsIDAsIGEpKTtcclxuICAgICAgICAvLyBidWlsZCBlZGdlc1xyXG4gICAgICAgIGxldCBhZGRFZGdlID0gKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShhLCBiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkgKz0gNCkge1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAwLCBpICsgMSk7XHJcbiAgICAgICAgICAgIGFkZEVkZ2UoaSArIDIsIGkgKyAzKTtcclxuICAgICAgICAgICAgbGV0IGluZXh0ID0gKGkgKyA0KSAlIDEyO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAwLCBpbmV4dCArIDIpO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAwLCBpbmV4dCArIDApO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAxLCBpbmV4dCArIDIpO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAxLCBpbmV4dCArIDApO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAyLCBpbmV4dCArIDMpO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAyLCBpbmV4dCArIDEpO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAzLCBpbmV4dCArIDMpO1xyXG4gICAgICAgICAgICBhZGRFZGdlKGkgKyAzLCBpbmV4dCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tR3JhcGgoZ3JhcGgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ld1NwaGVyZShjZW50ZXIsIHJhZGl1cywgbnVtUmluZ3MsIG51bVBlclJpbmcpIHtcclxuICAgICAgICAvLyB2ZXJ0c1xyXG4gICAgICAgIGxldCB2ZXJ0Q291bnQgPSBudW1SaW5ncyAqIG51bVBlclJpbmcgKyAyO1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkodmVydENvdW50KTtcclxuICAgICAgICBsZXQgc2V0VmVydCA9IGZ1bmN0aW9uIChpLCB2ZWN0b3IpIHtcclxuICAgICAgICAgICAgdmVydHMuc2V0VmVjdG9yKGksIHZlY3Rvci5zY2FsZShyYWRpdXMpLmFkZChjZW50ZXIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHNldFZlcnQoMCwgbmV3IFZlY3RvcjMoMCwgMCwgMSkpO1xyXG4gICAgICAgIGZvciAobGV0IHJpbmcgPSAwOyByaW5nIDwgbnVtUmluZ3M7IHJpbmcrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwZXJSaW5nID0gMDsgcGVyUmluZyA8IG51bVBlclJpbmc7IHBlclJpbmcrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFscGhhID0gKE1hdGguUEkgKiAocmluZyArIDEpKSAvIChudW1SaW5ncyArIDEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJldGEgPSAoMiAqIE1hdGguUEkgKiBwZXJSaW5nKSAvIG51bVBlclJpbmc7XHJcbiAgICAgICAgICAgICAgICBsZXQgeCA9IE1hdGguc2luKGFscGhhKSAqIE1hdGguY29zKGJldGEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBNYXRoLnNpbihhbHBoYSkgKiBNYXRoLnNpbihiZXRhKTtcclxuICAgICAgICAgICAgICAgIGxldCB6ID0gTWF0aC5jb3MoYWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMSArIHJpbmcgKiBudW1QZXJSaW5nICsgcGVyUmluZztcclxuICAgICAgICAgICAgICAgIHNldFZlcnQoaW5kZXgsIG5ldyBWZWN0b3IzKHgsIHksIHopKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRWZXJ0KHZlcnRDb3VudCAtIDEsIG5ldyBWZWN0b3IzKDAsIDAsIC0xKSk7XHJcbiAgICAgICAgLy8gZmFjZXNcclxuICAgICAgICBsZXQgZmFjZUNvdW50ID0gbnVtUGVyUmluZyAqIG51bVJpbmdzICogMjtcclxuICAgICAgICBsZXQgbGlua3MgPSBuZXcgSW50TWF0cml4KGZhY2VDb3VudCwgMyk7XHJcbiAgICAgICAgbGlua3MuZmlsbCgtMSk7XHJcbiAgICAgICAgbGV0IHNldEZhY2UgPSBmdW5jdGlvbiAoaSwgcm93KSB7XHJcbiAgICAgICAgICAgIGxpbmtzLnNldFJvdyhpLCByb3cpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gZmFjZXMgdG9wXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QZXJSaW5nOyBpKyspIHtcclxuICAgICAgICAgICAgc2V0RmFjZShpLCBbMCwgaSArIDEsICgoaSArIDEpICUgbnVtUGVyUmluZykgKyAxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhY2VzIG1pZGRsZVxyXG4gICAgICAgIC8vIHdlIGFyZSBhdCB0aGlzIGN1cnNvclxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmFjZXNcIiwgZmFjZUNvdW50KTtcclxuICAgICAgICBmb3IgKGxldCByaW5nID0gMDsgcmluZyA8IG51bVJpbmdzIC0gMTsgcmluZysrKSB7XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0Q3Vyc29yID0gbnVtUGVyUmluZyAqIHJpbmcgKyAxO1xyXG4gICAgICAgICAgICBsZXQgdmVydEN1cnNvckJlbG93ID0gdmVydEN1cnNvciArIG51bVBlclJpbmc7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHBlclJpbmcgPSAwOyBwZXJSaW5nIDwgbnVtUGVyUmluZzsgcGVyUmluZysrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYSA9IHZlcnRDdXJzb3IgKyBwZXJSaW5nO1xyXG4gICAgICAgICAgICAgICAgbGV0IGIgPSB2ZXJ0Q3Vyc29yICsgKChwZXJSaW5nICsgMSkgJSBudW1QZXJSaW5nKTtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gdmVydEN1cnNvckJlbG93ICsgcGVyUmluZztcclxuICAgICAgICAgICAgICAgIGxldCBkID0gdmVydEN1cnNvckJlbG93ICsgKChwZXJSaW5nICsgMSkgJSBudW1QZXJSaW5nKTtcclxuICAgICAgICAgICAgICAgIGxldCBpRmFjZSA9IG51bVBlclJpbmcgKyBudW1QZXJSaW5nICogcmluZyAqIDIgKyBwZXJSaW5nICogMjtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGlGYWNlKTtcclxuICAgICAgICAgICAgICAgIHNldEZhY2UoaUZhY2UsIFthLCBjLCBiXSk7XHJcbiAgICAgICAgICAgICAgICBzZXRGYWNlKGlGYWNlICsgMSwgW2MsIGQsIGJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmYWNlcyBib3R0b21cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBlclJpbmc7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaU5leHQgPSAoaSArIDEpICUgbnVtUGVyUmluZztcclxuICAgICAgICAgICAgbGV0IGxhc3QgPSB2ZXJ0Q291bnQgLSAxO1xyXG4gICAgICAgICAgICBsZXQgaUZhY2UgPSBmYWNlQ291bnQgLSBudW1QZXJSaW5nICsgaTtcclxuICAgICAgICAgICAgbGV0IHplcm8gPSB2ZXJ0Q291bnQgLSBudW1QZXJSaW5nIC0gMTtcclxuICAgICAgICAgICAgbGV0IHZlcnRJID0gemVybyArIGk7XHJcbiAgICAgICAgICAgIGxldCB2ZXJ0SU5leHQgPSB6ZXJvICsgaU5leHQ7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGlGYWNlKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJmYWNlXCIsIGxhc3QsIHZlcnRJTmV4dCwgdmVydEkpO1xyXG4gICAgICAgICAgICBzZXRGYWNlKGlGYWNlLCBbbGFzdCwgdmVydElOZXh0LCB2ZXJ0SV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1lc2godmVydHMsIGxpbmtzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXdDeWxpbmRlcihmcm9tLCB0bywgcmFkaXVzLCBudW1QZXJSaW5nKSB7XHJcbiAgICAgICAgbGV0IG5vcm1hbCA9IHRvLnN1YmJlZChmcm9tKTtcclxuICAgICAgICBsZXQgbnVtVmVydHMgPSBudW1QZXJSaW5nICogMiArIDI7XHJcbiAgICAgICAgbGV0IG51bUZhY2VzID0gKG51bVZlcnRzIC0gMikgKiAyO1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkobnVtVmVydHMpO1xyXG4gICAgICAgIC8vIHNvbWUgZHVtYiBzdHVmZlxyXG4gICAgICAgIGxldCBzZXRWZXJ0ID0gZnVuY3Rpb24gKGksIHZlY3Rvcikge1xyXG4gICAgICAgICAgICB2ZXJ0cy5zZXRWZWN0b3IoaSwgdmVjdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHBsYW5lcyB0byByZXByZXNlbnQgdG9wICYgYm90dG9tXHJcbiAgICAgICAgbGV0IHBsYW5lRnJvbSA9IFBsYW5lLmZyb21QTihmcm9tLCBub3JtYWwpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHBsYW5lRnJvbSk7XHJcbiAgICAgICAgbGV0IHBsYW5lVG8gPSBQbGFuZS5mcm9tUE4odG8sIG5vcm1hbCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cocGxhbmVGcm9tKTtcclxuICAgICAgICAvLyB2ZXJ0cyAnZnJvbSByaW5nXHJcbiAgICAgICAgc2V0VmVydCgwLCBmcm9tKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBlclJpbmc7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdiA9IG5ldyBWZWN0b3IzKE1hdGguY29zKChNYXRoLlBJICogMiAqIGkpIC8gbnVtUGVyUmluZyksIE1hdGguc2luKChNYXRoLlBJICogMiAqIGkpIC8gbnVtUGVyUmluZyksIDApLnNjYWxlKHJhZGl1cyk7XHJcbiAgICAgICAgICAgIHYgPSBwbGFuZUZyb20ubWF0cml4Lm11bHRpcGx5VmVjdG9yKHYpO1xyXG4gICAgICAgICAgICBzZXRWZXJ0KGkgKyAxLCB2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVydHMgJ3RvJyByaW5nXHJcbiAgICAgICAgbGV0IG51bVZlcnRzSGFsZiA9IG51bVZlcnRzIC8gMjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBlclJpbmc7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdiA9IG5ldyBWZWN0b3IzKE1hdGguY29zKChNYXRoLlBJICogMiAqIGkpIC8gbnVtUGVyUmluZyksIE1hdGguc2luKChNYXRoLlBJICogMiAqIGkpIC8gbnVtUGVyUmluZyksIDApLnNjYWxlKHJhZGl1cyk7XHJcbiAgICAgICAgICAgIHYgPSBwbGFuZVRvLm1hdHJpeC5tdWx0aXBseVZlY3Rvcih2KTtcclxuICAgICAgICAgICAgc2V0VmVydChudW1WZXJ0c0hhbGYgKyBpLCB2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VmVydChudW1WZXJ0cyAtIDEsIHRvKTtcclxuICAgICAgICAvLyBzdGFydCBtYWtpbmcgbGlua3NcclxuICAgICAgICBsZXQgbGlua3MgPSBuZXcgSW50TWF0cml4KG51bUZhY2VzLCAzKTtcclxuICAgICAgICBsaW5rcy5maWxsKC0xKTtcclxuICAgICAgICBsZXQgc2V0RmFjZSA9IGZ1bmN0aW9uIChpLCByb3cpIHtcclxuICAgICAgICAgICAgbGlua3Muc2V0Um93KGksIHJvdyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBzZXQgZmFjZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBlclJpbmc7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBiID0gMSArIGk7XHJcbiAgICAgICAgICAgIGxldCBjID0gMSArICgoaSArIDEpICUgbnVtUGVyUmluZyk7XHJcbiAgICAgICAgICAgIGxldCBkID0gbnVtVmVydHMgLSAxO1xyXG4gICAgICAgICAgICBsZXQgZSA9IG51bVZlcnRzSGFsZiArIGk7XHJcbiAgICAgICAgICAgIGxldCBmID0gbnVtVmVydHNIYWxmICsgKChpICsgMSkgJSBudW1QZXJSaW5nKTtcclxuICAgICAgICAgICAgc2V0RmFjZShpICogNCwgW2EsIGMsIGJdKTtcclxuICAgICAgICAgICAgc2V0RmFjZShpICogNCArIDEsIFtiLCBjLCBlXSk7XHJcbiAgICAgICAgICAgIHNldEZhY2UoaSAqIDQgKyAyLCBbYywgZiwgZV0pO1xyXG4gICAgICAgICAgICBzZXRGYWNlKGkgKiA0ICsgMywgW2QsIGUsIGZdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKHZlcnRzLCBsaW5rcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3Q29uZShjZW50ZXIsIHJhZGl1cywgaGVpZ2h0LCBudW1QZXJSaW5nKSB7XHJcbiAgICAgICAgbGV0IG51bVZlcnRzID0gbnVtUGVyUmluZyArIDI7XHJcbiAgICAgICAgbGV0IG51bUZhY2VzID0gbnVtUGVyUmluZyAqIDI7XHJcbiAgICAgICAgbGV0IHZlcnRzID0gbmV3IFZlY3RvcjNBcnJheShudW1WZXJ0cyk7XHJcbiAgICAgICAgbGV0IHNldFZlcnQgPSBmdW5jdGlvbiAoaSwgdmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZlcnRzLnNldFZlY3RvcihpLCB2ZWN0b3IuYWRkKGNlbnRlcikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGxpbmtzID0gbmV3IEludE1hdHJpeChudW1GYWNlcywgMyk7XHJcbiAgICAgICAgbGlua3MuZmlsbCgtMSk7XHJcbiAgICAgICAgbGV0IHNldEZhY2UgPSBmdW5jdGlvbiAoaSwgcm93KSB7XHJcbiAgICAgICAgICAgIGxpbmtzLnNldFJvdyhpLCByb3cpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gc2V0IHZlcnRzXHJcbiAgICAgICAgc2V0VmVydCgwLCBuZXcgVmVjdG9yMygwLCAwLCAwKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QZXJSaW5nOyBpKyspIHtcclxuICAgICAgICAgICAgc2V0VmVydChpICsgMSwgbmV3IFZlY3RvcjMoTWF0aC5jb3MoKE1hdGguUEkgKiAyICogaSkgLyBudW1QZXJSaW5nKSwgTWF0aC5zaW4oKE1hdGguUEkgKiAyICogaSkgLyBudW1QZXJSaW5nKSwgMCkuc2NhbGUocmFkaXVzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNldFZlcnQobnVtVmVydHMgLSAxLCBuZXcgVmVjdG9yMygwLCAwLCBoZWlnaHQpKTtcclxuICAgICAgICAvLyBzZXQgZmFjZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBlclJpbmc7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYSA9IDA7XHJcbiAgICAgICAgICAgIGxldCBiID0gbnVtVmVydHMgLSAxO1xyXG4gICAgICAgICAgICBsZXQgYyA9IDEgKyBpO1xyXG4gICAgICAgICAgICBsZXQgZCA9IDEgKyAoKGkgKyAxKSAlIG51bVBlclJpbmcpO1xyXG4gICAgICAgICAgICBzZXRGYWNlKGkgKiAyLCBbYSwgZCwgY10pO1xyXG4gICAgICAgICAgICBzZXRGYWNlKGkgKiAyICsgMSwgW2MsIGQsIGJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNoKHZlcnRzLCBsaW5rcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUdyYXBoKGdyYXBoKSB7XHJcbiAgICAgICAgLy8gTk9URSA6IGRvZXNudCByZWFsbHkgd29yayBpZiB0aGUgbG9vcHMgYXJlIG5vdCBvZiBzaXplIDMuXHJcbiAgICAgICAgbGV0IHZlcnRzID0gVmVjdG9yM0FycmF5LmZyb21MaXN0KGdyYXBoLmFsbFZlcnRQb3NpdGlvbnMoKSk7XHJcbiAgICAgICAgbGV0IGxvb3BzID0gZ3JhcGguYWxsVmVydExvb3BzQXNJbnRzKCk7XHJcbiAgICAgICAgbGV0IGxpbmtzID0gbmV3IEludE1hdHJpeChsb29wcy5sZW5ndGgsIDMpO1xyXG4gICAgICAgIGxvb3BzLmZvckVhY2goKGxvb3AsIGkpID0+IHtcclxuICAgICAgICAgICAgaWYgKGxvb3AubGVuZ3RoID09IDMpIHtcclxuICAgICAgICAgICAgICAgIGxpbmtzLnNldFJvdyhpLCBsb29wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2FudCBjb252ZXJ0IGxvb3BcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gTWVzaC5uZXcodmVydHMsIGxpbmtzKTtcclxuICAgIH1cclxuICAgIC8vIENPTlZFUlRFUlNcclxuICAgIHRvTGluZXMoKSB7XHJcbiAgICAgICAgY29uc3QgZ2V0TGluZXMgPSAobnVtKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMubGlua3MuY291bnQoKSAqIG51bTtcclxuICAgICAgICAgICAgbGV0IGxpbmVzID0gbmV3IEludE1hdHJpeChjb3VudCwgMik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5saW5rcy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgam5leHQgPSAoaiArIDEpICUgbnVtO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpTGluZXMgPSBpICogbnVtICsgajtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5zZXQoaUxpbmVzLCAwLCB0aGlzLmxpbmtzLmdldChpLCBqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMuc2V0KGlMaW5lcywgMSwgdGhpcy5saW5rcy5nZXQoaSwgam5leHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGluZXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpO1xyXG4gICAgICAgIGlmICh0eXBlID09IE1lc2hUeXBlLkxpbmVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTWVzaFR5cGUuVHJpYW5nbGVzKSB7XHJcbiAgICAgICAgICAgIGxldCBsaW5lcyA9IGdldExpbmVzKDMpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaC5uZXcodGhpcy52ZXJ0cy5jbG9uZSgpLCBsaW5lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gTWVzaFR5cGUuUXVhZHMpIHtcclxuICAgICAgICAgICAgbGV0IGxpbmVzID0gZ2V0TGluZXMoNCk7XHJcbiAgICAgICAgICAgIHJldHVybiBNZXNoLm5ldyh0aGlzLnZlcnRzLmNsb25lKCksIGxpbmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcImNhbm5vdCBjb252ZXJ0IHRvIGxpbmVzXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaC5uZXdFbXB0eSgwLCAwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1JlbmRlcmFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlbmRlcmFibGUuZnJvbU1lc2godGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b0dyYXBoKCkge1xyXG4gICAgICAgIHJldHVybiBHcmFwaC5mcm9tTWVzaCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8vIEdFVFRFUlNcclxuICAgIGdldFR5cGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlua3MuX3dpZHRoID09IE1lc2hUeXBlLlBvaW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaFR5cGUuUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmtzLl93aWR0aCA9PSBNZXNoVHlwZS5MaW5lcykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaFR5cGUuTGluZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlua3MuX3dpZHRoID09IE1lc2hUeXBlLlRyaWFuZ2xlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaFR5cGUuVHJpYW5nbGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmtzLl93aWR0aCA9PSBNZXNoVHlwZS5RdWFkcykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaFR5cGUuUXVhZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTWVzaFR5cGUuSW52YWxpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRMaW5rVmVydHMoZikge1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkodGhpcy5saW5rcy5fd2lkdGgpO1xyXG4gICAgICAgIHRoaXMubGlua3MuZ2V0Um93KGYpLmZvckVhY2goKHYsIGkpID0+IHtcclxuICAgICAgICAgICAgdmVydHMuc2V0VmVjdG9yKGksIHRoaXMudmVydHMuZ2V0VmVjdG9yKHYpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdmVydHM7XHJcbiAgICB9XHJcbiAgICAvLyBNSVNDXHJcbiAgICBjYWxjdWxhdGVGYWNlTm9ybWFscygpIHtcclxuICAgICAgICBsZXQgbm9ybXMgPSBbXTtcclxuICAgICAgICBpZiAodGhpcy5nZXRUeXBlKCkgIT0gTWVzaFR5cGUuVHJpYW5nbGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjYW4gb25seSBjYWxjdWxhdGUgbm9ybWFscyBmcm9tIHRyaWFuZ3VsYXIgbWVzaGVzXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9ybXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmYWNlQ291bnQgPSB0aGlzLmxpbmtzLmNvdW50KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdmVydHMgPSB0aGlzLmdldExpbmtWZXJ0cyhpKS50b0xpc3QoKTtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbCA9IHZlcnRzWzFdLnN1YmJlZCh2ZXJ0c1swXSkuY3Jvc3ModmVydHNbMl0uc3ViYmVkKHZlcnRzWzBdKSkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIG5vcm1zLnB1c2gobm9ybWFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1zO1xyXG4gICAgfVxyXG4gICAgY2FsY3VsYXRlVmVydGV4Tm9ybWFscygpIHtcclxuICAgICAgICBsZXQgZmFjZUNvdW50ID0gdGhpcy5saW5rcy5jb3VudCgpO1xyXG4gICAgICAgIGxldCBmYWNlTm9ybWFscyA9IHRoaXMuY2FsY3VsYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICAvLyBzdGFjayBhbGwgZmFjZSBub3JtYWxzIHBlciB2ZXJ0ZXhcclxuICAgICAgICBsZXQgYXJyYXkgPSBuZXcgVmVjdG9yM0FycmF5KHRoaXMudmVydHMuY291bnQoKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsID0gZmFjZU5vcm1hbHNbaV07XHJcbiAgICAgICAgICAgIHRoaXMubGlua3MuZ2V0Um93KGkpLmZvckVhY2goKHZlcnRleEluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdiA9IGFycmF5LmdldFZlY3Rvcih2ZXJ0ZXhJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5zZXRWZWN0b3IodmVydGV4SW5kZXgsIHYuYWRkKG5vcm1hbCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIGFsbFxyXG4gICAgICAgIGxldCBub3JtYWxzID0gYXJyYXkudG9MaXN0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3JtYWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbHNbaV0ubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub3JtYWxzO1xyXG4gICAgfVxyXG59XHJcbi8vID09PT09PT09PT09PT09PT0gSGVscCA9PT09PT09PT09PT09PT09PT1cclxuLy8gMCAtLS0tLS0tIDFcclxuLy8gfCBcXCAgICAgLyB8XHJcbi8vIHwgIDQtLS01ICB8XHJcbi8vIHwgIHwgICB8ICB8XHJcbi8vIHwgIDYtLS03ICB8XHJcbi8vIHwgLyAgICAgXFwgfFxyXG4vLyAyIC0tLS0tLS0gM1xyXG5jb25zdCBjdWJlRmFjZXMgPSBbXHJcbiAgICBbMCwgMSwgMywgMl0sXHJcbiAgICBbNCwgMCwgMiwgNl0sXHJcbiAgICBbMSwgMCwgNCwgNV0sXHJcbiAgICBbMSwgNSwgNywgM10sXHJcbiAgICBbMiwgMywgNywgNl0sXHJcbiAgICBbNSwgNCwgNiwgN10sXHJcbl07XHJcbmZ1bmN0aW9uIHF1YWRUb1RyaShhYmNkKSB7XHJcbiAgICByZXR1cm4gW2FiY2RbMF0sIGFiY2RbMl0sIGFiY2RbMV0sIGFiY2RbMF0sIGFiY2RbM10sIGFiY2RbMl1dO1xyXG59XHJcbiIsIi8vIG5hbWU6ICAgIG1hcmNoaW5nLWN1YmVzLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBhIG1hcmNoaW5nIGN1YmVzIGltcGxlbWVudGF0aW9uIHVzZWZ1bCBmb3IgY29udmVydGluZyBzY2FsYXIgZGlzY3JldGUgZmllbGRzIHRvIGNvbnRvdXJzXHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuLy8gYmFzZWQgdXBvbjpcclxuLy8gaHR0cDovL3BhdWxib3Vya2UubmV0L2dlb21ldHJ5L3BvbHlnb25pc2UvXHJcbi8vIFBvbHlnb25pc2luZyBhIHNjYWxhciBmaWVsZFxyXG4vLyBBbHNvIGtub3duIGFzOiBcIjNEIENvbnRvdXJpbmdcIiwgXCJNYXJjaGluZyBDdWJlc1wiLCBcIlN1cmZhY2UgUmVjb25zdHJ1Y3Rpb25cIlxyXG4vLyBXcml0dGVuIGJ5IFBhdWwgQm91cmtlXHJcbi8vIE1heSAxOTk0XHJcbi8vXHJcbi8vXHJcbi8vIFRoZSBjdWJlIG1vZGVsIHVzZWQ6XHJcbi8vXHJcbi8vICAgICAoNCkgLS0tLS0tIDQgLS0tLS0tICg1KVxyXG4vLyAgICAgL3wgICAgICAgICAgICAgICAgICAvfFxyXG4vLyAgICA3IHwgICAgICAgICAgICAgICAgIDUgfFxyXG4vLyAgIC8gIHwgICAgICAgICAgICAgICAgLyAgfFxyXG4vLyAoNykgLS0tLS0tIDYgLS0tLS0tICg2KSAgfFxyXG4vLyAgfCAgIDggICAgICAgICAgICAgICB8ICAgOVxyXG4vLyAgfCAgIHwgICAgICAgICAgICAgICB8ICAgfFxyXG4vLyAgfCAgIHwgICAgICAgICAgICAgICB8ICAgfFxyXG4vLyAgfCAgKDApIC0tLS0tLSAwIC0tLS0tLSAoMSlcclxuLy8gIDExIC8gICAgICAgICAgICAgICAxMCAgL1xyXG4vLyAgfCAzICAgICAgICAgICAgICAgICB8IDFcclxuLy8gIHwvICAgICAgICAgICAgICAgICAgfC9cclxuLy8gKDMpIC0tLS0tLSAyIC0tLS0tLSAoMilcclxuLypcclxuICAgIEdpdmVuIGEgZ3JpZCBjZWxsIGFuZCBhbiBpc29sZXZlbCwgY2FsY3VsYXRlIHRoZSB0cmlhbmd1bGFyXHJcbiAgICBmYWNldHMgcmVxdWlyZWQgdG8gcmVwcmVzZW50IHRoZSBpc29zdXJmYWNlIHRocm91Z2ggdGhlIGNlbGwuXHJcbiAgICBSZXR1cm4gdGhlIG51bWJlciBvZiB0cmlhbmd1bGFyIGZhY2V0cywgdGhlIGFycmF5IFwidHJpYW5nbGVzXCJcclxuICAgIHdpbGwgYmUgbG9hZGVkIHVwIHdpdGggdGhlIHZlcnRpY2VzIGF0IG1vc3QgNSB0cmlhbmd1bGFyIGZhY2V0cy5cclxuICAgICAwIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhlIGdyaWQgY2VsbCBpcyBlaXRoZXIgdG90YWxseSBhYm92ZVxyXG4gICAgb2YgdG90YWxseSBiZWxvdyB0aGUgaXNvbGV2ZWwuXHJcbiAqL1xyXG4vLyB0eXBlZGVmIHN0cnVjdCB7XHJcbi8vICAgICBYWVogcFszXTtcclxuLy8gIH0gVFJJQU5HTEU7XHJcbi8vICB0eXBlZGVmIHN0cnVjdCB7XHJcbi8vICAgICBYWVogcFs4XTtcclxuLy8gICAgIGRvdWJsZSB2YWxbOF07XHJcbi8vICB9IEdSSURDRUxMO1xyXG5jbGFzcyBHcmlkY2VsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdOyAvLyA4XHJcbiAgICAgICAgdGhpcy5jb3JuZXIgPSBbXTsgLy8gOFxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFRyaWFuZ2xlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMueHl6ID0gW107IC8vIDNcclxuICAgIH1cclxufVxyXG5jb25zdCBlZGdlVGFibGUgPSBbXHJcbiAgICAweDAsXHJcbiAgICAweDEwOSxcclxuICAgIDB4MjAzLFxyXG4gICAgMHgzMGEsXHJcbiAgICAweDQwNixcclxuICAgIDB4NTBmLFxyXG4gICAgMHg2MDUsXHJcbiAgICAweDcwYyxcclxuICAgIDB4ODBjLFxyXG4gICAgMHg5MDUsXHJcbiAgICAweGEwZixcclxuICAgIDB4YjA2LFxyXG4gICAgMHhjMGEsXHJcbiAgICAweGQwMyxcclxuICAgIDB4ZTA5LFxyXG4gICAgMHhmMDAsXHJcbiAgICAweDE5MCxcclxuICAgIDB4OTksXHJcbiAgICAweDM5MyxcclxuICAgIDB4MjlhLFxyXG4gICAgMHg1OTYsXHJcbiAgICAweDQ5ZixcclxuICAgIDB4Nzk1LFxyXG4gICAgMHg2OWMsXHJcbiAgICAweDk5YyxcclxuICAgIDB4ODk1LFxyXG4gICAgMHhiOWYsXHJcbiAgICAweGE5NixcclxuICAgIDB4ZDlhLFxyXG4gICAgMHhjOTMsXHJcbiAgICAweGY5OSxcclxuICAgIDB4ZTkwLFxyXG4gICAgMHgyMzAsXHJcbiAgICAweDMzOSxcclxuICAgIDB4MzMsXHJcbiAgICAweDEzYSxcclxuICAgIDB4NjM2LFxyXG4gICAgMHg3M2YsXHJcbiAgICAweDQzNSxcclxuICAgIDB4NTNjLFxyXG4gICAgMHhhM2MsXHJcbiAgICAweGIzNSxcclxuICAgIDB4ODNmLFxyXG4gICAgMHg5MzYsXHJcbiAgICAweGUzYSxcclxuICAgIDB4ZjMzLFxyXG4gICAgMHhjMzksXHJcbiAgICAweGQzMCxcclxuICAgIDB4M2EwLFxyXG4gICAgMHgyYTksXHJcbiAgICAweDFhMyxcclxuICAgIDB4YWEsXHJcbiAgICAweDdhNixcclxuICAgIDB4NmFmLFxyXG4gICAgMHg1YTUsXHJcbiAgICAweDRhYyxcclxuICAgIDB4YmFjLFxyXG4gICAgMHhhYTUsXHJcbiAgICAweDlhZixcclxuICAgIDB4OGE2LFxyXG4gICAgMHhmYWEsXHJcbiAgICAweGVhMyxcclxuICAgIDB4ZGE5LFxyXG4gICAgMHhjYTAsXHJcbiAgICAweDQ2MCxcclxuICAgIDB4NTY5LFxyXG4gICAgMHg2NjMsXHJcbiAgICAweDc2YSxcclxuICAgIDB4NjYsXHJcbiAgICAweDE2ZixcclxuICAgIDB4MjY1LFxyXG4gICAgMHgzNmMsXHJcbiAgICAweGM2YyxcclxuICAgIDB4ZDY1LFxyXG4gICAgMHhlNmYsXHJcbiAgICAweGY2NixcclxuICAgIDB4ODZhLFxyXG4gICAgMHg5NjMsXHJcbiAgICAweGE2OSxcclxuICAgIDB4YjYwLFxyXG4gICAgMHg1ZjAsXHJcbiAgICAweDRmOSxcclxuICAgIDB4N2YzLFxyXG4gICAgMHg2ZmEsXHJcbiAgICAweDFmNixcclxuICAgIDB4ZmYsXHJcbiAgICAweDNmNSxcclxuICAgIDB4MmZjLFxyXG4gICAgMHhkZmMsXHJcbiAgICAweGNmNSxcclxuICAgIDB4ZmZmLFxyXG4gICAgMHhlZjYsXHJcbiAgICAweDlmYSxcclxuICAgIDB4OGYzLFxyXG4gICAgMHhiZjksXHJcbiAgICAweGFmMCxcclxuICAgIDB4NjUwLFxyXG4gICAgMHg3NTksXHJcbiAgICAweDQ1MyxcclxuICAgIDB4NTVhLFxyXG4gICAgMHgyNTYsXHJcbiAgICAweDM1ZixcclxuICAgIDB4NTUsXHJcbiAgICAweDE1YyxcclxuICAgIDB4ZTVjLFxyXG4gICAgMHhmNTUsXHJcbiAgICAweGM1ZixcclxuICAgIDB4ZDU2LFxyXG4gICAgMHhhNWEsXHJcbiAgICAweGI1MyxcclxuICAgIDB4ODU5LFxyXG4gICAgMHg5NTAsXHJcbiAgICAweDdjMCxcclxuICAgIDB4NmM5LFxyXG4gICAgMHg1YzMsXHJcbiAgICAweDRjYSxcclxuICAgIDB4M2M2LFxyXG4gICAgMHgyY2YsXHJcbiAgICAweDFjNSxcclxuICAgIDB4Y2MsXHJcbiAgICAweGZjYyxcclxuICAgIDB4ZWM1LFxyXG4gICAgMHhkY2YsXHJcbiAgICAweGNjNixcclxuICAgIDB4YmNhLFxyXG4gICAgMHhhYzMsXHJcbiAgICAweDljOSxcclxuICAgIDB4OGMwLFxyXG4gICAgMHg4YzAsXHJcbiAgICAweDljOSxcclxuICAgIDB4YWMzLFxyXG4gICAgMHhiY2EsXHJcbiAgICAweGNjNixcclxuICAgIDB4ZGNmLFxyXG4gICAgMHhlYzUsXHJcbiAgICAweGZjYyxcclxuICAgIDB4Y2MsXHJcbiAgICAweDFjNSxcclxuICAgIDB4MmNmLFxyXG4gICAgMHgzYzYsXHJcbiAgICAweDRjYSxcclxuICAgIDB4NWMzLFxyXG4gICAgMHg2YzksXHJcbiAgICAweDdjMCxcclxuICAgIDB4OTUwLFxyXG4gICAgMHg4NTksXHJcbiAgICAweGI1MyxcclxuICAgIDB4YTVhLFxyXG4gICAgMHhkNTYsXHJcbiAgICAweGM1ZixcclxuICAgIDB4ZjU1LFxyXG4gICAgMHhlNWMsXHJcbiAgICAweDE1YyxcclxuICAgIDB4NTUsXHJcbiAgICAweDM1ZixcclxuICAgIDB4MjU2LFxyXG4gICAgMHg1NWEsXHJcbiAgICAweDQ1MyxcclxuICAgIDB4NzU5LFxyXG4gICAgMHg2NTAsXHJcbiAgICAweGFmMCxcclxuICAgIDB4YmY5LFxyXG4gICAgMHg4ZjMsXHJcbiAgICAweDlmYSxcclxuICAgIDB4ZWY2LFxyXG4gICAgMHhmZmYsXHJcbiAgICAweGNmNSxcclxuICAgIDB4ZGZjLFxyXG4gICAgMHgyZmMsXHJcbiAgICAweDNmNSxcclxuICAgIDB4ZmYsXHJcbiAgICAweDFmNixcclxuICAgIDB4NmZhLFxyXG4gICAgMHg3ZjMsXHJcbiAgICAweDRmOSxcclxuICAgIDB4NWYwLFxyXG4gICAgMHhiNjAsXHJcbiAgICAweGE2OSxcclxuICAgIDB4OTYzLFxyXG4gICAgMHg4NmEsXHJcbiAgICAweGY2NixcclxuICAgIDB4ZTZmLFxyXG4gICAgMHhkNjUsXHJcbiAgICAweGM2YyxcclxuICAgIDB4MzZjLFxyXG4gICAgMHgyNjUsXHJcbiAgICAweDE2ZixcclxuICAgIDB4NjYsXHJcbiAgICAweDc2YSxcclxuICAgIDB4NjYzLFxyXG4gICAgMHg1NjksXHJcbiAgICAweDQ2MCxcclxuICAgIDB4Y2EwLFxyXG4gICAgMHhkYTksXHJcbiAgICAweGVhMyxcclxuICAgIDB4ZmFhLFxyXG4gICAgMHg4YTYsXHJcbiAgICAweDlhZixcclxuICAgIDB4YWE1LFxyXG4gICAgMHhiYWMsXHJcbiAgICAweDRhYyxcclxuICAgIDB4NWE1LFxyXG4gICAgMHg2YWYsXHJcbiAgICAweDdhNixcclxuICAgIDB4YWEsXHJcbiAgICAweDFhMyxcclxuICAgIDB4MmE5LFxyXG4gICAgMHgzYTAsXHJcbiAgICAweGQzMCxcclxuICAgIDB4YzM5LFxyXG4gICAgMHhmMzMsXHJcbiAgICAweGUzYSxcclxuICAgIDB4OTM2LFxyXG4gICAgMHg4M2YsXHJcbiAgICAweGIzNSxcclxuICAgIDB4YTNjLFxyXG4gICAgMHg1M2MsXHJcbiAgICAweDQzNSxcclxuICAgIDB4NzNmLFxyXG4gICAgMHg2MzYsXHJcbiAgICAweDEzYSxcclxuICAgIDB4MzMsXHJcbiAgICAweDMzOSxcclxuICAgIDB4MjMwLFxyXG4gICAgMHhlOTAsXHJcbiAgICAweGY5OSxcclxuICAgIDB4YzkzLFxyXG4gICAgMHhkOWEsXHJcbiAgICAweGE5NixcclxuICAgIDB4YjlmLFxyXG4gICAgMHg4OTUsXHJcbiAgICAweDk5YyxcclxuICAgIDB4NjljLFxyXG4gICAgMHg3OTUsXHJcbiAgICAweDQ5ZixcclxuICAgIDB4NTk2LFxyXG4gICAgMHgyOWEsXHJcbiAgICAweDM5MyxcclxuICAgIDB4OTksXHJcbiAgICAweDE5MCxcclxuICAgIDB4ZjAwLFxyXG4gICAgMHhlMDksXHJcbiAgICAweGQwMyxcclxuICAgIDB4YzBhLFxyXG4gICAgMHhiMDYsXHJcbiAgICAweGEwZixcclxuICAgIDB4OTA1LFxyXG4gICAgMHg4MGMsXHJcbiAgICAweDcwYyxcclxuICAgIDB4NjA1LFxyXG4gICAgMHg1MGYsXHJcbiAgICAweDQwNixcclxuICAgIDB4MzBhLFxyXG4gICAgMHgyMDMsXHJcbiAgICAweDEwOSxcclxuICAgIDB4MCxcclxuXTtcclxuY29uc3QgdHJpVGFibGUgPSBbXHJcbiAgICBbLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDgsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCAxLCA5LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgOCwgMywgOSwgOCwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDIsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgOCwgMywgMSwgMiwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAyLCAxMCwgMCwgMiwgOSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzIsIDgsIDMsIDIsIDEwLCA4LCAxMCwgOSwgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzMsIDExLCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgMTEsIDIsIDgsIDExLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgOSwgMCwgMiwgMywgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCAxMSwgMiwgMSwgOSwgMTEsIDksIDgsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMTAsIDEsIDExLCAxMCwgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDEwLCAxLCAwLCA4LCAxMCwgOCwgMTEsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgOSwgMCwgMywgMTEsIDksIDExLCAxMCwgOSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDgsIDEwLCAxMCwgOCwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs0LCA3LCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgMywgMCwgNywgMywgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDEsIDksIDgsIDQsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs0LCAxLCA5LCA0LCA3LCAxLCA3LCAzLCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgMiwgMTAsIDgsIDQsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCA0LCA3LCAzLCAwLCA0LCAxLCAyLCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDIsIDEwLCA5LCAwLCAyLCA4LCA0LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgMTAsIDksIDIsIDksIDcsIDIsIDcsIDMsIDcsIDksIDQsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCA0LCA3LCAzLCAxMSwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzExLCA0LCA3LCAxMSwgMiwgNCwgMiwgMCwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDAsIDEsIDgsIDQsIDcsIDIsIDMsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgNywgMTEsIDksIDQsIDExLCA5LCAxMSwgMiwgOSwgMiwgMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzMsIDEwLCAxLCAzLCAxMSwgMTAsIDcsIDgsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCAxMSwgMTAsIDEsIDQsIDExLCAxLCAwLCA0LCA3LCAxMSwgNCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDcsIDgsIDksIDAsIDExLCA5LCAxMSwgMTAsIDExLCAwLCAzLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgNywgMTEsIDQsIDExLCA5LCA5LCAxMSwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA1LCA0LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOSwgNSwgNCwgMCwgOCwgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDUsIDQsIDEsIDUsIDAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCA1LCA0LCA4LCAzLCA1LCAzLCAxLCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgMiwgMTAsIDksIDUsIDQsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCAwLCA4LCAxLCAyLCAxMCwgNCwgOSwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzUsIDIsIDEwLCA1LCA0LCAyLCA0LCAwLCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgMTAsIDUsIDMsIDIsIDUsIDMsIDUsIDQsIDMsIDQsIDgsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA1LCA0LCAyLCAzLCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDExLCAyLCAwLCA4LCAxMSwgNCwgOSwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDUsIDQsIDAsIDEsIDUsIDIsIDMsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgMSwgNSwgMiwgNSwgOCwgMiwgOCwgMTEsIDQsIDgsIDUsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgMywgMTEsIDEwLCAxLCAzLCA5LCA1LCA0LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgOSwgNSwgMCwgOCwgMSwgOCwgMTAsIDEsIDgsIDExLCAxMCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzUsIDQsIDAsIDUsIDAsIDExLCA1LCAxMSwgMTAsIDExLCAwLCAzLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNSwgNCwgOCwgNSwgOCwgMTAsIDEwLCA4LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDcsIDgsIDUsIDcsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAzLCAwLCA5LCA1LCAzLCA1LCA3LCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgNywgOCwgMCwgMSwgNywgMSwgNSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDUsIDMsIDMsIDUsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA3LCA4LCA5LCA1LCA3LCAxMCwgMSwgMiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEwLCAxLCAyLCA5LCA1LCAwLCA1LCAzLCAwLCA1LCA3LCAzLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOCwgMCwgMiwgOCwgMiwgNSwgOCwgNSwgNywgMTAsIDUsIDIsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsyLCAxMCwgNSwgMiwgNSwgMywgMywgNSwgNywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzcsIDksIDUsIDcsIDgsIDksIDMsIDExLCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOSwgNSwgNywgOSwgNywgMiwgOSwgMiwgMCwgMiwgNywgMTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsyLCAzLCAxMSwgMCwgMSwgOCwgMSwgNywgOCwgMSwgNSwgNywgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzExLCAyLCAxLCAxMSwgMSwgNywgNywgMSwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDUsIDgsIDgsIDUsIDcsIDEwLCAxLCAzLCAxMCwgMywgMTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs1LCA3LCAwLCA1LCAwLCA5LCA3LCAxMSwgMCwgMSwgMCwgMTAsIDExLCAxMCwgMCwgLTFdLFxyXG4gICAgWzExLCAxMCwgMCwgMTEsIDAsIDMsIDEwLCA1LCAwLCA4LCAwLCA3LCA1LCA3LCAwLCAtMV0sXHJcbiAgICBbMTEsIDEwLCA1LCA3LCAxMSwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEwLCA2LCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgOCwgMywgNSwgMTAsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAwLCAxLCA1LCAxMCwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDgsIDMsIDEsIDksIDgsIDUsIDEwLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgNiwgNSwgMiwgNiwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDYsIDUsIDEsIDIsIDYsIDMsIDAsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA2LCA1LCA5LCAwLCA2LCAwLCAyLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNSwgOSwgOCwgNSwgOCwgMiwgNSwgMiwgNiwgMywgMiwgOCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzIsIDMsIDExLCAxMCwgNiwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzExLCAwLCA4LCAxMSwgMiwgMCwgMTAsIDYsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCAxLCA5LCAyLCAzLCAxMSwgNSwgMTAsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs1LCAxMCwgNiwgMSwgOSwgMiwgOSwgMTEsIDIsIDksIDgsIDExLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNiwgMywgMTEsIDYsIDUsIDMsIDUsIDEsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCA4LCAxMSwgMCwgMTEsIDUsIDAsIDUsIDEsIDUsIDExLCA2LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMTEsIDYsIDAsIDMsIDYsIDAsIDYsIDUsIDAsIDUsIDksIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs2LCA1LCA5LCA2LCA5LCAxMSwgMTEsIDksIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs1LCAxMCwgNiwgNCwgNywgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDMsIDAsIDQsIDcsIDMsIDYsIDUsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgOSwgMCwgNSwgMTAsIDYsIDgsIDQsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgNiwgNSwgMSwgOSwgNywgMSwgNywgMywgNywgOSwgNCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzYsIDEsIDIsIDYsIDUsIDEsIDQsIDcsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCAyLCA1LCA1LCAyLCA2LCAzLCAwLCA0LCAzLCA0LCA3LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOCwgNCwgNywgOSwgMCwgNSwgMCwgNiwgNSwgMCwgMiwgNiwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzcsIDMsIDksIDcsIDksIDQsIDMsIDIsIDksIDUsIDksIDYsIDIsIDYsIDksIC0xXSxcclxuICAgIFszLCAxMSwgMiwgNywgOCwgNCwgMTAsIDYsIDUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs1LCAxMCwgNiwgNCwgNywgMiwgNCwgMiwgMCwgMiwgNywgMTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCAxLCA5LCA0LCA3LCA4LCAyLCAzLCAxMSwgNSwgMTAsIDYsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAyLCAxLCA5LCAxMSwgMiwgOSwgNCwgMTEsIDcsIDExLCA0LCA1LCAxMCwgNiwgLTFdLFxyXG4gICAgWzgsIDQsIDcsIDMsIDExLCA1LCAzLCA1LCAxLCA1LCAxMSwgNiwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzUsIDEsIDExLCA1LCAxMSwgNiwgMSwgMCwgMTEsIDcsIDExLCA0LCAwLCA0LCAxMSwgLTFdLFxyXG4gICAgWzAsIDUsIDksIDAsIDYsIDUsIDAsIDMsIDYsIDExLCA2LCAzLCA4LCA0LCA3LCAtMV0sXHJcbiAgICBbNiwgNSwgOSwgNiwgOSwgMTEsIDQsIDcsIDksIDcsIDExLCA5LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDQsIDksIDYsIDQsIDEwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgMTAsIDYsIDQsIDksIDEwLCAwLCA4LCAzLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDAsIDEsIDEwLCA2LCAwLCA2LCA0LCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOCwgMywgMSwgOCwgMSwgNiwgOCwgNiwgNCwgNiwgMSwgMTAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCA0LCA5LCAxLCAyLCA0LCAyLCA2LCA0LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMCwgOCwgMSwgMiwgOSwgMiwgNCwgOSwgMiwgNiwgNCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDIsIDQsIDQsIDIsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCAzLCAyLCA4LCAyLCA0LCA0LCAyLCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDQsIDksIDEwLCA2LCA0LCAxMSwgMiwgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDgsIDIsIDIsIDgsIDExLCA0LCA5LCAxMCwgNCwgMTAsIDYsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCAxMSwgMiwgMCwgMSwgNiwgMCwgNiwgNCwgNiwgMSwgMTAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs2LCA0LCAxLCA2LCAxLCAxMCwgNCwgOCwgMSwgMiwgMSwgMTEsIDgsIDExLCAxLCAtMV0sXHJcbiAgICBbOSwgNiwgNCwgOSwgMywgNiwgOSwgMSwgMywgMTEsIDYsIDMsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCAxMSwgMSwgOCwgMSwgMCwgMTEsIDYsIDEsIDksIDEsIDQsIDYsIDQsIDEsIC0xXSxcclxuICAgIFszLCAxMSwgNiwgMywgNiwgMCwgMCwgNiwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzYsIDQsIDgsIDExLCA2LCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNywgMTAsIDYsIDcsIDgsIDEwLCA4LCA5LCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDcsIDMsIDAsIDEwLCA3LCAwLCA5LCAxMCwgNiwgNywgMTAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgNiwgNywgMSwgMTAsIDcsIDEsIDcsIDgsIDEsIDgsIDAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgNiwgNywgMTAsIDcsIDEsIDEsIDcsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCAyLCA2LCAxLCA2LCA4LCAxLCA4LCA5LCA4LCA2LCA3LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgNiwgOSwgMiwgOSwgMSwgNiwgNywgOSwgMCwgOSwgMywgNywgMywgOSwgLTFdLFxyXG4gICAgWzcsIDgsIDAsIDcsIDAsIDYsIDYsIDAsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs3LCAzLCAyLCA2LCA3LCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgMywgMTEsIDEwLCA2LCA4LCAxMCwgOCwgOSwgOCwgNiwgNywgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzIsIDAsIDcsIDIsIDcsIDExLCAwLCA5LCA3LCA2LCA3LCAxMCwgOSwgMTAsIDcsIC0xXSxcclxuICAgIFsxLCA4LCAwLCAxLCA3LCA4LCAxLCAxMCwgNywgNiwgNywgMTAsIDIsIDMsIDExLCAtMV0sXHJcbiAgICBbMTEsIDIsIDEsIDExLCAxLCA3LCAxMCwgNiwgMSwgNiwgNywgMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzgsIDksIDYsIDgsIDYsIDcsIDksIDEsIDYsIDExLCA2LCAzLCAxLCAzLCA2LCAtMV0sXHJcbiAgICBbMCwgOSwgMSwgMTEsIDYsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs3LCA4LCAwLCA3LCAwLCA2LCAzLCAxMSwgMCwgMTEsIDYsIDAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs3LCAxMSwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzcsIDYsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMCwgOCwgMTEsIDcsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCAxLCA5LCAxMSwgNywgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzgsIDEsIDksIDgsIDMsIDEsIDExLCA3LCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDEsIDIsIDYsIDExLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgMiwgMTAsIDMsIDAsIDgsIDYsIDExLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgOSwgMCwgMiwgMTAsIDksIDYsIDExLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNiwgMTEsIDcsIDIsIDEwLCAzLCAxMCwgOCwgMywgMTAsIDksIDgsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs3LCAyLCAzLCA2LCAyLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNywgMCwgOCwgNywgNiwgMCwgNiwgMiwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzIsIDcsIDYsIDIsIDMsIDcsIDAsIDEsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCA2LCAyLCAxLCA4LCA2LCAxLCA5LCA4LCA4LCA3LCA2LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDcsIDYsIDEwLCAxLCA3LCAxLCAzLCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDcsIDYsIDEsIDcsIDEwLCAxLCA4LCA3LCAxLCAwLCA4LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgMywgNywgMCwgNywgMTAsIDAsIDEwLCA5LCA2LCAxMCwgNywgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzcsIDYsIDEwLCA3LCAxMCwgOCwgOCwgMTAsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs2LCA4LCA0LCAxMSwgOCwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzMsIDYsIDExLCAzLCAwLCA2LCAwLCA0LCA2LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOCwgNiwgMTEsIDgsIDQsIDYsIDksIDAsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA0LCA2LCA5LCA2LCAzLCA5LCAzLCAxLCAxMSwgMywgNiwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzYsIDgsIDQsIDYsIDExLCA4LCAyLCAxMCwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDIsIDEwLCAzLCAwLCAxMSwgMCwgNiwgMTEsIDAsIDQsIDYsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs0LCAxMSwgOCwgNCwgNiwgMTEsIDAsIDIsIDksIDIsIDEwLCA5LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTAsIDksIDMsIDEwLCAzLCAyLCA5LCA0LCAzLCAxMSwgMywgNiwgNCwgNiwgMywgLTFdLFxyXG4gICAgWzgsIDIsIDMsIDgsIDQsIDIsIDQsIDYsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCA0LCAyLCA0LCA2LCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgOSwgMCwgMiwgMywgNCwgMiwgNCwgNiwgNCwgMywgOCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDksIDQsIDEsIDQsIDIsIDIsIDQsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCAxLCAzLCA4LCA2LCAxLCA4LCA0LCA2LCA2LCAxMCwgMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEwLCAxLCAwLCAxMCwgMCwgNiwgNiwgMCwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDYsIDMsIDQsIDMsIDgsIDYsIDEwLCAzLCAwLCAzLCA5LCAxMCwgOSwgMywgLTFdLFxyXG4gICAgWzEwLCA5LCA0LCA2LCAxMCwgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDksIDUsIDcsIDYsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgOCwgMywgNCwgOSwgNSwgMTEsIDcsIDYsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs1LCAwLCAxLCA1LCA0LCAwLCA3LCA2LCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzExLCA3LCA2LCA4LCAzLCA0LCAzLCA1LCA0LCAzLCAxLCA1LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOSwgNSwgNCwgMTAsIDEsIDIsIDcsIDYsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNiwgMTEsIDcsIDEsIDIsIDEwLCAwLCA4LCAzLCA0LCA5LCA1LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNywgNiwgMTEsIDUsIDQsIDEwLCA0LCAyLCAxMCwgNCwgMCwgMiwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzMsIDQsIDgsIDMsIDUsIDQsIDMsIDIsIDUsIDEwLCA1LCAyLCAxMSwgNywgNiwgLTFdLFxyXG4gICAgWzcsIDIsIDMsIDcsIDYsIDIsIDUsIDQsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA1LCA0LCAwLCA4LCA2LCAwLCA2LCAyLCA2LCA4LCA3LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgNiwgMiwgMywgNywgNiwgMSwgNSwgMCwgNSwgNCwgMCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzYsIDIsIDgsIDYsIDgsIDcsIDIsIDEsIDgsIDQsIDgsIDUsIDEsIDUsIDgsIC0xXSxcclxuICAgIFs5LCA1LCA0LCAxMCwgMSwgNiwgMSwgNywgNiwgMSwgMywgNywgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDYsIDEwLCAxLCA3LCA2LCAxLCAwLCA3LCA4LCA3LCAwLCA5LCA1LCA0LCAtMV0sXHJcbiAgICBbNCwgMCwgMTAsIDQsIDEwLCA1LCAwLCAzLCAxMCwgNiwgMTAsIDcsIDMsIDcsIDEwLCAtMV0sXHJcbiAgICBbNywgNiwgMTAsIDcsIDEwLCA4LCA1LCA0LCAxMCwgNCwgOCwgMTAsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs2LCA5LCA1LCA2LCAxMSwgOSwgMTEsIDgsIDksIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCA2LCAxMSwgMCwgNiwgMywgMCwgNSwgNiwgMCwgOSwgNSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDExLCA4LCAwLCA1LCAxMSwgMCwgMSwgNSwgNSwgNiwgMTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs2LCAxMSwgMywgNiwgMywgNSwgNSwgMywgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDIsIDEwLCA5LCA1LCAxMSwgOSwgMTEsIDgsIDExLCA1LCA2LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgMTEsIDMsIDAsIDYsIDExLCAwLCA5LCA2LCA1LCA2LCA5LCAxLCAyLCAxMCwgLTFdLFxyXG4gICAgWzExLCA4LCA1LCAxMSwgNSwgNiwgOCwgMCwgNSwgMTAsIDUsIDIsIDAsIDIsIDUsIC0xXSxcclxuICAgIFs2LCAxMSwgMywgNiwgMywgNSwgMiwgMTAsIDMsIDEwLCA1LCAzLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNSwgOCwgOSwgNSwgMiwgOCwgNSwgNiwgMiwgMywgOCwgMiwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDUsIDYsIDksIDYsIDAsIDAsIDYsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCA1LCA4LCAxLCA4LCAwLCA1LCA2LCA4LCAzLCA4LCAyLCA2LCAyLCA4LCAtMV0sXHJcbiAgICBbMSwgNSwgNiwgMiwgMSwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDMsIDYsIDEsIDYsIDEwLCAzLCA4LCA2LCA1LCA2LCA5LCA4LCA5LCA2LCAtMV0sXHJcbiAgICBbMTAsIDEsIDAsIDEwLCAwLCA2LCA5LCA1LCAwLCA1LCA2LCAwLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgMywgOCwgNSwgNiwgMTAsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgNSwgNiwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzExLCA1LCAxMCwgNywgNSwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMSwgNSwgMTAsIDExLCA3LCA1LCA4LCAzLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNSwgMTEsIDcsIDUsIDEwLCAxMSwgMSwgOSwgMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEwLCA3LCA1LCAxMCwgMTEsIDcsIDksIDgsIDEsIDgsIDMsIDEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMSwgMSwgMiwgMTEsIDcsIDEsIDcsIDUsIDEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCA4LCAzLCAxLCAyLCA3LCAxLCA3LCA1LCA3LCAyLCAxMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDcsIDUsIDksIDIsIDcsIDksIDAsIDIsIDIsIDExLCA3LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNywgNSwgMiwgNywgMiwgMTEsIDUsIDksIDIsIDMsIDIsIDgsIDksIDgsIDIsIC0xXSxcclxuICAgIFsyLCA1LCAxMCwgMiwgMywgNSwgMywgNywgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzgsIDIsIDAsIDgsIDUsIDIsIDgsIDcsIDUsIDEwLCAyLCA1LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOSwgMCwgMSwgNSwgMTAsIDMsIDUsIDMsIDcsIDMsIDEwLCAyLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbOSwgOCwgMiwgOSwgMiwgMSwgOCwgNywgMiwgMTAsIDIsIDUsIDcsIDUsIDIsIC0xXSxcclxuICAgIFsxLCAzLCA1LCAzLCA3LCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgOCwgNywgMCwgNywgMSwgMSwgNywgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDAsIDMsIDksIDMsIDUsIDUsIDMsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA4LCA3LCA1LCA5LCA3LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNSwgOCwgNCwgNSwgMTAsIDgsIDEwLCAxMSwgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzUsIDAsIDQsIDUsIDExLCAwLCA1LCAxMCwgMTEsIDExLCAzLCAwLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgMSwgOSwgOCwgNCwgMTAsIDgsIDEwLCAxMSwgMTAsIDQsIDUsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxMCwgMTEsIDQsIDEwLCA0LCA1LCAxMSwgMywgNCwgOSwgNCwgMSwgMywgMSwgNCwgLTFdLFxyXG4gICAgWzIsIDUsIDEsIDIsIDgsIDUsIDIsIDExLCA4LCA0LCA1LCA4LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgNCwgMTEsIDAsIDExLCAzLCA0LCA1LCAxMSwgMiwgMTEsIDEsIDUsIDEsIDExLCAtMV0sXHJcbiAgICBbMCwgMiwgNSwgMCwgNSwgOSwgMiwgMTEsIDUsIDQsIDUsIDgsIDExLCA4LCA1LCAtMV0sXHJcbiAgICBbOSwgNCwgNSwgMiwgMTEsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsyLCA1LCAxMCwgMywgNSwgMiwgMywgNCwgNSwgMywgOCwgNCwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzUsIDEwLCAyLCA1LCAyLCA0LCA0LCAyLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMTAsIDIsIDMsIDUsIDEwLCAzLCA4LCA1LCA0LCA1LCA4LCAwLCAxLCA5LCAtMV0sXHJcbiAgICBbNSwgMTAsIDIsIDUsIDIsIDQsIDEsIDksIDIsIDksIDQsIDIsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs4LCA0LCA1LCA4LCA1LCAzLCAzLCA1LCAxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgNCwgNSwgMSwgMCwgNSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzgsIDQsIDUsIDgsIDUsIDMsIDksIDAsIDUsIDAsIDMsIDUsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA0LCA1LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgMTEsIDcsIDQsIDksIDExLCA5LCAxMCwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCA4LCAzLCA0LCA5LCA3LCA5LCAxMSwgNywgOSwgMTAsIDExLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgMTAsIDExLCAxLCAxMSwgNCwgMSwgNCwgMCwgNywgNCwgMTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCAxLCA0LCAzLCA0LCA4LCAxLCAxMCwgNCwgNywgNCwgMTEsIDEwLCAxMSwgNCwgLTFdLFxyXG4gICAgWzQsIDExLCA3LCA5LCAxMSwgNCwgOSwgMiwgMTEsIDksIDEsIDIsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCA3LCA0LCA5LCAxMSwgNywgOSwgMSwgMTEsIDIsIDExLCAxLCAwLCA4LCAzLCAtMV0sXHJcbiAgICBbMTEsIDcsIDQsIDExLCA0LCAyLCAyLCA0LCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMTEsIDcsIDQsIDExLCA0LCAyLCA4LCAzLCA0LCAzLCAyLCA0LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgOSwgMTAsIDIsIDcsIDksIDIsIDMsIDcsIDcsIDQsIDksIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAxMCwgNywgOSwgNywgNCwgMTAsIDIsIDcsIDgsIDcsIDAsIDIsIDAsIDcsIC0xXSxcclxuICAgIFszLCA3LCAxMCwgMywgMTAsIDIsIDcsIDQsIDEwLCAxLCAxMCwgMCwgNCwgMCwgMTAsIC0xXSxcclxuICAgIFsxLCAxMCwgMiwgOCwgNywgNCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDksIDEsIDQsIDEsIDcsIDcsIDEsIDMsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs0LCA5LCAxLCA0LCAxLCA3LCAwLCA4LCAxLCA4LCA3LCAxLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbNCwgMCwgMywgNywgNCwgMywgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzQsIDgsIDcsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFs5LCAxMCwgOCwgMTAsIDExLCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMCwgOSwgMywgOSwgMTEsIDExLCA5LCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDEsIDEwLCAwLCAxMCwgOCwgOCwgMTAsIDExLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMywgMSwgMTAsIDExLCAzLCAxMCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzEsIDIsIDExLCAxLCAxMSwgOSwgOSwgMTEsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCAwLCA5LCAzLCA5LCAxMSwgMSwgMiwgOSwgMiwgMTEsIDksIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFswLCAyLCAxMSwgOCwgMCwgMTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFszLCAyLCAxMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzIsIDMsIDgsIDIsIDgsIDEwLCAxMCwgOCwgOSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzksIDEwLCAyLCAwLCA5LCAyLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMiwgMywgOCwgMiwgOCwgMTAsIDAsIDEsIDgsIDEsIDEwLCA4LCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMSwgMTAsIDIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFsxLCAzLCA4LCA5LCAxLCA4LCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbiAgICBbMCwgOSwgMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTFdLFxyXG4gICAgWzAsIDMsIDgsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcclxuICAgIFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0sXHJcbl07XHJcbmZ1bmN0aW9uIHBvbHlnb25pc2UoY29ybmVycywgdmFsdWVzLCBsZXZlbCkge1xyXG4gICAgbGV0IHRyaWFuZ2xlcyA9IG51bGw7XHJcbiAgICAvLyBnZXQgdGhlIG1hcmNoaW5nIGN1YmUgaW5kZXggYmFzZWQgb24gY29ybmVyc1xyXG4gICAgbGV0IGN1YmVpbmRleCA9IDA7XHJcbiAgICBpZiAodmFsdWVzWzBdIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDE7XHJcbiAgICBpZiAodmFsdWVzWzFdIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDI7XHJcbiAgICBpZiAodmFsdWVzWzJdIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDQ7XHJcbiAgICBpZiAodmFsdWVzWzNdIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDg7XHJcbiAgICBpZiAodmFsdWVzWzRdIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDE2O1xyXG4gICAgaWYgKHZhbHVlc1s1XSA8IGxldmVsKVxyXG4gICAgICAgIGN1YmVpbmRleCB8PSAzMjtcclxuICAgIGlmICh2YWx1ZXNbNl0gPCBsZXZlbClcclxuICAgICAgICBjdWJlaW5kZXggfD0gNjQ7XHJcbiAgICBpZiAodmFsdWVzWzddIDwgbGV2ZWwpXHJcbiAgICAgICAgY3ViZWluZGV4IHw9IDEyODtcclxuICAgIC8qIEN1YmUgaXMgZW50aXJlbHkgaW4vb3V0IG9mIHRoZSBzdXJmYWNlICovXHJcbiAgICBsZXQgdmVydGxpc3QgPSBbXTsgLy8gMTJcclxuICAgIGlmIChlZGdlVGFibGVbY3ViZWluZGV4XSA9PSAwKVxyXG4gICAgICAgIHJldHVybiBNZXNoLnplcm8oKTtcclxuICAgIC8qIEZpbmQgdGhlIHZlcnRpY2VzIHdoZXJlIHRoZSBzdXJmYWNlIGludGVyc2VjdHMgdGhlIGN1YmUgKi9cclxuICAgIGlmIChlZGdlVGFibGVbY3ViZWluZGV4XSAmIDEpXHJcbiAgICAgICAgdmVydGxpc3RbMF0gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzBdLCBjb3JuZXJzWzFdLCB2YWx1ZXNbMF0sIHZhbHVlc1sxXSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiAyKVxyXG4gICAgICAgIHZlcnRsaXN0WzFdID0gbGVycChsZXZlbCwgY29ybmVyc1sxXSwgY29ybmVyc1syXSwgdmFsdWVzWzFdLCB2YWx1ZXNbMl0pO1xyXG4gICAgaWYgKGVkZ2VUYWJsZVtjdWJlaW5kZXhdICYgNClcclxuICAgICAgICB2ZXJ0bGlzdFsyXSA9IGxlcnAobGV2ZWwsIGNvcm5lcnNbMl0sIGNvcm5lcnNbM10sIHZhbHVlc1syXSwgdmFsdWVzWzNdKTtcclxuICAgIGlmIChlZGdlVGFibGVbY3ViZWluZGV4XSAmIDgpXHJcbiAgICAgICAgdmVydGxpc3RbM10gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzNdLCBjb3JuZXJzWzBdLCB2YWx1ZXNbM10sIHZhbHVlc1swXSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiAxNilcclxuICAgICAgICB2ZXJ0bGlzdFs0XSA9IGxlcnAobGV2ZWwsIGNvcm5lcnNbNF0sIGNvcm5lcnNbNV0sIHZhbHVlc1s0XSwgdmFsdWVzWzVdKTtcclxuICAgIGlmIChlZGdlVGFibGVbY3ViZWluZGV4XSAmIDMyKVxyXG4gICAgICAgIHZlcnRsaXN0WzVdID0gbGVycChsZXZlbCwgY29ybmVyc1s1XSwgY29ybmVyc1s2XSwgdmFsdWVzWzVdLCB2YWx1ZXNbNl0pO1xyXG4gICAgaWYgKGVkZ2VUYWJsZVtjdWJlaW5kZXhdICYgNjQpXHJcbiAgICAgICAgdmVydGxpc3RbNl0gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzZdLCBjb3JuZXJzWzddLCB2YWx1ZXNbNl0sIHZhbHVlc1s3XSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiAxMjgpXHJcbiAgICAgICAgdmVydGxpc3RbN10gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzddLCBjb3JuZXJzWzRdLCB2YWx1ZXNbN10sIHZhbHVlc1s0XSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiAyNTYpXHJcbiAgICAgICAgdmVydGxpc3RbOF0gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzBdLCBjb3JuZXJzWzRdLCB2YWx1ZXNbMF0sIHZhbHVlc1s0XSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiA1MTIpXHJcbiAgICAgICAgdmVydGxpc3RbOV0gPSBsZXJwKGxldmVsLCBjb3JuZXJzWzFdLCBjb3JuZXJzWzVdLCB2YWx1ZXNbMV0sIHZhbHVlc1s1XSk7XHJcbiAgICBpZiAoZWRnZVRhYmxlW2N1YmVpbmRleF0gJiAxMDI0KVxyXG4gICAgICAgIHZlcnRsaXN0WzEwXSA9IGxlcnAobGV2ZWwsIGNvcm5lcnNbMl0sIGNvcm5lcnNbNl0sIHZhbHVlc1syXSwgdmFsdWVzWzZdKTtcclxuICAgIGlmIChlZGdlVGFibGVbY3ViZWluZGV4XSAmIDIwNDgpXHJcbiAgICAgICAgdmVydGxpc3RbMTFdID0gbGVycChsZXZlbCwgY29ybmVyc1szXSwgY29ybmVyc1s3XSwgdmFsdWVzWzNdLCB2YWx1ZXNbN10pO1xyXG4gICAgLy8gY3JlYXRlIHRyaWFuZ2xlc1xyXG4gICAgLy8gbnRyaWFuZyA9IDA7XHJcbiAgICAvLyBmb3IgKGxldCBpID0gMDsgdHJpVGFibGVbY3ViZWluZGV4XVtpXSE9LTE7IGkrPTMpIHtcclxuICAgIC8vICAgICB0cmlhbmdsZXNbbnRyaWFuZ10ucFswXSA9IHZlcnRsaXN0W3RyaVRhYmxlW2N1YmVpbmRleF1baSAgXV07XHJcbiAgICAvLyAgICAgdHJpYW5nbGVzW250cmlhbmddLnBbMV0gPSB2ZXJ0bGlzdFt0cmlUYWJsZVtjdWJlaW5kZXhdW2krMV1dO1xyXG4gICAgLy8gICAgIHRyaWFuZ2xlc1tudHJpYW5nXS5wWzJdID0gdmVydGxpc3RbdHJpVGFibGVbY3ViZWluZGV4XVtpKzJdXTtcclxuICAgIC8vICAgICBudHJpYW5nKys7XHJcbiAgICAvLyB9XHJcbiAgICAvLyByZXR1cm4obnRyaWFuZyk7XHJcbiAgICByZXR1cm4gTWVzaC56ZXJvKCk7XHJcbn1cclxuLypcclxuICAgIExpbmVhcmx5IGludGVycG9sYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSBhbiBpc29zdXJmYWNlIGN1dHNcclxuICAgIGFuIGVkZ2UgYmV0d2VlbiB0d28gdmVydGljZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gc2NhbGFyIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBsZXJwKGxldmVsLCBwMSwgcDIsIHZhbHAxLCB2YWxwMikge1xyXG4gICAgcmV0dXJuIFZlY3RvcjMuZnJvbUxlcnBXZWlnaHRzKHAxLCBwMiwgdmFscDEsIHZhbHAyLCBsZXZlbCk7XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIEFwcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgZGVzID0gXCJcIikge1xyXG4gICAgICAgIC8vIHVuaXF1ZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlcztcclxuICAgIH1cclxuICAgIHVpKHVpKSB7XHJcbiAgICAgICAgLy8gc2V0dXAgZm9yIFVJXHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICAvLyBhZGRpdGlvbmFsIHNldHVwIG9mIHN0YXRlXHJcbiAgICB9XHJcbiAgICB1cGRhdGUoc3RhdGUpIHtcclxuICAgICAgICAvLyB1cGRhdGluZyBzdGF0ZVxyXG4gICAgfVxyXG4gICAgZHJhdyhnbCkge1xyXG4gICAgICAgIC8vIGRyYXdpbmcgc3RhdGVcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICB1aS5qc1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogbGV0cyBjcmVhdGUgdGhlIFVJIHVzaW5nIGh0bWwgJiBkb20gYXBpLCBiZWNhdXNlIHdoeSB0aGUgaGVsbCBub3RcclxuaW1wb3J0IHsgR2Vvbk1hdGggfSBmcm9tIFwiLi4vbWF0aC9tYXRoXCI7XHJcbmV4cG9ydCBjbGFzcyBVSSB7XHJcbiAgICBjb25zdHJ1Y3RvcihmcmFtZSkge1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsQ29udGV4dCA9IGZyYW1lO1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBmcmFtZTtcclxuICAgIH1cclxuICAgIC8vIHRoZSBjb250ZXh0IHN5c3RlbSBtYWtlcyBzdXJlIHRoYXQgdWkgYWRkaXRpb25zIGFwcGVhciB1bmRlciB0aGUgY3VycmVudGx5IGFjdGl2ZSxcclxuICAgIC8vIHNlbGVjdGVkIGFwcCwgYW5kIHRoYXQgdGhlc2UgdWkgZWxlbWVudHMgYXJlIHJlbW92ZWQgd2hlbiBzd2l0Y2hpbmcgdG8gYW5vdGhlciBhcHAuXHJcbiAgICB0b2dnbGVWaXNpYmlsaXR5KCkge1xyXG4gICAgICAgIC8vIHNpbXBsZSB0b2dnbGVcclxuICAgICAgICBpZiAodGhpcy5nbG9iYWxDb250ZXh0LmhpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxDb250ZXh0LmhpZGRlbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsQ29udGV4dC5oaWRkZW4gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGFkZENvbnRleHQoYXBwTmFtZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB0aGlzLmdsb2JhbENvbnRleHQ7XHJcbiAgICAgICAgbGV0IGFwcERpdiA9IHRoaXMuYWRkRGl2KGFwcE5hbWUgKyBcIiBhcHAtaW50ZXJmYWNlXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBhcHBEaXY7XHJcbiAgICB9XHJcbiAgICBzZXRDb250ZXh0KGFwcE5hbWUpIHtcclxuICAgICAgICB0aGlzLmdsb2JhbENvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhcHBOYW1lKTtcclxuICAgIH1cclxuICAgIHJlbW92ZUNvbnRleHQoYXBwTmFtZSkge1xyXG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChhcHBOYW1lKTtcclxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmN1cnJlbnRDb250ZXh0LmNoaWxkRWxlbWVudENvdW50O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRleHQucmVtb3ZlQ2hpbGQodGhpcy5jdXJyZW50Q29udGV4dC5jaGlsZHJlbi5pdGVtKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRlbXAgPSB0aGlzLmN1cnJlbnRDb250ZXh0O1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSB0aGlzLmdsb2JhbENvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q29udGV4dC5yZW1vdmVDaGlsZCh0ZW1wKTtcclxuICAgIH1cclxuICAgIGFkZEVsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lID0gXCJcIikge1xyXG4gICAgICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgICAgIHRoaXMuY3VycmVudENvbnRleHQuYXBwZW5kQ2hpbGQoZWwpO1xyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH1cclxuICAgIGFkZERpdihjbGFzc25hbWUsIGl0ZW1zID0gW10pIHtcclxuICAgICAgICBsZXQgZGl2ID0gdGhpcy5hZGRFbGVtZW50KFwiZGl2XCIsIGNsYXNzbmFtZSk7XHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaXRlbSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRpdjtcclxuICAgIH1cclxuICAgIGFkZEJvb2xlYW5QYXJhbWV0ZXIocGFyYW0sIG9uSW5wdXQgPSAoKSA9PiB7IH0pIHtcclxuICAgICAgICAvLyBjcmVhdGUgaGFja3kgYnV0dG9uXHJcbiAgICAgICAgLy8gPGxhYmVsIGNsYXNzPVwiY2hlY2stY29udGFpbmVyXCI+XHJcbiAgICAgICAgLy8gICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD1cImNoZWNrZWRcIj5cclxuICAgICAgICAvLyAgIDxzcGFuIGNsYXNzPVwiY2hlY2ttYXJrXCI+PC9zcGFuPlxyXG4gICAgICAgIC8vIDwvbGFiZWw+XHJcbiAgICAgICAgbGV0IGNoZWNrYm94ID0gdGhpcy5hZGRFbGVtZW50KFwiaW5wdXRcIiwgXCJjaGVja2JveFwiKTtcclxuICAgICAgICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xyXG4gICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RhdGUgPSBjaGVja2JveC5jaGVja2VkO1xyXG4gICAgICAgICAgICBwYXJhbS5zZXQoc3RhdGUgPyAxIDogMCk7XHJcbiAgICAgICAgICAgIG9uSW5wdXQoY2hlY2tib3gudmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgICAgIHRleHQxLmlubmVyVGV4dCA9IHBhcmFtLm5hbWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHBhcmFtLmdldCgpID09IDE7XHJcbiAgICAgICAgLy8gdGhpcyBuZWVkcyB0byBiZSBkb25lIHRvIG1ha2UgY3NzIGhhcHB5XHJcbiAgICAgICAgbGV0IGNoZWNrY29udGFpbmVyID0gdGhpcy5hZGRFbGVtZW50KFwibGFiZWxcIiwgXCJjaGVjay1jb250YWluZXJcIik7XHJcbiAgICAgICAgbGV0IGNoZWNrbWFyayA9IHRoaXMuYWRkRWxlbWVudChcInNwYW5cIiwgXCJjaGVja21hcmtcIik7XHJcbiAgICAgICAgY2hlY2tjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xyXG4gICAgICAgIGNoZWNrY29udGFpbmVyLmFwcGVuZENoaWxkKGNoZWNrbWFyayk7XHJcbiAgICAgICAgLy8gdGV4dFxyXG4gICAgICAgIGxldCB0ZXh0MSA9IHRoaXMuYWRkRWxlbWVudChcInBcIiwgXCJjb250cm9sLXRleHRcIik7XHJcbiAgICAgICAgdGV4dDEuaW5uZXJUZXh0ID0gcGFyYW0ubmFtZTtcclxuICAgICAgICAvLyBUT0RPIHVwZGF0ZSBiZXlvbmQgb3VyIGNvbnRyb2xcclxuICAgICAgICAvLyBwYXJhbS5vbnNldCA9ICgpID0+IHtcclxuICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coXCJUT0RPXCIpO1xyXG4gICAgICAgIC8vIH07XHJcbiAgICAgICAgdGhpcy5hZGREaXYoXCJjb250cm9sXCIsIFt0ZXh0MSwgY2hlY2tjb250YWluZXJdKTtcclxuICAgICAgICByZXR1cm4gY2hlY2tib3g7XHJcbiAgICB9XHJcbiAgICBhZGRQYXJhbWV0ZXIocGFyYW0sIG9uSW5wdXQgPSAoKSA9PiB7IH0pIHtcclxuICAgICAgICBsZXQgcDtcclxuICAgICAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBFbnVtUGFyYW1ldGVyKSB7XHJcbiAgICAgICAgICAgIHAgPSBwYXJhbS5wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcCA9IHBhcmFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjcmVhdGUgc2xpZGVyIGl0c2VsZlxyXG4gICAgICAgIGxldCBzbGlkZXIgPSB0aGlzLmFkZFJhbmdlSW5wdXQocCwgb25JbnB1dCk7XHJcbiAgICAgICAgLy8gY3JlYXRlIHNsaWRlciB0aXRsZVxyXG4gICAgICAgIGxldCB0ZXh0MSA9IHRoaXMuYWRkRWxlbWVudChcInBcIiwgXCJjb250cm9sLXRleHRcIik7XHJcbiAgICAgICAgdGV4dDEuaW5uZXJUZXh0ID0gcC5uYW1lO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBzbGlkZXIgdmFsdWUgaW5kaWNhdG9yXHJcbiAgICAgICAgbGV0IHRleHQyID0gdGhpcy5hZGRFbGVtZW50KFwicFwiLCBcImNvbnRyb2wtdmFsdWVcIik7XHJcbiAgICAgICAgaWYgKHBhcmFtIGluc3RhbmNlb2YgRW51bVBhcmFtZXRlcikge1xyXG4gICAgICAgICAgICB0ZXh0Mi5pbm5lclRleHQgPSBwYXJhbS5nZXROYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXh0Mi5pbm5lclRleHQgPSBzbGlkZXIudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHB1dCB0aGVtIGFsbCB0b2dldGhlclxyXG4gICAgICAgIHRoaXMuYWRkRGl2KFwiY29udHJvbFwiLCBbdGV4dDEsIHNsaWRlciwgdGV4dDJdKTtcclxuICAgICAgICAvLyBvbiByZXZlcnNlIHVwZGF0ZVxyXG4gICAgICAgIHBhcmFtLnNldFNsaWRlckFuZFRleHQoc2xpZGVyLCB0ZXh0Mik7XHJcbiAgICAgICAgLy8gb24gdXBkYXRlIGJ5IHVzZXJcclxuICAgICAgICBzbGlkZXIub25pbnB1dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgcC5zZXQoc2xpZGVyLnZhbHVlQXNOdW1iZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgb25JbnB1dChzbGlkZXIudmFsdWVBc051bWJlcik7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbSBpbnN0YW5jZW9mIEVudW1QYXJhbWV0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRleHQyLmlubmVyVGV4dCA9IHBhcmFtLmdldE5hbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHQyLmlubmVyVGV4dCA9IHNsaWRlci52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHNsaWRlcjtcclxuICAgIH1cclxuICAgIGFkZFJhbmdlSW5wdXQocGFyYW0sIG9uSW5wdXQgPSAoKSA9PiB7IH0pIHtcclxuICAgICAgICAvLyBhIHNsaWRlciBsb29rcyBsaWtlIHRoaXMgOiA8aW5wdXQgdHlwZT1cInJhbmdlXCIgbWluPVwiMVwiIG1heD1cIjEwMFwiIHN0ZXA9XCIxXCIgdmFsdWU9XCI1MFwiPlxyXG4gICAgICAgIGxldCBzbGlkZXIgPSB0aGlzLmFkZEVsZW1lbnQoXCJpbnB1dFwiLCBcImNvbnRyb2wtc2xpZGVyXCIpO1xyXG4gICAgICAgIHNsaWRlci50eXBlID0gXCJyYW5nZVwiO1xyXG4gICAgICAgIHNsaWRlci5taW4gPSBwYXJhbS5taW4udG9TdHJpbmcoKTtcclxuICAgICAgICBzbGlkZXIubWF4ID0gcGFyYW0ubWF4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgc2xpZGVyLnZhbHVlQXNOdW1iZXIgPSBwYXJhbS5zdGF0ZTtcclxuICAgICAgICBzbGlkZXIuc3RlcCA9IHBhcmFtLnN0ZXAudG9TdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gc2xpZGVyO1xyXG4gICAgfVxyXG4gICAgYWRkVGV4dCh0ZXh0KSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmFkZEVsZW1lbnQoXCJwXCIsIFwidWktdGV4dFwiKTtcclxuICAgICAgICBwLmlubmVyVGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBhZGRCdXR0b24obmFtZSwgY2FsbGJhY2spIHtcclxuICAgICAgICBsZXQgYnV0dG9uID0gdGhpcy5hZGRFbGVtZW50KFwiYnV0dG9uXCIsIFwiY29udHJvbC1idXR0b25cIik7XHJcbiAgICAgICAgYnV0dG9uLmlubmVyVGV4dCA9IG5hbWU7XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYWxsYmFjayk7XHJcbiAgICAgICAgbGV0IHRleHQxID0gdGhpcy5hZGRFbGVtZW50KFwicFwiLCBcImNvbnRyb2wtdGV4dFwiKTtcclxuICAgICAgICBsZXQgY29udHJvbCA9IHRoaXMuYWRkRGl2KFwiY29udHJvbFwiLCBbdGV4dDEsIGJ1dHRvbl0pO1xyXG4gICAgICAgIHJldHVybiBjb250cm9sO1xyXG4gICAgfVxyXG4gICAgYWRkRHJvcGRvd24oZW51bVBhcmFtLCBvbmNoYW5nZSkge1xyXG4gICAgICAgIC8vIDxzZWxlY3Q+XHJcbiAgICAgICAgLy8gIDxvcHRpb24+Q2FwcHVjY2lubzwvb3B0aW9uPlxyXG4gICAgICAgIC8vICA8b3B0aW9uPk1vY2hhPC9vcHRpb24+XHJcbiAgICAgICAgLy8gPC9zZWxlY3Q+XHJcbiAgICAgICAgbGV0IGNvdW50ID0gZW51bVBhcmFtLnZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGRyb3Bkb3duU2VsZWN0b3IgPSB0aGlzLmFkZEVsZW1lbnQoXCJzZWxlY3RcIiwgXCJlbnVtLXNlbGVjdG9yIGRyb3Bkb3duLXNlbGVjdFwiKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG8gPSB0aGlzLmFkZEVsZW1lbnQoXCJvcHRpb25cIiwgXCJlbnVtLWl0ZW1cIik7XHJcbiAgICAgICAgICAgIG8uaW5uZXJUZXh0ID0gZW51bVBhcmFtLnZhbHVlc1tpXTtcclxuICAgICAgICAgICAgZHJvcGRvd25TZWxlY3Rvci5hcHBlbmRDaGlsZChvKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgZHJvcGRvd25TZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldDtcclxuICAgICAgICAgICAgbGV0IGkgPSB0YXJnZXQuc2VsZWN0ZWRJbmRleDtcclxuICAgICAgICAgICAgZW51bVBhcmFtLnNldChpKTtcclxuICAgICAgICAgICAgb25jaGFuZ2UoaSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5hZGREaXYoXCJkcm9wZG93bi1kYXJrXCIsIFtkcm9wZG93blNlbGVjdG9yXSk7XHJcbiAgICAgICAgcmV0dXJuIGRyb3Bkb3duU2VsZWN0b3I7XHJcbiAgICB9XHJcbn1cclxuLy8gYSBzbGlkZXIgcGFyYW1ldGVyXHJcbmV4cG9ydCBjbGFzcyBQYXJhbWV0ZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgc3RhdGUsIG1pbiA9IC1JbmZpbml0eSwgbWF4ID0gSW5maW5pdHksIHN0ZXAgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHRoaXMuc2V0KHRoaXMuc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhuYW1lLCBzdGF0ZSwgbWluID0gLUluZmluaXR5LCBtYXggPSBJbmZpbml0eSwgc3RlcCA9IDAuMSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKG5hbWUsIHN0YXRlLCBtaW4sIG1heCwgc3RlcCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3Qm9vbGVhbihuYW1lLCBzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1ldGVyKG5hbWUsIHN0YXRlID8gMSA6IDAsIDAsIDEsIDEpO1xyXG4gICAgfVxyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlO1xyXG4gICAgfVxyXG4gICAgc2V0KHN0YXRlLCBhY3RpdmF0ZU9uU2V0ID0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIHNvbWV0aGluZyBpcyBzdGlsbCB3cm9uZyBoZXJlLi4uXHJcbiAgICAgICAgbGV0IGNsYW1wZWQgPSBHZW9uTWF0aC5jbGFtcChzdGF0ZSwgdGhpcy5taW4sIHRoaXMubWF4KTtcclxuICAgICAgICBsZXQgcmVzdCA9IHN0YXRlIC0gdGhpcy5taW47XHJcbiAgICAgICAgbGV0IHRpbWVzID0gTWF0aC5yb3VuZChyZXN0IC8gdGhpcy5zdGVwKTtcclxuICAgICAgICBsZXQgc3RlcHBlZCA9IHRoaXMubWluICsgdGhpcy5zdGVwICogdGltZXM7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEdlb25NYXRoLmNsYW1wKHN0ZXBwZWQsIHRoaXMubWluLCB0aGlzLm1heCk7XHJcbiAgICAgICAgaWYgKGFjdGl2YXRlT25TZXQgJiYgdGhpcy5zbGlkZXIgJiYgdGhpcy50ZXh0KVxyXG4gICAgICAgICAgICB0aGlzLm9uc2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXROUGVybXV0YXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbigodGhpcy5tYXggLSB0aGlzLm1pbikgLyB0aGlzLnN0ZXAgKyAxKTtcclxuICAgIH1cclxuICAgIHNldFNsaWRlckFuZFRleHQoc2xpZGVyLCB0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5zbGlkZXIgPSBzbGlkZXI7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgIH1cclxuICAgIG9uc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLnZhbHVlQXNOdW1iZXIgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIHRoaXMudGV4dC5pbm5lclRleHQgPSB0aGlzLnN0YXRlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuLy8gYSBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIGRpc3RpbmN0IHN0YXRlc1xyXG5leHBvcnQgY2xhc3MgRW51bVBhcmFtZXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwLCB2YWx1ZXMpIHtcclxuICAgICAgICB0aGlzLnAgPSBwO1xyXG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhuYW1lLCBzdGF0ZSwgZGVzY3JpcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbnVtUGFyYW1ldGVyKG5ldyBQYXJhbWV0ZXIobmFtZSwgc3RhdGUsIDAsIGRlc2NyaXB0aW9ucy5sZW5ndGggLSAxLCAxKSwgZGVzY3JpcHRpb25zKTtcclxuICAgIH1cclxuICAgIGdldE5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW3RoaXMuZ2V0KCldO1xyXG4gICAgfVxyXG4gICAgLy8gcGFzc3Rocm91Z2hzXHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucC5nZXQoKTtcclxuICAgIH1cclxuICAgIHNldChzdGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnAuc2V0KHN0YXRlKTtcclxuICAgIH1cclxuICAgIGdldE5QZXJtdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucC5nZXROUGVybXV0YXRpb25zKCk7XHJcbiAgICB9XHJcbiAgICBzZXRTbGlkZXJBbmRUZXh0KHNsaWRlciwgdGV4dCkge1xyXG4gICAgICAgIHRoaXMuc2xpZGVyID0gc2xpZGVyO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICB9XHJcbiAgICBvbnNldCgpIHtcclxuICAgICAgICB0aGlzLnNsaWRlci52YWx1ZUFzTnVtYmVyID0gdGhpcy5nZXQoKTtcclxuICAgICAgICB0aGlzLnRleHQuaW5uZXJUZXh0ID0gdGhpcy5nZXROYW1lKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gbmFtZTogICAgc3dhcC1hcHBcclxuLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IHN3YXAgYmV0d2VlbiBkaWZmZXJlbnQgYXBwcy5cclxuLy8gICAgICAgICAgLSBmYWN0b3J5IGZvciBpbml0aWF6aW5nIHRoZXNlIGFwcHNcclxuLy8gICAgICAgICAgLSBtYWtpbmcgc3VyZSBjb3JlIGRlbGV0ZXMgb2xkIGFwcHNcclxuaW1wb3J0IHsgRW51bVBhcmFtZXRlciB9IGZyb20gXCIuLi9zeXN0ZW0vdWlcIjtcclxuaW1wb3J0IHsgQXBwIH0gZnJvbSBcIi4vYXBwXCI7XHJcbmV4cG9ydCBjbGFzcyBTd2FwQXBwIGV4dGVuZHMgQXBwIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBjb3JlLCBwb3NzaWJsZUFwcHMpIHtcclxuICAgICAgICBzdXBlcihnbCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QXBwSW5kZXggPSAtMTtcclxuICAgICAgICB0aGlzLmlzdWloaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xyXG4gICAgICAgIHRoaXMucG9zc2libGVBcHBzID0gcG9zc2libGVBcHBzO1xyXG4gICAgfVxyXG4gICAgZ2V0QXBwTmFtZXMoKSB7XHJcbiAgICAgICAgbGV0IG5hbWVzID0gW107XHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5wb3NzaWJsZUFwcHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBuYW1lcy5wdXNoKHRoaXMucG9zc2libGVBcHBzW2ldLm5hbWUucmVwbGFjZShcIkFwcFwiLCBcIlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuYW1lcztcclxuICAgIH1cclxuICAgIHVpKHVpKSB7XHJcbiAgICAgICAgbGV0IG5hbWVzID0gdGhpcy5nZXRBcHBOYW1lcygpO1xyXG4gICAgICAgIHRoaXMucGFyYW0gPSBFbnVtUGFyYW1ldGVyLm5ldyhcImFwcHNcIiwgMCwgbmFtZXMpO1xyXG4gICAgICAgIHVpLmFkZERyb3Bkb3duKHRoaXMucGFyYW0sIChpKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc3dhcChpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN3YXBGcm9tVXJsKGhhc2gsIGlmbm90KSB7XHJcbiAgICAgICAgLy8gc2VsZWN0IG9uZSBvZiB0aGUgYXBwcyBiYXNlZCBvbiBhbiB1cmxcclxuICAgICAgICBsZXQgdGVzdCA9IGhhc2guc3Vic3RyKDEpO1xyXG4gICAgICAgIGxldCBuYW1lcyA9IHRoaXMuZ2V0QXBwTmFtZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpID09PSB0ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN3YXAoaSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm8gbWF0Y2hcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm5vIGhhc2ggbWF0Y2gsIGRlZmF1bHRpbmcuLi5cIik7XHJcbiAgICAgICAgdGhpcy5zd2FwKGlmbm90KTtcclxuICAgIH1cclxuICAgIHN3YXAoaW5kZXgpIHtcclxuICAgICAgICAvLyB0b2RvIGRvIHNvbWUgcmFuZ2UgY2hlY2tpbmdcclxuICAgICAgICBsZXQgQXBwVHlwZSA9IHRoaXMucG9zc2libGVBcHBzW2luZGV4XTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QXBwSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBsZXQgUHJldmlvdXNUeXBlID0gdGhpcy5wb3NzaWJsZUFwcHNbdGhpcy5jdXJyZW50QXBwSW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlbW92aW5nXCIsIFByZXZpb3VzVHlwZS5uYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5jb3JlLnJlbW92ZUFwcChQcmV2aW91c1R5cGUubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29uc3RydWN0aW5nXCIsIEFwcFR5cGUubmFtZSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QXBwSW5kZXggPSBpbmRleDtcclxuICAgICAgICBsZXQgYXBwID0gbmV3IEFwcFR5cGUodGhpcy5nbCk7XHJcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IFwiI1wiICsgQXBwVHlwZS5uYW1lLnJlcGxhY2UoXCJBcHBcIiwgXCJcIikudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB0aGlzLmNvcmUuYWRkQXBwKGFwcCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoc3RhdGUpIHtcclxuICAgICAgICBpZiAoc3RhdGUuSXNLZXlQcmVzc2VkKFwibVwiKSkge1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgdG9nZ2xlXHJcbiAgICAgICAgICAgIHRoaXMuY29yZS51aS50b2dnbGVWaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuLy8gYSBDdWJlIG9mIHZveGVsc1xyXG5leHBvcnQgY2xhc3MgSW50Q3ViZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihoZWlnaHQsIHdpZHRoLCBkZXB0aCwgZGF0YSA9IFtdKSB7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fZGVwdGggPSBkZXB0aDtcclxuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuX3dpZHRoICogdGhpcy5faGVpZ2h0ICogdGhpcy5fZGVwdGg7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgaWYgKGRhdGEgPT0gW10gfHwgZGF0YS5sZW5ndGggPT0gMClcclxuICAgICAgICAgICAgdGhpcy5maWxsKDApO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldERhdGEoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggKiB0aGlzLl9oZWlnaHQgKiB0aGlzLl9kZXB0aDtcclxuICAgIH1cclxuICAgIC8vIHNoYWxsb3cgY29weVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IEludEN1YmUodGhpcy5faGVpZ2h0LCB0aGlzLl93aWR0aCwgdGhpcy5fZGVwdGgpO1xyXG4gICAgICAgIGNsb25lLmRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfVxyXG4gICAgc2V0RGF0YShkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9IHRoaXMuc2l6ZSgpKVxyXG4gICAgICAgICAgICB0aHJvdyBcImRhdGEubGVuZ3RoIGRvZXMgbm90IG1hdGNoIHdpZHRoICogaGVpZ2h0IFwiICsgZGF0YS5sZW5ndGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmRhdGEuc2V0KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZmlsbCh2YWx1ZSkge1xyXG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5SYW5nZShpLCBqLCBrKSB7XHJcbiAgICAgICAgcmV0dXJuICEoaSA8IDAgfHwgaiA8IDAgfHwgayA8IDAgfHwgaSA+IHRoaXMuX3dpZHRoIC0gMSB8fCBqID4gdGhpcy5faGVpZ2h0IC0gMSB8fCBrID4gdGhpcy5fZGVwdGggLSAxKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KGksIGosIGspIHtcclxuICAgICAgICByZXR1cm4gaSAqICh0aGlzLl9oZWlnaHQgKiB0aGlzLl9kZXB0aCkgKyBqICogdGhpcy5fZGVwdGggKyBrO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29vcmRzKGluZGV4KSB7XHJcbiAgICAgICAgLy8gamF2YXNjcmlwdCwgZG9udCB5b3UgZGFyZSB0dXJuICAnaW50IC8gaW50JyBpbnRvIGEgZmxvYXQuLi5cclxuICAgICAgICBsZXQgaSA9IE1hdGguZmxvb3IoaW5kZXggLyAodGhpcy5faGVpZ2h0ICogdGhpcy5fZGVwdGgpKSAlIHRoaXMuX3dpZHRoO1xyXG4gICAgICAgIGxldCBqID0gTWF0aC5mbG9vcihpbmRleCAvIHRoaXMuX2RlcHRoKSAlIHRoaXMuX2hlaWdodDtcclxuICAgICAgICBsZXQgayA9IGluZGV4ICUgdGhpcy5fZGVwdGg7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKGksIGosIGspO1xyXG4gICAgfVxyXG4gICAgZ2V0KGksIGosIGspIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMuZ2V0SW5kZXgoaSwgaiwgayldO1xyXG4gICAgfVxyXG4gICAgdHJ5R2V0KGksIGosIGspIHtcclxuICAgICAgICBpZiAodGhpcy5pblJhbmdlKGksIGosIGspKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy5nZXRJbmRleChpLCBqLCBrKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0KGksIGosIGssIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhW3RoaXMuZ2V0SW5kZXgoaSwgaiwgayldID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICB0cnlTZXQoaSwgaiwgaywgdmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5pblJhbmdlKGksIGosIGspKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLmdldEluZGV4KGksIGosIGspXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGl0ZXIoY2FsbGJhY2tmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrZm4odGhpcy5kYXRhW2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXAoY2FsbGJhY2tmbikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGNhbGxiYWNrZm4odGhpcy5kYXRhW2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnVlRm9yQWxsKGNhbGxiYWNrZm4pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrZm4odGhpcy5kYXRhW2ldLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IENvbnN0IH0gZnJvbSBcIi4uL21hdGgvY29uc3RcIjtcclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5leHBvcnQgY2xhc3MgQ2lyY2xlMiB7XHJcbiAgICBjb25zdHJ1Y3RvcihjZW50ZXIsIHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG4gICAgfVxyXG4gICAgLy8gdGhhbmsgeW91IG1yIE1pdHRlbGRvcmYgZm9yIG1ha2luZyBtZSByZW1lbWJlciBob3cgYmFzaWMgbWF0aCB3b3Jrc1xyXG4gICAgLy8gaHR0cDovL21hdGhmb3J1bS5vcmcvbGlicmFyeS9kcm1hdGgvdmlldy81MzAyNy5odG1sXHJcbiAgICAvLyBjYWxjdWxhdGUgdGhlIGNlbnRlcnMgb2YgdHdvIGNpcmNsZXMsIGRlZmluZWQgYnkgdHdvIHBvaW50cyBhbmQgYSByYWRpdXNcclxuICAgIHN0YXRpYyBjZW50ZXJzRnJvbVBQUihhLCBiLCByYWRpdXMpIHtcclxuICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICAgICAgICAvLyBnZXQgaW4gYmV0d2VlbiBsZW5ndGggYW5kIGhhbGZ3YXkgcG9pbnRcclxuICAgICAgICBsZXQgbm9ybWFsID0gYi5jbG9uZSgpLnN1YihhKTtcclxuICAgICAgICBsZXQgZGlzID0gbm9ybWFsLmxlbmd0aCgpO1xyXG4gICAgICAgIGxldCBtaWRkbGUgPSBhXHJcbiAgICAgICAgICAgIC5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5hZGQoYilcclxuICAgICAgICAgICAgLnNjYWxlKDEgLyAyKTtcclxuICAgICAgICAvLyBzY2FsYXIgbGVuZ3RoIG9uIG1pcnJvciBsaW5lIChweXRoYWdvcmFzKVxyXG4gICAgICAgIGxldCB2YWx1ZSA9IE1hdGgucG93KHJhZGl1cywgMikgLSBNYXRoLnBvdygoZGlzIC8gMiksIDIpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IC1Db25zdC5UT0xFUkFOQ0UpIHtcclxuICAgICAgICAgICAgLy8gbm8gc29sbHV0aW9uXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCBDb25zdC5UT0xFUkFOQ0UpIHtcclxuICAgICAgICAgICAgLy8gY2VudGVyIHJvdWdobHkgaW4gdGhlIG1pZGRsZSwgc28ganVzdCByZXR1cm4gdGhlIG1pZGRsZVxyXG4gICAgICAgICAgICByZXR1cm4gW21pZGRsZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0d28gY2lyY2xlcyBwb3NzaWJsZTpcclxuICAgICAgICAgICAgbGV0IGRpc1RvQ2VudGVyID0gTWF0aC5wb3codmFsdWUsIDAuNSk7XHJcbiAgICAgICAgICAgIGxldCBub3JtWSA9IG5ldyBWZWN0b3IyKG5vcm1hbC55LCAtbm9ybWFsLngpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBtaWRkbGUgcG9pbnQgdXAgYW5kIGRvd25cclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG1pZGRsZS5jbG9uZSgpLmFkZChub3JtWS5jbG9uZSgpLnNjYWxlKGRpc1RvQ2VudGVyKSksXHJcbiAgICAgICAgICAgICAgICBtaWRkbGUuY2xvbmUoKS5hZGQobm9ybVkuY2xvbmUoKS5zY2FsZSgtZGlzVG9DZW50ZXIpKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gcHVycG9zZTogcmVwcmVzZW50cyBhIDNkIGNpcmNsZVxyXG5pbXBvcnQgeyBDb25zdCB9IGZyb20gXCIuLi9tYXRoL2NvbnN0XCI7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSBcIi4vcGxhbmVcIjtcclxuZXhwb3J0IGNsYXNzIENpcmNsZTMge1xyXG4gICAgY29uc3RydWN0b3IocGxhbmUsIHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMucGxhbmUgPSBwbGFuZTtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQ2lyY2xlMihjaXJjbGUyLCBwbGFuZSA9IFBsYW5lLldvcmxkWFkoKSkge1xyXG4gICAgICAgIC8vIGVsZXZhdGUgY2VudGVyIG9mIGNpcmNsZSwgbWFrZSBpdCB0aGUgY2VudGVyIG9mIGEgcGxhbmVcclxuICAgICAgICBsZXQgY2VudGVyM2QgPSBwbGFuZS5wdXNoVG9Xb3JsZChjaXJjbGUyLmNlbnRlci50bzNEKCkpO1xyXG4gICAgICAgIHBsYW5lID0gcGxhbmUuY2xvbmUoKTtcclxuICAgICAgICBwbGFuZS5jZW50ZXIgPSBjZW50ZXIzZDtcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZTMocGxhbmUsIGNpcmNsZTIucmFkaXVzKTtcclxuICAgIH1cclxuICAgIGluY2x1ZGVzKHApIHtcclxuICAgICAgICAvLyB0ZXN0IGlmIHRoZSBwb2ludCBmYWxscyBpbiByYW5nZSBvZiB0aGUgY2lyY2xlLCBieSByZWdhcmRpbmdcclxuICAgICAgICAvLyB0aGUgY2lyY2xlIGFzIGEgdG9ydXNcclxuICAgICAgICAvLyBDSEFOR0UgTk9URTogaSBzZXQgdGhpcyB0byB6ZXJvLCBmb3IgdGVzdGluZ1xyXG4gICAgICAgIC8vIHZlcnRpY2FsIGVycm9yXHJcbiAgICAgICAgbGV0IFtwcm9qUG9pbnQsIHlFcnJvcl0gPSB0aGlzLnBsYW5lLmNsb3Nlc3RQb2ludChwKTtcclxuICAgICAgICB5RXJyb3IgPSB5RXJyb3IgLyAzO1xyXG4gICAgICAgIC8vIGhvcml6b250YWwgZXJyb3I6IGdldCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHBvaW50XHJcbiAgICAgICAgbGV0IHhFcnJvciA9IHRoaXMucGxhbmUuY2VudGVyLmNsb25lKCkuZGlzVG8ocHJvalBvaW50KSAtIHRoaXMucmFkaXVzO1xyXG4gICAgICAgIC8vIGxlbmd0aCBvZiB0b3RhbCBlcnJvciB2ZWN0b3IgbmVlZHMgdG8gYmUgc21hbGxlciB0aGFuIHRoZSBnaXZlblxyXG4gICAgICAgIC8vIHRvbGVyYW5jZVxyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdyh5RXJyb3IsIDIpICsgTWF0aC5wb3coeEVycm9yLCAyKSA8IENvbnN0LlRPTF9TUVVBUkVEO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIGRvbWFpbi50c1xyXG4vL1xyXG4vLyBhdXRob3I6IEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBnZW5lcmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgZG9tYWluIC8gcmFuZ2UgLyBib3VuZCBvZiBudW1iZXJzXHJcbi8vXHJcbmltcG9ydCB7IFZlY3RvcjNBcnJheSB9IGZyb20gXCIuLi9kYXRhL3ZlY3Rvci1hcnJheVwiO1xyXG5pbXBvcnQgeyBWZWN0b3IyLCBWZWN0b3IzIH0gZnJvbSBcIi4vdmVjdG9yXCI7XHJcbmV4cG9ydCBjbGFzcyBEb21haW4ge1xyXG4gICAgY29uc3RydWN0b3IodDAgPSAwLjAsIHQxID0gMS4wKSB7XHJcbiAgICAgICAgLy8gaWYgKHQwID4gdDEpIGNvbnNvbGUuZXJyb3IoXCJjcmVhdGVkIGEgZG9tYWluIHdpdGggbmVnYXRpdmUgc2l6ZS5cIik7XHJcbiAgICAgICAgLy8gaWYgKHQwID09IHQxKSBjb25zb2xlLndhcm4oXCJjcmVhdGVkIGEgZG9tYWluIHdpdGggc2l6ZSBpcyAwLjAuIGNvdWxkIGNhdXNlIHByb2JsZW1zXCIpO1xyXG4gICAgICAgIHRoaXMudDAgPSB0MDtcclxuICAgICAgICB0aGlzLnQxID0gdDE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVJhZGl1cyhyKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb21haW4oLXIsIHIpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21JbmNsdWRlKGRhdGEpIHtcclxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgZG9tYWluIHdoaWNoIGJvdW5kcyBhbGwgcGFyc2VkIHZhbHVlc1xyXG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBtYXggPSBOdW1iZXIuTUlOX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVtpXSA8IG1pbilcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldID4gbWF4KVxyXG4gICAgICAgICAgICAgICAgbWF4ID0gZGF0YVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb21haW4obWluLCBtYXgpO1xyXG4gICAgfVxyXG4gICAgb2Zmc2V0KHQwT2Zmc2V0LCB0MU9mZnNldCkge1xyXG4gICAgICAgIHRoaXMudDAgKz0gdDBPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy50MSArPSB0MU9mZnNldDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGluY2x1ZGVzKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gbm90ZTogaW5jbHVkaW5nIHQwLCBpbmNsdWRpbmcgdDFcclxuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy50MCAmJiB2YWx1ZSA8PSB0aGlzLnQxO1xyXG4gICAgfVxyXG4gICAgc2l6ZSgpIHtcclxuICAgICAgICAvLyB0aGUgc2l6ZSBvciBsZW5ndGggb2YgdGhpcyBkb21haW5cclxuICAgICAgICByZXR1cm4gdGhpcy50MSAtIHRoaXMudDA7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemUodmFsdWUpIHtcclxuICAgICAgICAvLyBub3JtYWxpemUgYSBwYXJhbWV0ZXJcclxuICAgICAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy50MCkgLyB0aGlzLnNpemUoKTtcclxuICAgIH1cclxuICAgIGVsZXZhdGUodCkge1xyXG4gICAgICAgIC8vIGVsZXZhdGUgYSBub3JtYWxpemVkIHBhcmFtZXRlciB0byB0aGUgcGFyYW1ldGVyIHNwYWNlIG9mIHRoaXMgZG9tYWluXHJcbiAgICAgICAgcmV0dXJuIHQgKiB0aGlzLnNpemUoKSArIHRoaXMudDA7XHJcbiAgICB9XHJcbiAgICByZW1hcCh2YWx1ZSwgb3RoZXIgPSBuZXcgRG9tYWluKCkpIHtcclxuICAgICAgICAvLyBub3JtYWxpemUgYSB2YWx1ZSwgdGhlbiBlbGV2YXRlIGl0IHRvIGEgbmV3IGRvbWFpblxyXG4gICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBvdGhlci5lbGV2YXRlKG5vcm0pO1xyXG4gICAgfVxyXG4gICAgKml0ZXIoY291bnQpIHtcclxuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgdGhpcyBEb21haW4gJ2NvdW50JyBudW1iZXIgb2YgdGltZXNcclxuICAgICAgICBsZXQgc3RlcCA9IHRoaXMuc2l6ZSgpIC8gY291bnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudDA7IGkgPCB0aGlzLnQxOyBpICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgeWllbGQgaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAqaXRlclN0ZXAoc3RlcCkge1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGlzIGRvbWFpbiB3aXRoIGEgc3RlcHNpemUgb2YgJ3N0ZXAnXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMudDA7IGkgPCB0aGlzLnQxOyBpICs9IHN0ZXApIHtcclxuICAgICAgICAgICAgeWllbGQgaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjb21mb3JtIGEgbnVtYmVyIHRvIHRoZSBib3VuZFxyXG4gICAgY29tZm9ybSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMudDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID4gdGhpcy50MSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIERvbWFpbjIge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IG5ldyBEb21haW4oKSwgeSA9IG5ldyBEb21haW4oKSkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUmFkaXVzKHIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvbWFpbjIoRG9tYWluLmZyb21SYWRpdXMociksIERvbWFpbi5mcm9tUmFkaXVzKHIpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tQm91bmRzKHgwLCB4MSwgeTAsIHkxKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb21haW4yKG5ldyBEb21haW4oeDAsIHgxKSwgbmV3IERvbWFpbih5MCwgeTEpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSW5jbHVkZShkYXRhKSB7XHJcbiAgICAgICAgLy8gbm90ZSA6IGNvdWxkIGJlIHF1aWNrZXIgYnkgZ29pbmcgdmVyYm9zZSwgdGhpcyBub3cgaXRlcmF0ZXMgb3ZlciBkYXRhIDQgdGltZXNcclxuICAgICAgICByZXR1cm4gbmV3IERvbWFpbjIoRG9tYWluLmZyb21JbmNsdWRlKGRhdGEuZ2V0Q29sdW1uKDApKSwgRG9tYWluLmZyb21JbmNsdWRlKGRhdGEuZ2V0Q29sdW1uKDEpKSk7XHJcbiAgICB9XHJcbiAgICBvZmZzZXQoeFh5WW9mZnNldCkge1xyXG4gICAgICAgIGxldCBvZmYgPSB4WHlZb2Zmc2V0O1xyXG4gICAgICAgIGlmIChvZmYubGVuZ3RoICE9IDQpXHJcbiAgICAgICAgICAgIHRocm93IFwibmVlZCA0IHZhbHVlc1wiO1xyXG4gICAgICAgIHRoaXMueC5vZmZzZXQob2ZmWzBdLCBvZmZbMV0pO1xyXG4gICAgICAgIHRoaXMueS5vZmZzZXQob2ZmWzJdLCBvZmZbM10pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaW5jbHVkZXModmFsdWUpIHtcclxuICAgICAgICAvLyBub3RlOiBpbmNsdWRpbmcgdDAsIGluY2x1ZGluZyB0MVxyXG4gICAgICAgIHJldHVybiB0aGlzLnguaW5jbHVkZXModmFsdWUueCkgJiYgdGhpcy55LmluY2x1ZGVzKHZhbHVlLnkpO1xyXG4gICAgfVxyXG4gICAgc2l6ZSgpIHtcclxuICAgICAgICAvLyB0aGUgc2l6ZSBvciBsZW5ndGggb2YgdGhpcyBkb21haW5cclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54LnNpemUoKSwgdGhpcy55LnNpemUoKSk7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemUodmFsdWUpIHtcclxuICAgICAgICAvLyBub3JtYWxpemUgYSBwYXJhbWV0ZXJcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIodGhpcy54Lm5vcm1hbGl6ZSh2YWx1ZS54KSwgdGhpcy55Lm5vcm1hbGl6ZSh2YWx1ZS55KSk7XHJcbiAgICB9XHJcbiAgICBlbGV2YXRlKHQpIHtcclxuICAgICAgICAvLyBlbGV2YXRlIGEgbm9ybWFsaXplZCBwYXJhbWV0ZXIgdG8gdGhlIHBhcmFtZXRlciBzcGFjZSBvZiB0aGlzIGRvbWFpblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnguZWxldmF0ZSh0LngpLCB0aGlzLnkuZWxldmF0ZSh0LnkpKTtcclxuICAgIH1cclxuICAgIHJlbWFwKHZhbHVlLCBvdGhlciA9IG5ldyBEb21haW4yKCkpIHtcclxuICAgICAgICAvLyBub3JtYWxpemUgYSB2YWx1ZSwgdGhlbiBlbGV2YXRlIGl0IHRvIGEgbmV3IGRvbWFpblxyXG4gICAgICAgIGxldCBub3JtID0gdGhpcy5ub3JtYWxpemUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBvdGhlci5lbGV2YXRlKG5vcm0pO1xyXG4gICAgfVxyXG4gICAgY29ybmVycygpIHtcclxuICAgICAgICAvLyByZW5kZXIgdGhlIGV4dGVuZHMgb2YgdGhpcyBib3VuZGFyeSAvIGRvbWFpblxyXG4gICAgICAgIGxldCBkaW0gPSAyO1xyXG4gICAgICAgIGxldCBjb3JuZXJzID0gTWF0aC5wb3coMiwgZGltKTtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHggb2YgW3RoaXMueC50MCwgdGhpcy54LnQxXSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5IG9mIFt0aGlzLnkudDAsIHRoaXMueS50MV0pIHtcclxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChuZXcgVmVjdG9yMih4LCB5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIERvbWFpbjMge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IG5ldyBEb21haW4oKSwgeSA9IG5ldyBEb21haW4oKSwgeiA9IG5ldyBEb21haW4oKSkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnogPSB6O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Cb3VuZHMoeDAsIHgxLCB5MCwgeTEsIHowLCB6MSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRG9tYWluMyhuZXcgRG9tYWluKHgwLCB4MSksIG5ldyBEb21haW4oeTAsIHkxKSwgbmV3IERvbWFpbih6MCwgejEpKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUmFkaXVzKHIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvbWFpbjMoRG9tYWluLmZyb21SYWRpdXMociksIERvbWFpbi5mcm9tUmFkaXVzKHIpLCBEb21haW4uZnJvbVJhZGl1cyhyKSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVJhZGlpKHJ4LCByeSwgcnopIHtcclxuICAgICAgICByZXR1cm4gbmV3IERvbWFpbjMoRG9tYWluLmZyb21SYWRpdXMocngpLCBEb21haW4uZnJvbVJhZGl1cyhyeSksIERvbWFpbi5mcm9tUmFkaXVzKHJ6KSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUluY2x1ZGUoZGF0YSkge1xyXG4gICAgICAgIC8vIG5vdGUgOiBjb3VsZCBiZSBxdWlja2VyIGJ5IGdvaW5nIHZlcmJvc2UsIHRoaXMgbm93IGl0ZXJhdGVzIG92ZXIgZGF0YSA2IHRpbWVzXHJcbiAgICAgICAgcmV0dXJuIG5ldyBEb21haW4zKERvbWFpbi5mcm9tSW5jbHVkZShkYXRhLmdldENvbHVtbigwKSksIERvbWFpbi5mcm9tSW5jbHVkZShkYXRhLmdldENvbHVtbigxKSksIERvbWFpbi5mcm9tSW5jbHVkZShkYXRhLmdldENvbHVtbigyKSkpO1xyXG4gICAgfVxyXG4gICAgb2Zmc2V0KHhYeVlvZmZzZXQpIHtcclxuICAgICAgICBsZXQgb2ZmID0geFh5WW9mZnNldDtcclxuICAgICAgICBpZiAob2ZmLmxlbmd0aCAhPSA2KVxyXG4gICAgICAgICAgICB0aHJvdyBcIm5lZWQgNiB2YWx1ZXNcIjtcclxuICAgICAgICB0aGlzLngub2Zmc2V0KG9mZlswXSwgb2ZmWzFdKTtcclxuICAgICAgICB0aGlzLnkub2Zmc2V0KG9mZlsyXSwgb2ZmWzNdKTtcclxuICAgICAgICB0aGlzLnoub2Zmc2V0KG9mZls0XSwgb2ZmWzVdKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGluY2x1ZGVzKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gbm90ZTogaW5jbHVkaW5nIHQwLCBpbmNsdWRpbmcgdDFcclxuICAgICAgICByZXR1cm4gdGhpcy54LmluY2x1ZGVzKHZhbHVlLngpICYmIHRoaXMueS5pbmNsdWRlcyh2YWx1ZS55KSAmJiB0aGlzLnouaW5jbHVkZXModmFsdWUueik7XHJcbiAgICB9XHJcbiAgICBzaXplKCkge1xyXG4gICAgICAgIC8vIHRoZSBzaXplIG9yIGxlbmd0aCBvZiB0aGlzIGRvbWFpblxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLnguc2l6ZSgpLCB0aGlzLnkuc2l6ZSgpLCB0aGlzLnouc2l6ZSgpKTtcclxuICAgIH1cclxuICAgIG5vcm1hbGl6ZSh2YWx1ZSkge1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBhIHBhcmFtZXRlclxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh0aGlzLngubm9ybWFsaXplKHZhbHVlLngpLCB0aGlzLnkubm9ybWFsaXplKHZhbHVlLnkpLCB0aGlzLnoubm9ybWFsaXplKHZhbHVlLnopKTtcclxuICAgIH1cclxuICAgIGVsZXZhdGUodCkge1xyXG4gICAgICAgIC8vIGVsZXZhdGUgYSBub3JtYWxpemVkIHBhcmFtZXRlciB0byB0aGUgcGFyYW1ldGVyIHNwYWNlIG9mIHRoaXMgZG9tYWluXHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKHRoaXMueC5lbGV2YXRlKHQueCksIHRoaXMueS5lbGV2YXRlKHQueSksIHRoaXMuei5lbGV2YXRlKHQueikpO1xyXG4gICAgfVxyXG4gICAgcmVtYXAodmFsdWUsIG90aGVyID0gbmV3IERvbWFpbjMoKSkge1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBhIHZhbHVlLCB0aGVuIGVsZXZhdGUgaXQgdG8gYSBuZXcgZG9tYWluXHJcbiAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG90aGVyLmVsZXZhdGUobm9ybSk7XHJcbiAgICB9XHJcbiAgICByZW1hcEFsbCh2YWx1ZXMsIG90aGVyID0gbmV3IERvbWFpbjMoKSkge1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSBhIHZhbHVlLCB0aGVuIGVsZXZhdGUgaXQgdG8gYSBuZXcgZG9tYWluXHJcbiAgICAgICAgbGV0IG5ld1ZhbHVlcyA9IG5ldyBWZWN0b3IzQXJyYXkodmFsdWVzLmNvdW50KCkpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmNvdW50KCk7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHZhbHVlcy5nZXRWZWN0b3IoaSkpO1xyXG4gICAgICAgICAgICBuZXdWYWx1ZXMuc2V0VmVjdG9yKGksIG90aGVyLmVsZXZhdGUobm9ybSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3VmFsdWVzO1xyXG4gICAgfVxyXG4gICAgY29ybmVycyhtYXRyaXgpIHtcclxuICAgICAgICAvLyByZW5kZXIgdGhlIGV4dGVuZHMgb2YgdGhpcyBib3VuZGFyeSAvIGRvbWFpblxyXG4gICAgICAgIGxldCBkaW0gPSAzO1xyXG4gICAgICAgIGxldCBjb3JuZXJzID0gMiBeIGRpbTtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IHggb2YgW3RoaXMueC50MCwgdGhpcy54LnQxXSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5IG9mIFt0aGlzLnkudDAsIHRoaXMueS50MV0pIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHogb2YgW3RoaXMuei50MCwgdGhpcy56LnQxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChtYXRyaXgubXVsdGlwbHlWZWN0b3IobmV3IFZlY3RvcjMoeCwgeSwgeikpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBjdWJlLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBSZXByZXNlbnRzIGEgY3ViZSBpbiAzZCBzcGFjZSwgaW4gYSBjZXJ0YWluIHBvc2UuXHJcbmltcG9ydCB7IERvbWFpbjMgfSBmcm9tIFwiLi4vbWF0aC9kb21haW5cIjtcclxuaW1wb3J0IHsgUGxhbmUgfSBmcm9tIFwiLi9wbGFuZVwiO1xyXG5leHBvcnQgY2xhc3MgQ3ViZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwbGFuZSwgZG9tYWluKSB7XHJcbiAgICAgICAgdGhpcy5wbGFuZSA9IHBsYW5lO1xyXG4gICAgICAgIHRoaXMuZG9tYWluID0gZG9tYWluO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhwbGFuZSwgZG9tYWluKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDdWJlKHBsYW5lLCBkb21haW4pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21SYWRpdXMocG9pbnQsIHJhZGl1cykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3ViZShQbGFuZS5Xb3JsZFhZKCkubW92ZVRvKHBvaW50KSwgRG9tYWluMy5mcm9tUmFkaXVzKHJhZGl1cykpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29ybmVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb21haW4uY29ybmVycyh0aGlzLnBsYW5lLm1hdHJpeCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gbmFtZTogICAgZ2VvLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBiYXNlIGNsYXNzIG9mIGFsbCAzZCBnZW9tZXRyeVxyXG4vLyBub3RlOiAgICBUT0RPXHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuLy8gaSB3YW50IHRyYWl0cy4uLi5cclxuZXhwb3J0IGNsYXNzIEdlbyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxyXG4gICAgY2xvbmUoKSB7IH1cclxuICAgIHRyYW5zZm9ybShtKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICByb3RhdGVYKHJhZGlhbnMpIHtcclxuICAgICAgICBsZXQgcm90YXRlciA9IE1hdHJpeDQubmV3WFJvdGF0aW9uKHJhZGlhbnMpO1xyXG4gICAgICAgIC8vIGV0Yy4uLlxyXG4gICAgfVxyXG4gICAgcm90YXRlWShyYWRpYW5zKSB7XHJcbiAgICAgICAgbGV0IHJvdGF0ZXIgPSBNYXRyaXg0Lm5ld1lSb3RhdGlvbihyYWRpYW5zKTtcclxuICAgICAgICAvLyBldGMuLi5cclxuICAgIH1cclxuICAgIHJvdGF0ZVoocmFkaWFucykge1xyXG4gICAgICAgIGxldCByb3RhdGVyID0gTWF0cml4NC5uZXdaUm90YXRpb24ocmFkaWFucyk7XHJcbiAgICAgICAgLy8gZXRjLi4uXHJcbiAgICB9XHJcbiAgICByb3RhdGUocmFkaWFucywgYXhpcykge1xyXG4gICAgICAgIGxldCByb3RhdGVyID0gTWF0cml4NC5uZXdBeGlzUm90YXRpb24oYXhpcywgcmFkaWFucyk7XHJcbiAgICAgICAgLy8gZXRjLi4uXHJcbiAgICB9XHJcbiAgICBtb3ZlKG0pIHtcclxuICAgICAgICBsZXQgbW92ZXIgPSBNYXRyaXg0Lm5ld1NjYWxlcihtLngsIG0ueSwgbS56KTtcclxuICAgICAgICAvLyBldGMuLi5cclxuICAgIH1cclxuICAgIHNjYWxlKHMpIHtcclxuICAgICAgICBsZXQgc2NhbGVyID0gTWF0cml4NC5uZXdTY2FsZXIocy54LCBzLnksIHMueik7XHJcbiAgICAgICAgLy8gZXRjLi5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb25zdCB9IGZyb20gXCIuLi9tYXRoL2NvbnN0XCI7XHJcbi8qKlxyXG4gKiBAcmV0dXJucyAtMSBpZiBubyBpbnRlcnNlY3Rpb24sIDAgb2YgcGFyYWxsZWwgb3IgdG91Y2hpbmcsIDEgaWYgaW50ZXJzZWN0aW9uO1xyXG4gKi9cclxuZnVuY3Rpb24gbGluZVhwbGFuZShsMSwgbDIsIHAxLCBwMiwgcDMpIHtcclxuICAgIGxldCB0ZXN0MSA9IHNpZ25lZF92b2x1bWUocDEsIHAyLCBwMywgbDEpO1xyXG4gICAgbGV0IHRlc3QyID0gc2lnbmVkX3ZvbHVtZShwMSwgcDIsIHAzLCBsMik7XHJcbiAgICBpZiAoTWF0aC5hYnModGVzdDEpIDwgQ29uc3QuVE9MRVJBTkNFIHx8IE1hdGguYWJzKHRlc3QyKSA8IENvbnN0LlRPTEVSQU5DRSkge1xyXG4gICAgICAgIHJldHVybiAwOyAvLyB0cmlhbmdsZSB0b3VjaGVzIHBsYW5lIHdpdGggYW4gZWRnZVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHRlc3QxIDwgMCAmJiB0ZXN0MiA+IDApIHx8ICh0ZXN0MSA+IDAgJiYgdGVzdDIgPCAwKSkge1xyXG4gICAgICAgIHJldHVybiAxOyAvLyBpZiAxIHRlc3QgcG9zIGFuZCBvdGhlciBuZWdhdGl2ZSAtPiBsaW5lIGludGVyc2VjdHMgcGxhbmUhXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gLTE7IC8vIG5vIGludGVyc2VjdGlvblxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgaWYgbGluZSBhbmQgdHJpYW5nbGUgaW50ZXJzZWN0XHJcbiAqXHJcbiAqIE5PVEUgd2UgY291bGQgZXhwYW5kIG9uIHRoZSAncmV0dXJuIDAnIGFuZCBleHBsb3JlIGlmIGl0cyB0b3VjaGluZyBhXHJcbiAgICB2ZXJ0ZXgsIGxpbmUsIG9yIHN1cmZhY2Ugb2YgdHJpYW5nZVxyXG4gKiBAcmV0dXJucyAwICBpZiBsaW5lIHRvdWNoZXMgdHJpYW5nbGVcclxuICAgICAgICAgICAgLTEgaWYgbGluZSBtaXNzZXMgIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAxICBpZiBsaW5lIGNyb3NzZXMgdHJpYW5nbGVcclxuICovXHJcbmZ1bmN0aW9uIGxpbmVYdHJpYW5nbGUobDEsIGwyLCBwMSwgcDIsIHAzKSB7XHJcbiAgICAvLyBsaW5lIHBvaW50cyBtdXN0IGJlIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSB0cmlhbmdsZVxyXG4gICAgLy8gcmV0dXJuIGltbWlkaWF0ZWx5IGlmIC0xOiBpdCBtZWFucyBubyBpbnRlcnNlY3Rpb24gYWx3YXlzXHJcbiAgICBsZXQgdGVzdDAgPSBsaW5lWHBsYW5lKGwxLCBsMiwgcDEsIHAyLCBwMyk7XHJcbiAgICBpZiAodGVzdDAgPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgLy8gcGxhbmUgdGVzdHNcclxuICAgIGxldCB0ZXN0MSA9IGxpbmVYcGxhbmUocDEsIHAyLCBsMSwgbDIsIHAzKTtcclxuICAgIGlmICh0ZXN0MSA9PSAtMSlcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBsZXQgdGVzdDIgPSBsaW5lWHBsYW5lKHAyLCBwMywgbDEsIGwyLCBwMSk7XHJcbiAgICBpZiAodGVzdDIgPT0gLTEpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgbGV0IHRlc3QzID0gbGluZVhwbGFuZShwMywgcDEsIGwxLCBsMiwgcDIpO1xyXG4gICAgaWYgKHRlc3QzID09IC0xKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIC8vIGRlYnVnXHJcbiAgICAvLyBwcmludChcInBvaW50czogXCIsIGwxLCBsMiwgcDEsIHAyLCBwMylcclxuICAgIC8vIHByaW50KCd0ZXN0czonLCB0ZXN0MCwgdGVzdDEsIHRlc3QyLCB0ZXN0MylcclxuICAgIC8vIGZpZ3VyZSBvdXQgaWYgdGhlIGxpbmUgdG91Y2hlcyB0aGUgdHJpYW5nbGUsIG9yIGlmIGl0IGludGVyc2VjdHNcclxuICAgIGlmICh0ZXN0MCA9PSAxICYmIHRlc3QxID09IDEgJiYgdGVzdDIgPT0gMSAmJiB0ZXN0MyA9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUT0RPIGJhc2VkIHVwb24gdGhlIGRpZmZlcmVudCB0ZXN0cywgd2UgY291bGQgZGV0ZXJtaW5lIHdoYXQgaXMgaGl0XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gc2lnbmVkX3ZvbHVtZShhLCBiLCBjLCBkKSB7XHJcbiAgICAvLyB3aXRoIHZlcnRpY2VzIGEsYixjLGQ6IGdldCBzaWduZWQgdm9sdW1lXHJcbiAgICAvLyByZW1lbWJlcjogdmVjdG9ycyBhbHdheXMgcmVtYWluIHN0YXRlLiBXZSBkb250IHdhbnQgdG8gYWx0ZXIgdGhlIGFiY2QgdmVjdG9ycy5cclxuICAgIGEgPSBhLmNsb25lKCk7XHJcbiAgICBiID0gYi5jbG9uZSgpO1xyXG4gICAgYyA9IGMuY2xvbmUoKTtcclxuICAgIHJldHVybiAoKDEgLyA2KSAqXHJcbiAgICAgICAgYVxyXG4gICAgICAgICAgICAuY2xvbmUoKVxyXG4gICAgICAgICAgICAuc3ViKGQpXHJcbiAgICAgICAgICAgIC5kb3QoYy5zdWIoZCkuY3Jvc3MoYi5zdWIoZCkpKSk7XHJcbn1cclxuZnVuY3Rpb24gSXNSb3VnaGx5KHRlc3QxLCBhcmcxKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQuXCIpO1xyXG59XHJcbiIsImltcG9ydCB7IERvbWFpbiB9IGZyb20gXCIuLi9tYXRoL2RvbWFpblwiO1xyXG5pbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbi8vIGhlYXZ5IHdlaWdodCBMaW5lIGNsYXNzXHJcbmV4cG9ydCBjbGFzcyBMaW5lQ3VydmUyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XHJcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcclxuICAgICAgICB0aGlzLnRvID0gdG87XHJcbiAgICAgICAgdGhpcy52ZWN0b3IgPSB0by5zdWJiZWQodGhpcy5mcm9tKTtcclxuICAgICAgICB0aGlzLm5vcm1hbCA9IHRoaXMudmVjdG9yLm5vcm1hbGl6ZWQoKTtcclxuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBEb21haW4oMCwgdGhpcy52ZWN0b3IubGVuZ3RoKCkpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy52ZWN0b3IubGVuZ3RoKCk7XHJcbiAgICB9XHJcbiAgICBhdCh0LCBib3VuZGVkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChib3VuZGVkKVxyXG4gICAgICAgICAgICB0ID0gdGhpcy5ib3VuZHMuY29tZm9ybSh0KTtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMi5mcm9tTGVycCh0aGlzLmZyb20sIHRoaXMudG8sIHQgLyB0aGlzLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBhdE5vcm1hbCh0LCBib3VuZGVkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChib3VuZGVkKVxyXG4gICAgICAgICAgICB0ID0gbmV3IERvbWFpbigwLCAxKS5jb21mb3JtKHQpO1xyXG4gICAgICAgIHJldHVybiBWZWN0b3IyLmZyb21MZXJwKHRoaXMuZnJvbSwgdGhpcy50bywgdCk7XHJcbiAgICB9XHJcbiAgICBjbG9zZXN0UG9pbnQocG9pbnQsIGJvdW5kZWQgPSB0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IHRoaXMudmVjdG9yLmxlbmd0aCgpO1xyXG4gICAgICAgIGlmIChkID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgbGV0IGxpbmVUb1BvaW50ID0gcG9pbnQuc3ViYmVkKHRoaXMuZnJvbSk7XHJcbiAgICAgICAgbGV0IGRvdCA9IGxpbmVUb1BvaW50LmRvdCh0aGlzLnZlY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoZG90LCBib3VuZGVkKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBWZWN0b3IyIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmltcG9ydCB7IFBsYW5lIH0gZnJvbSBcIi4vcGxhbmVcIjtcclxuZXhwb3J0IGNsYXNzIFJlY3RhbmdsZTIge1xyXG4gICAgY29uc3RydWN0b3IocG9zZSwgZG9tYWluKSB7XHJcbiAgICAgICAgdGhpcy5wb3NlID0gcG9zZTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcclxuICAgIH1cclxuICAgIGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NlLnRyYW5zZm9ybVZlY3RvcihuZXcgVmVjdG9yMigwLCAwKSk7XHJcbiAgICB9XHJcbiAgICBnZXRWZXJ0aWNlcygpIHtcclxuICAgICAgICBsZXQgdmVydHMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IyKHRoaXMuZG9tYWluLngudDAsIHRoaXMuZG9tYWluLnkudDApLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yMih0aGlzLmRvbWFpbi54LnQxLCB0aGlzLmRvbWFpbi55LnQwKSxcclxuICAgICAgICAgICAgbmV3IFZlY3RvcjIodGhpcy5kb21haW4ueC50MCwgdGhpcy5kb21haW4ueS50MSksXHJcbiAgICAgICAgICAgIG5ldyBWZWN0b3IyKHRoaXMuZG9tYWluLngudDEsIHRoaXMuZG9tYWluLnkudDEpLFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdmVydHMuZm9yRWFjaCgodikgPT4gdGhpcy5wb3NlLnRyYW5zZm9ybVZlY3Rvcih2KSk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRzO1xyXG4gICAgfVxyXG4gICAgdG8zRCgpIHtcclxuICAgICAgICBsZXQgbWF0NCA9IHRoaXMucG9zZS50b01hdDQoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZTMobmV3IFBsYW5lKG1hdDQpLCB0aGlzLmRvbWFpbik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFJlY3RhbmdsZTMge1xyXG4gICAgY29uc3RydWN0b3IocGxhbmUsIGRvbWFpbikge1xyXG4gICAgICAgIHRoaXMucGxhbmUgPSBwbGFuZTtcclxuICAgICAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcclxuICAgIH1cclxuICAgIGdldENvcm5lcnMoKSB7XHJcbiAgICAgICAgbGV0IGNvcm5lcnMgPSB0aGlzLmRvbWFpbi5jb3JuZXJzKCk7XHJcbiAgICAgICAgbGV0IGNvcm5lcnMzID0gY29ybmVycy5tYXAoKGMpID0+IHRoaXMucGxhbmUucHVzaFRvV29ybGQoYy50bzNEKCkpKTtcclxuICAgICAgICByZXR1cm4gY29ybmVyczM7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgVmVjdG9yMkFycmF5IH0gZnJvbSBcIi4uL2RhdGEvdmVjdG9yLWFycmF5XCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgTGluZUN1cnZlMiB9IGZyb20gXCIuL2xpbmVcIjtcclxuaW1wb3J0IHsgUGxhbmUgfSBmcm9tIFwiLi9wbGFuZVwiO1xyXG5leHBvcnQgY2xhc3MgVHJpYW5nbGUyIHtcclxuICAgIGNvbnN0cnVjdG9yKGEsIGIsIGMpIHtcclxuICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgdGhpcy5jID0gYztcclxuICAgIH1cclxuICAgIHBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gVmVjdG9yMkFycmF5LmZyb21MaXN0KFt0aGlzLmEsIHRoaXMuYiwgdGhpcy5jXSk7XHJcbiAgICB9XHJcbiAgICB0b0JhcnljZW50cmljKHBvaW50KSB7XHJcbiAgICAgICAgbGV0IHYwID0gdGhpcy5iLnN1YmJlZCh0aGlzLmEpO1xyXG4gICAgICAgIGxldCB2MSA9IHRoaXMuYy5zdWJiZWQodGhpcy5hKTtcclxuICAgICAgICBsZXQgdjIgPSBwb2ludC5zdWJiZWQodGhpcy5hKTtcclxuICAgICAgICBsZXQgZDAwID0gdjAuZG90KHYwKTtcclxuICAgICAgICBsZXQgZDAxID0gdjAuZG90KHYxKTtcclxuICAgICAgICBsZXQgZDExID0gdjEuZG90KHYxKTtcclxuICAgICAgICBsZXQgZDIwID0gdjIuZG90KHYwKTtcclxuICAgICAgICBsZXQgZDIxID0gdjIuZG90KHYxKTtcclxuICAgICAgICBsZXQgZGVub20gPSBkMDAgKiBkMTEgLSBkMDEgKiBkMDE7XHJcbiAgICAgICAgbGV0IHYgPSAoZDExICogZDIwIC0gZDAxICogZDIxKSAvIGRlbm9tO1xyXG4gICAgICAgIGxldCB3ID0gKGQwMCAqIGQyMSAtIGQwMSAqIGQyMCkgLyBkZW5vbTtcclxuICAgICAgICBsZXQgdSA9IDEuMCAtIHYgLSB3O1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh1LCB2LCB3KTtcclxuICAgIH1cclxuICAgIGZyb21CYXJ5Y2VudHJpYyhiYXJpKSB7XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLmEuc2NhbGVkKGJhcmkueCk7XHJcbiAgICAgICAgbGV0IGIgPSB0aGlzLmIuc2NhbGVkKGJhcmkueSk7XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmMuc2NhbGVkKGJhcmkueik7XHJcbiAgICAgICAgcmV0dXJuIGEuYWRkKGIpLmFkZChjKTtcclxuICAgIH1cclxuICAgIGNsb3Nlc3RQb2ludChwb2ludCkge1xyXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgcm91Z2hseSB3aGVyZSB0aGUgcG9pbnQgaXMuXHJcbiAgICAgICAgLy8gbm90ZTpcclxuICAgICAgICBsZXQgYWIgPSBwb2ludC5zaWduKHRoaXMuYSwgdGhpcy5iKTtcclxuICAgICAgICBsZXQgYmMgPSBwb2ludC5zaWduKHRoaXMuYiwgdGhpcy5jKTtcclxuICAgICAgICBsZXQgY2EgPSBwb2ludC5zaWduKHRoaXMuYywgdGhpcy5hKTtcclxuICAgICAgICAvLyBpZiBpdHMgZnVsbHkgd2l0aGluLCByZXR1cm4gaXQhXHJcbiAgICAgICAgaWYgKChhYiA8IDAgJiYgYmMgPCAwICYmIGNhIDwgMCkgfHwgKGFiID4gMCAmJiBiYyA+IDAgJiYgY2EgPiAwKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImZ1bGx5IGluc2lkZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBhYnMgPSBNYXRoLmFicyhhYik7XHJcbiAgICAgICAgICAgIGxldCBiY3MgPSBNYXRoLmFicyhiYyk7XHJcbiAgICAgICAgICAgIGxldCBjYXMgPSBNYXRoLmFicyhjYSk7XHJcbiAgICAgICAgICAgIGlmIChhYnMgPCBiY3MgJiYgYWJzIDwgY2FzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhYlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ3VydmUyKHRoaXMuYSwgdGhpcy5iKS5jbG9zZXN0UG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJjcyA8IGNhcykge1xyXG4gICAgICAgICAgICAgICAgLy8gYmNcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTGluZUN1cnZlMih0aGlzLmIsIHRoaXMuYykuY2xvc2VzdFBvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJ2ZTIodGhpcy5jLCB0aGlzLmEpLmNsb3Nlc3RQb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFRyaWFuZ2xlMyB7XHJcbiAgICBjb25zdHJ1Y3RvcihhLCBiLCBjKSB7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICB9XHJcbiAgICBwb2ludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmEsIHRoaXMuYiwgdGhpcy5jXTtcclxuICAgIH1cclxuICAgIGdldFBsYW5lKCkge1xyXG4gICAgICAgIHJldHVybiBQbGFuZS5mcm9tM3B0KHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMpO1xyXG4gICAgfVxyXG4gICAgdG8yRChwbGFuZSA9IFBsYW5lLldvcmxkWFkoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJpYW5nbGUyKHBsYW5lLnB1bGxUb1BsYW5lKHRoaXMuYSkudG8yRCgpLCBwbGFuZS5wdWxsVG9QbGFuZSh0aGlzLmIpLnRvMkQoKSwgcGxhbmUucHVsbFRvUGxhbmUodGhpcy5jKS50bzJEKCkpO1xyXG4gICAgfVxyXG4gICAgY2xvc2VzdFBvaW50KHBvaW50KSB7XHJcbiAgICAgICAgbGV0IHBsYW5lID0gdGhpcy5nZXRQbGFuZSgpO1xyXG4gICAgICAgIGxldCBbY3AsIF9dID0gcGxhbmUuY2xvc2VzdFBvaW50KHBvaW50KTtcclxuICAgICAgICBsZXQgcGxhbmVDUCA9IHBsYW5lLnB1bGxUb1BsYW5lKGNwKTtcclxuICAgICAgICBsZXQgcGxhbmVUcmlhbmdsZSA9IHRoaXMudG8yRChwbGFuZSk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG4gICAgLy8gVHJhbnNjcmliZWQgZnJvbSBDaHJpc3RlciBFcmljc29uJ3MgUmVhbC1UaW1lIENvbGxpc2lvbiBEZXRlY3Rpb246XHJcbiAgICAvLyBodHRwOi8vcmVhbHRpbWVjb2xsaXNpb25kZXRlY3Rpb24ubmV0L1xyXG4gICAgdG9CYXJ5Y2VudHJpYyhwb2ludCkge1xyXG4gICAgICAgIGxldCB2MCA9IHRoaXMuYi5zdWJiZWQodGhpcy5hKTtcclxuICAgICAgICBsZXQgdjEgPSB0aGlzLmMuc3ViYmVkKHRoaXMuYSk7XHJcbiAgICAgICAgbGV0IHYyID0gcG9pbnQuc3ViYmVkKHRoaXMuYSk7XHJcbiAgICAgICAgbGV0IGQwMCA9IHYwLmRvdCh2MCk7XHJcbiAgICAgICAgbGV0IGQwMSA9IHYwLmRvdCh2MSk7XHJcbiAgICAgICAgbGV0IGQxMSA9IHYxLmRvdCh2MSk7XHJcbiAgICAgICAgbGV0IGQyMCA9IHYyLmRvdCh2MCk7XHJcbiAgICAgICAgbGV0IGQyMSA9IHYyLmRvdCh2MSk7XHJcbiAgICAgICAgbGV0IGRlbm9tID0gZDAwICogZDExIC0gZDAxICogZDAxO1xyXG4gICAgICAgIGxldCB2ID0gKGQxMSAqIGQyMCAtIGQwMSAqIGQyMSkgLyBkZW5vbTtcclxuICAgICAgICBsZXQgdyA9IChkMDAgKiBkMjEgLSBkMDEgKiBkMjApIC8gZGVub207XHJcbiAgICAgICAgbGV0IHUgPSAxLjAgLSB2IC0gdztcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjModSwgdiwgdyk7XHJcbiAgICB9XHJcbiAgICBmcm9tQmFyeWNlbnRyaWMoYmFyaSkge1xyXG4gICAgICAgIGxldCBhID0gdGhpcy5hLmNsb25lKCkuc2NhbGUoYmFyaS54KTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuYi5jbG9uZSgpLnNjYWxlKGJhcmkueSk7XHJcbiAgICAgICAgbGV0IGMgPSB0aGlzLmMuY2xvbmUoKS5zY2FsZShiYXJpLnopO1xyXG4gICAgICAgIHJldHVybiBhLmFkZGVkKGIpLmFkZChjKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBGbG9hdE1hdHJpeCB9IGZyb20gXCIuLi9kYXRhL2Zsb2F0LW1hdHJpeFwiO1xyXG4vLyBrZXJuZWxzXHJcbmV4cG9ydCBjbGFzcyBLZXJuZWxzIHtcclxuICAgIC8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3l1dGExOTg0L0Nhbm55SlMvYmxvYi9tYXN0ZXIvY2FubnkuanNcclxuICAgIHN0YXRpYyBnZW5lcmF0ZUdhdXNzaWFuS2VybmVsKHNpZ21tYSwgc2l6ZSkge1xyXG4gICAgICAgIC8vIG1lc3N5LCBwcm9iYWJseSBhdXRvLWdlbmVyYXRlZFxyXG4gICAgICAgIHZhciBlLCBnYXVzc2lhbiwgaSwgaiwga2VybmVsLCBzLCBzdW0sIHgsIHksIF9pLCBfaiwgX2ssIF9sLCBfcmVmLCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xyXG4gICAgICAgIHMgPSBzaWdtbWE7XHJcbiAgICAgICAgZSA9IDIuNzE4O1xyXG4gICAgICAgIGtlcm5lbCA9IG5ldyBGbG9hdE1hdHJpeChzaXplLCBzaXplKTtcclxuICAgICAgICBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZiA9IHNpemUgLSAxOyAwIDw9IF9yZWYgPyBfaSA8PSBfcmVmIDogX2kgPj0gX3JlZjsgaSA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XHJcbiAgICAgICAgICAgIHggPSAtKHNpemUgLSAxKSAvIDIgKyBpO1xyXG4gICAgICAgICAgICBmb3IgKGogPSBfaiA9IDAsIF9yZWYxID0gc2l6ZSAtIDE7IDAgPD0gX3JlZjEgPyBfaiA8PSBfcmVmMSA6IF9qID49IF9yZWYxOyBqID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0gLShzaXplIC0gMSkgLyAyICsgajtcclxuICAgICAgICAgICAgICAgIGdhdXNzaWFuID0gKDEgLyAoMiAqIE1hdGguUEkgKiBzICogcykpICogTWF0aC5wb3coZSwgLSh4ICogeCArIHkgKiB5KSAvICgyICogcyAqIHMpKTtcclxuICAgICAgICAgICAgICAgIGtlcm5lbC5zZXQoaSwgaiwgZ2F1c3NpYW4pO1xyXG4gICAgICAgICAgICAgICAgc3VtICs9IGdhdXNzaWFuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IF9rID0gMCwgX3JlZjIgPSBzaXplIC0gMTsgMCA8PSBfcmVmMiA/IF9rIDw9IF9yZWYyIDogX2sgPj0gX3JlZjI7IGkgPSAwIDw9IF9yZWYyID8gKytfayA6IC0tX2spIHtcclxuICAgICAgICAgICAgZm9yIChqID0gX2wgPSAwLCBfcmVmMyA9IHNpemUgLSAxOyAwIDw9IF9yZWYzID8gX2wgPD0gX3JlZjMgOiBfbCA+PSBfcmVmMzsgaiA9IDAgPD0gX3JlZjMgPyArK19sIDogLS1fbCkge1xyXG4gICAgICAgICAgICAgICAga2VybmVsLnNldChpLCBqLCBrZXJuZWwuZ2V0KGksIGopIC8gc3VtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2VybmVsO1xyXG4gICAgfVxyXG59XHJcbktlcm5lbHMuU21vb3RoS2VybmVsID0gbmV3IEZsb2F0TWF0cml4KDMsIDMsIFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSkuZm9yRWFjaFZhbHVlKChpKSA9PiAoaSAqIDEpIC8gOSk7XHJcbktlcm5lbHMuU21vb3RoS2VybmVsNSA9IG5ldyBGbG9hdE1hdHJpeCg1LCA1LCBbXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG4gICAgMSxcclxuICAgIDEsXHJcbiAgICAxLFxyXG5dKS5mb3JFYWNoVmFsdWUoKHYpID0+ICh2ICogMSkgLyAyNSk7XHJcbktlcm5lbHMuR2F1c3M1ID0gbmV3IEZsb2F0TWF0cml4KDUsIDUsIFtcclxuICAgIDIsXHJcbiAgICA0LFxyXG4gICAgNSxcclxuICAgIDQsXHJcbiAgICAyLFxyXG4gICAgNCxcclxuICAgIDksXHJcbiAgICAxMixcclxuICAgIDksXHJcbiAgICA0LFxyXG4gICAgNSxcclxuICAgIDEyLFxyXG4gICAgMTUsXHJcbiAgICAxMixcclxuICAgIDUsXHJcbiAgICA0LFxyXG4gICAgOSxcclxuICAgIDEyLFxyXG4gICAgOSxcclxuICAgIDQsXHJcbiAgICAyLFxyXG4gICAgNCxcclxuICAgIDUsXHJcbiAgICA0LFxyXG4gICAgMixcclxuXSkuZm9yRWFjaFZhbHVlKCh2KSA9PiAodiAqIDEpIC8gMTU5KTtcclxuS2VybmVscy5UZXN0S2VybmVsID0gbmV3IEZsb2F0TWF0cml4KDMsIDMsIFsxLCAwLCAtMSwgMCwgMCwgMCwgLTEsIDAsIDFdKTtcclxuS2VybmVscy5Tb2JlbExlZnQgPSBuZXcgRmxvYXRNYXRyaXgoMywgMywgWzEsIDIsIDEsIDAsIDAsIDAsIC0xLCAtMiwgLTFdKTtcclxuS2VybmVscy5Tb2JlbFJpZ2h0ID0gbmV3IEZsb2F0TWF0cml4KDMsIDMsIFstMSwgLTIsIC0xLCAwLCAwLCAwLCAxLCAyLCAxXSk7XHJcbktlcm5lbHMuU29iZWxVcCA9IG5ldyBGbG9hdE1hdHJpeCgzLCAzLCBbMSwgMCwgLTEsIDIsIDAsIC0yLCAxLCAwLCAtMV0pO1xyXG5LZXJuZWxzLlNvYmVsRG93biA9IG5ldyBGbG9hdE1hdHJpeCgzLCAzLCBbLTEsIDAsIDEsIC0yLCAwLCAyLCAtMSwgMCwgMV0pO1xyXG4iLCIvLyBuYW1lOiAgICBsaW5lLXJlbmRlci1kYXRhLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiByZXByZXNlbnRzIGFuIG9iamVjdCB3aGljaCBjYW4gYmUgZmVkIGRpcmVjdGx5IHRvIGEgbGluZXJlbmRlcmVyLlxyXG4vLyAgICAgICAgICB1c2UgaXQgdG8gbm90IGNvbnRpbnVvdXNseSBoYXZlIHRvIGNhbGN1bGF0ZSB0aGVzZSBhc3BlY3RzIGlmIHRoZSB1bmRlcmx5aW5nIG9iamVjdCBpcyB1bmNoYW5nZWQuXHJcbmltcG9ydCB7IGdldEdlbmVyYWxGbG9hdE1hdHJpeCwgVmVjdG9yM0FycmF5IH0gZnJvbSBcIi4uL2RhdGEvdmVjdG9yLWFycmF5XCI7XHJcbmltcG9ydCB7IENvbnN0IH0gZnJvbSBcIi4uL21hdGgvY29uc3RcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG4vLyByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBtdWx0aXBsZSBsaW5lcy4gVGhlc2UgY291bGQgZm9ybSAxIHBvbHlsaW5lLCBidXQgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudFxyXG5leHBvcnQgY2xhc3MgTGluZUFycmF5IHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRzLCBpZHMpIHtcclxuICAgICAgICB0aGlzLnZlcnRzID0gdmVydHM7XHJcbiAgICAgICAgaWYgKGlkcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rcyA9IGdldERlZmF1bHRJbmRpY2VzKHZlcnRzLmNvdW50KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5saW5rcyA9IGlkcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyB0aGlzIGFzc3VtZXMgZXZlbiB2ZWN0aWNlcyBhcmUgJ2Zyb20nIHBvaW50cywgYW5kIG9kZCB2ZXJ0aWNlcyBhcmUgJ3RvJyBwb2ludHNcclxuICAgIHN0YXRpYyBmcm9tTGluZXModmVydHMpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IGdldEdlbmVyYWxGbG9hdE1hdHJpeCh2ZXJ0cyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQXJyYXkoZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvLyBnZXQgYWxsIGxpbmVzIGZyb20gYSBtZXNoXHJcbiAgICBzdGF0aWMgZnJvbU1lc2gocmVuZCwgdXYgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIDMgZWRnZXMgcGVyIGZhY2UsIDIgaW5kaWNlcyBwZXIgZWRnZVxyXG4gICAgICAgIGxldCBtZXNoID0gcmVuZC5tZXNoO1xyXG4gICAgICAgIGxldCBjb3VudCA9IG1lc2gubGlua3MuY291bnQoKSAqIDY7XHJcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgVWludDE2QXJyYXkoY291bnQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzaC5saW5rcy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGlEYXRhID0gaSAqIDY7XHJcbiAgICAgICAgICAgIGRhdGFbaURhdGFdID0gbWVzaC5saW5rcy5nZXQoaSwgMCk7XHJcbiAgICAgICAgICAgIGRhdGFbaURhdGEgKyAxXSA9IG1lc2gubGlua3MuZ2V0KGksIDEpO1xyXG4gICAgICAgICAgICBkYXRhW2lEYXRhICsgMl0gPSBtZXNoLmxpbmtzLmdldChpLCAxKTtcclxuICAgICAgICAgICAgZGF0YVtpRGF0YSArIDNdID0gbWVzaC5saW5rcy5nZXQoaSwgMik7XHJcbiAgICAgICAgICAgIGRhdGFbaURhdGEgKyA0XSA9IG1lc2gubGlua3MuZ2V0KGksIDIpO1xyXG4gICAgICAgICAgICBkYXRhW2lEYXRhICsgNV0gPSBtZXNoLmxpbmtzLmdldChpLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZUFycmF5KHJlbmQudXZzLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZUFycmF5KG1lc2gudmVydHMsIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGNyZWF0ZSBsaW5lcyBhcyBhIGdyaWQgY2VudGVyZWQgYXQgYSBwbGFuZVxyXG4gICAgc3RhdGljIGZyb21HcmlkKHBsYW5lLCBjb3VudCwgZGlzKSB7XHJcbiAgICAgICAgbGV0IGhhbGZUb3RhbFNpemUgPSAoKGNvdW50IC0gMSkgKiBkaXMpIC8gMjtcclxuICAgICAgICAvLyAyIHZlY3RvcnMgcGVyIGxpbmUsIDIgbGluZXMgcGVyIGNvdW50XHJcbiAgICAgICAgLy8gcGx1cyA1IGxpbmVzLCBmb3IgaWhhdCBhbmQgamhhdCBpY29uc1xyXG4gICAgICAgIGxldCBsaW5lcyA9IG5ldyBWZWN0b3IzQXJyYXkoY291bnQgKiA0KTtcclxuICAgICAgICAvLyB4IGxpbmVzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0ID0gLWhhbGZUb3RhbFNpemUgKyBkaXMgKiBpO1xyXG4gICAgICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaSAqIDIsIG5ldyBWZWN0b3IzKHQsIC1oYWxmVG90YWxTaXplLCAwKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnNldFZlY3RvcihpICogMiArIDEsIG5ldyBWZWN0b3IzKHQsIGhhbGZUb3RhbFNpemUsIDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8geSBsaW5lc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdCA9IC1oYWxmVG90YWxTaXplICsgZGlzICogaTtcclxuICAgICAgICAgICAgbGluZXMuc2V0VmVjdG9yKDIgKiBjb3VudCArIGkgKiAyLCBuZXcgVmVjdG9yMygtaGFsZlRvdGFsU2l6ZSwgLWhhbGZUb3RhbFNpemUgKyBkaXMgKiBpLCAwKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnNldFZlY3RvcigyICogY291bnQgKyBpICogMiArIDEsIG5ldyBWZWN0b3IzKGhhbGZUb3RhbFNpemUsIC1oYWxmVG90YWxTaXplICsgZGlzICogaSwgMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaW5hbGx5LCB0cmFuc2Zvcm0gZXZlcnl0aGluZyB0byB3b3JsZHNwYWNlLCBhbmQgY3JlYXRlIHRoZSBsaW5lcmVuZGVyZGF0YSBvYmplY3RcclxuICAgICAgICBsaW5lcy5mb3JFYWNoKCh2KSA9PiBwbGFuZS5wdXNoVG9Xb3JsZCh2KSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQXJyYXkobGluZXMpO1xyXG4gICAgfVxyXG4gICAgLy8gZ2V0IGFsbCBsaW5lcyBmcm9tIGEgcGxhbmVcclxuICAgIHN0YXRpYyBmcm9tUGxhbmUocGxhbmUpIHtcclxuICAgICAgICBsZXQgY291bnQgPSBDb25zdC5QTEFORV9SRU5ERVJfTElORUNPVU5UO1xyXG4gICAgICAgIGxldCBkaXMgPSBDb25zdC5QTEFORV9SRU5ERVJfTElORURJU1RBTkNFO1xyXG4gICAgICAgIGxldCBkaXNTbWFsbCA9IGRpcyAvIDEwO1xyXG4gICAgICAgIGxldCBoYWxmVG90YWxTaXplID0gKChjb3VudCAtIDEpICogZGlzKSAvIDI7XHJcbiAgICAgICAgLy8gMiB2ZWN0b3JzIHBlciBsaW5lLCAyIGxpbmVzIHBlciBjb3VudFxyXG4gICAgICAgIC8vIHBsdXMgNSBsaW5lcywgZm9yIGloYXQgYW5kIGpoYXQgaWNvbnNcclxuICAgICAgICBsZXQgbGluZXMgPSBuZXcgVmVjdG9yM0FycmF5KGNvdW50ICogNCArIDUgKiAyKTtcclxuICAgICAgICAvLyB4IGxpbmVzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB0ID0gLWhhbGZUb3RhbFNpemUgKyBkaXMgKiBpO1xyXG4gICAgICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaSAqIDIsIG5ldyBWZWN0b3IzKHQsIC1oYWxmVG90YWxTaXplLCAwKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnNldFZlY3RvcihpICogMiArIDEsIG5ldyBWZWN0b3IzKHQsIGhhbGZUb3RhbFNpemUsIDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8geSBsaW5lc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgdCA9IC1oYWxmVG90YWxTaXplICsgZGlzICogaTtcclxuICAgICAgICAgICAgbGluZXMuc2V0VmVjdG9yKDIgKiBjb3VudCArIGkgKiAyLCBuZXcgVmVjdG9yMygtaGFsZlRvdGFsU2l6ZSwgLWhhbGZUb3RhbFNpemUgKyBkaXMgKiBpLCAwKSk7XHJcbiAgICAgICAgICAgIGxpbmVzLnNldFZlY3RvcigyICogY291bnQgKyBpICogMiArIDEsIG5ldyBWZWN0b3IzKGhhbGZUb3RhbFNpemUsIC1oYWxmVG90YWxTaXplICsgZGlzICogaSwgMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpY29uIEkgIHRvIHNob3cgaWhhdFxyXG4gICAgICAgIGxldCBpY29uTGluZTEgPSBsaW5lcy5jb3VudCgpIC0gMTA7XHJcbiAgICAgICAgbGluZXMuc2V0VmVjdG9yKGljb25MaW5lMSwgbmV3IFZlY3RvcjMoaGFsZlRvdGFsU2l6ZSArIGRpc1NtYWxsLCAtZGlzU21hbGwsIDApKTtcclxuICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaWNvbkxpbmUxICsgMSwgbmV3IFZlY3RvcjMoaGFsZlRvdGFsU2l6ZSArIGRpc1NtYWxsICogNCwgZGlzU21hbGwsIDApKTtcclxuICAgICAgICBsZXQgaWNvbkxpbmUyID0gbGluZXMuY291bnQoKSAtIDg7XHJcbiAgICAgICAgbGluZXMuc2V0VmVjdG9yKGljb25MaW5lMiwgbmV3IFZlY3RvcjMoaGFsZlRvdGFsU2l6ZSArIGRpc1NtYWxsLCBkaXNTbWFsbCwgMCkpO1xyXG4gICAgICAgIGxpbmVzLnNldFZlY3RvcihpY29uTGluZTIgKyAxLCBuZXcgVmVjdG9yMyhoYWxmVG90YWxTaXplICsgZGlzU21hbGwgKiA0LCAtZGlzU21hbGwsIDApKTtcclxuICAgICAgICAvLyBpY29uIElJIHRvIHNob3cgamhhdFxyXG4gICAgICAgIGxldCBpY29uTGluZTMgPSBsaW5lcy5jb3VudCgpIC0gNjtcclxuICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaWNvbkxpbmUzLCBuZXcgVmVjdG9yMygwLCBoYWxmVG90YWxTaXplICsgZGlzU21hbGwgKiAyLjUsIDApKTtcclxuICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaWNvbkxpbmUzICsgMSwgbmV3IFZlY3RvcjMoZGlzU21hbGwsIGhhbGZUb3RhbFNpemUgKyBkaXNTbWFsbCAqIDQsIDApKTtcclxuICAgICAgICBsZXQgaWNvbkxpbmU0ID0gbGluZXMuY291bnQoKSAtIDQ7XHJcbiAgICAgICAgbGluZXMuc2V0VmVjdG9yKGljb25MaW5lNCwgbmV3IFZlY3RvcjMoZGlzU21hbGwsIGhhbGZUb3RhbFNpemUgKyBkaXNTbWFsbCwgMCkpO1xyXG4gICAgICAgIGxpbmVzLnNldFZlY3RvcihpY29uTGluZTQgKyAxLCBuZXcgVmVjdG9yMygtZGlzU21hbGwsIGhhbGZUb3RhbFNpemUgKyBkaXNTbWFsbCAqIDQsIDApKTtcclxuICAgICAgICAvLyBpY29uIElJSSB0byBzaG93IGtoYXQgLyBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgbGV0IGljb25MaW5lNSA9IGxpbmVzLmNvdW50KCkgLSAyO1xyXG4gICAgICAgIGxpbmVzLnNldFZlY3RvcihpY29uTGluZTUsIG5ldyBWZWN0b3IzKDAsIDAsIDApKTtcclxuICAgICAgICBsaW5lcy5zZXRWZWN0b3IoaWNvbkxpbmU1ICsgMSwgbmV3IFZlY3RvcjMoMCwgMCwgZGlzKSk7XHJcbiAgICAgICAgLy8gZmluYWxseSwgdHJhbnNmb3JtIGV2ZXJ5dGhpbmcgdG8gd29ybGRzcGFjZSwgYW5kIGNyZWF0ZSB0aGUgbGluZXJlbmRlcmRhdGEgb2JqZWN0XHJcbiAgICAgICAgbGluZXMuZm9yRWFjaCgodikgPT4gcGxhbmUucHVzaFRvV29ybGQodikpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZUFycmF5KGxpbmVzKTtcclxuICAgIH1cclxuICAgIC8vIGdldCBhbGwgbGluZXMgcmVwcmVzZW50aW5nIGEgY2lyY2xlIGluIDJkLiB1c2UgYW4gb3B0aW9uYWwgbWF0cml4IHRvXHJcbiAgICBzdGF0aWMgZnJvbUNpcmNsZShjKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gQ29uc3QuQ0lSQ0xFX1NFR01FTlRTO1xyXG4gICAgICAgIC8vIGxldCBjb3VudCA9IDEyO1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkoY291bnQpO1xyXG4gICAgICAgIC8vIHggbGluZXNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgLy8gcmFkaWFsIGZyYWN0aW9uIG9mIGEgY2lyY2xlXHJcbiAgICAgICAgICAgIGxldCB0ID0gKGkgLyBjb3VudCkgKiAoTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5zZXRWZWN0b3IoaSwgYy5wbGFuZS5wdXNoVG9Xb3JsZChuZXcgVmVjdG9yMyhNYXRoLmNvcyh0KSAqIGMucmFkaXVzLCBNYXRoLnNpbih0KSAqIGMucmFkaXVzLCAwKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmVBcnJheSh2ZXJ0cywgZ2V0UGFpckluZGljZXMoY291bnQpKTtcclxuICAgIH1cclxuICAgIC8vIHR1cm4gYSBzcGxpbmUgaW50byBhIHBvbHlsaW5lLCBhbmQgcmVuZGVyIGl0XHJcbiAgICBzdGF0aWMgZnJvbVNwbGluZSgpIHtcclxuICAgICAgICB0aHJvdyBcInRvZG8hXCI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUN1YmUoY3ViZSkge1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IFZlY3RvcjNBcnJheS5mcm9tTGlzdChjdWJlLmdldENvcm5lcnMoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQXJyYXkodmVydHMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Kb2luKGxpbmVzKSB7XHJcbiAgICAgICAgLy8gam9pbiBtZXNoZXMsIGRvbnQgdHJ5IHRvIGxvb2sgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlc1xyXG4gICAgICAgIC8vIFRPRE8gOiBtYWtlIHRoaXMgdGhlIHRyb3VibGUgb2YgTWF0cmljZXMgYW5kIEFycmF5c1xyXG4gICAgICAgIGxldCBpZHNDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IHZlcnRDb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgICAgICBpZHNDb3VudCArPSBsaW5lLmxpbmtzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmVydENvdW50ICs9IGxpbmUudmVydHMuY291bnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHZlcnRzID0gbmV3IFZlY3RvcjNBcnJheSh2ZXJ0Q291bnQpO1xyXG4gICAgICAgIGxldCBpZHMgPSBuZXcgVWludDE2QXJyYXkoaWRzQ291bnQpO1xyXG4gICAgICAgIGxldCBhY2NWZXJ0cyA9IDA7XHJcbiAgICAgICAgbGV0IGFjY0ZhY2VzID0gMDtcclxuICAgICAgICBmb3IgKGxldCBsaW5lc2V0IG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNldC52ZXJ0cy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnNldFJvdyhhY2NWZXJ0cyArIGksIGxpbmVzZXQudmVydHMuZ2V0Um93KGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzZXQubGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlkc1thY2NGYWNlcyArIGldID0gbGluZXNldC5saW5rc1tpXSArIGFjY1ZlcnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY1ZlcnRzICs9IGxpbmVzZXQudmVydHMuY291bnQoKTtcclxuICAgICAgICAgICAgYWNjRmFjZXMgKz0gbGluZXNldC5saW5rcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTGluZUFycmF5KHZlcnRzLCBpZHMpO1xyXG4gICAgfVxyXG59XHJcbi8vIGp1c3QgZ2V0IGFuIGludCBzZXF1ZW5jZSBmcm9tIDAgdG8gbGVuZ3RoLlxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEluZGljZXMoY291bnQpIHtcclxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGNvdW50KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIGRhdGFbaV0gPSBpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UGFpckluZGljZXMoY291bnQpIHtcclxuICAgIC8vIGdpdmVuIGNvdW50IG9mIDMgPT4gcmV0dXJuIDAsMSB8IDEsMiB8IDIsMFxyXG4gICAgbGV0IGxlbmd0aCA9IGNvdW50ICogMjtcclxuICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICBkYXRhW2kgKiAyXSA9IGk7XHJcbiAgICAgICAgZGF0YVtpICogMiArIDFdID0gKGkgKyAxKSAlIGNvdW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuIiwiLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IGluZmluaXRlIFJheSB1c2VkIGZvciBwcm9qZWN0aW9uIGFuZCBzaW1pbGFyIGFjdGlvbnNcclxuLy8gbm90ZXM6ICAgZm91bmQgc29tZSBuaWNlIGV4YW1wbGVzIGF0IGh0dHBzOi8vd3d3LmNzLnByaW5jZXRvbi5lZHUvY291cnNlcy9hcmNoaXZlL2ZhbGwwMC9jczQyNi9sZWN0dXJlcy9yYXljYXN0L3NsZDAwNC5odG1cclxuaW1wb3J0IHsgTGluZUFycmF5IH0gZnJvbSBcIi4uL21lc2gvbGluZS1hcnJheVwiO1xyXG5leHBvcnQgY2xhc3MgUmF5IHtcclxuICAgIC8vIGkgZG8gdGhpcyB0byBmb3JjZSBpbnRlbnQgOiBmcm9tIHBvaW50cywgb3IgZnJvbSBub3JtYWwuIEJvdGggdmVjdG9yMywgc28gb3RoZXJ3aXNlIGNvbmZ1c2luZ1xyXG4gICAgY29uc3RydWN0b3Iob3JpZ2luLCBub3JtYWwpIHtcclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbC5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tTm9ybWFsKG9yaWdpbiwgbm9ybWFsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYXkob3JpZ2luLCBub3JtYWwpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Qb2ludHMob3JpZ2luLCB0aHJvdWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSYXkob3JpZ2luLCB0aHJvdWdoLnN1YmJlZChvcmlnaW4pLm5vcm1hbGl6ZSgpKTtcclxuICAgIH1cclxuICAgIGF0KHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4uYWRkZWQodGhpcy5ub3JtYWwuc2NhbGVkKHQpKTtcclxuICAgIH1cclxuICAgIHhQbGFuZShwbGFuZSkge1xyXG4gICAgICAgIC8vIHJheSA6IHB0ID0gck9yaWdpbiArIHQgKiByTm9ybWFsXHJcbiAgICAgICAgLy8gcGxhbmUgOiBhLCBiLCBjLCBkIC0+IHBOb3JtYWwoYSwgYiwgYykgLCBkXHJcbiAgICAgICAgLy8gcGxhbmUgOiBQIC4gTiArIGQgPSAwO1xyXG4gICAgICAgIC8vIHN1YnN0aXR1dGUgZm9yIHA6XHJcbiAgICAgICAgLy8gdCA9IC0ock9yaWdpbiAuIE4gKyBkKSAvIChWIC4gTilcclxuICAgICAgICBsZXQgcmF5ID0gdGhpczsgLy8gdG8gYmUgY2xlYXJcclxuICAgICAgICByZXR1cm4gLShyYXkub3JpZ2luLmRvdChwbGFuZS5ub3JtYWwpICsgcGxhbmUuZCkgLyByYXkubm9ybWFsLmRvdChwbGFuZS5ub3JtYWwpO1xyXG4gICAgfVxyXG4gICAgdG9MaW5lKGxlbmd0aCkge1xyXG4gICAgICAgIGxldCB0b1BvaW50ID0gdGhpcy5hdChsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBMaW5lQXJyYXkuZnJvbUxpbmVzKFt0aGlzLm9yaWdpbiwgdG9Qb2ludF0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEhhc2hUYWJsZSB9IGZyb20gXCIuLi9kYXRhL2hhc2gtdGFibGVcIjtcclxuaW1wb3J0IHsgSW50TWF0cml4IH0gZnJvbSBcIi4uL2RhdGEvaW50LW1hdHJpeFwiO1xyXG5pbXBvcnQgeyBWZWN0b3IzQXJyYXkgfSBmcm9tIFwiLi4vZGF0YS92ZWN0b3ItYXJyYXlcIjtcclxuaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG5pbXBvcnQgeyBSZW5kZXJhYmxlIH0gZnJvbSBcIi4vcmVuZGVyLW1lc2hcIjtcclxuaW1wb3J0IHsgVHJpYW5nbGUyLCBUcmlhbmdsZTMgfSBmcm9tIFwiLi4vZ2VvL3RyaWFuZ2xlXCI7XHJcbi8vIGEgbWVzaCB3aXRoIHRvcG9sb2dpY2FsIGluZm9ybWF0aW9uXHJcbmV4cG9ydCBjbGFzcyBUb3BvTWVzaCBleHRlbmRzIFJlbmRlcmFibGUge1xyXG4gICAgLy8gcHJpdmF0ZSAtPiBzaG91bGQgb25seSBiZSB1c2VkIHdpdGggZmFjdG9yeSBtZXRob2RzXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0Q291bnQsIG5vcm1Db3VudCwgdXZDb3VudCwgZmFjZUNvdW50LCB0ZXh0dXJlID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc3VwZXIodmVydENvdW50LCBub3JtQ291bnQsIHV2Q291bnQsIGZhY2VDb3VudCwgdGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5sYXN0VG91Y2hlZCA9IDA7IC8vIG5lZWRlZCBmb3IgdHJpYW5nbGUgd2Fsa1xyXG4gICAgICAgIHRoaXMubmVpZ2hib3JNYXAgPSBuZXcgSW50TWF0cml4KHRoaXMubWVzaC5saW5rcy5jb3VudCgpLCAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb3B5RnJvbVJlbmRlcmFibGUocmVuZCkge1xyXG4gICAgICAgIGxldCB0b3BvTWVzaCA9IG5ldyBUb3BvTWVzaChyZW5kLm1lc2gudmVydHMuY291bnQoKSwgcmVuZC5ub3Jtcy5jb3VudCgpLCByZW5kLnV2cy5jb3VudCgpLCByZW5kLm1lc2gubGlua3MuY291bnQoKSk7XHJcbiAgICAgICAgdG9wb01lc2gubWVzaC52ZXJ0cyA9IHJlbmQubWVzaC52ZXJ0cy5jbG9uZSgpO1xyXG4gICAgICAgIHRvcG9NZXNoLm5vcm1zID0gcmVuZC5ub3Jtcy5jbG9uZSgpO1xyXG4gICAgICAgIHRvcG9NZXNoLnV2cyA9IHJlbmQudXZzLmNsb25lKCk7XHJcbiAgICAgICAgdG9wb01lc2gubWVzaC5saW5rcyA9IHJlbmQubWVzaC5saW5rcy5jbG9uZSgpO1xyXG4gICAgICAgIHRvcG9NZXNoLnNldE5laWdoYm9yTWFwKCk7XHJcbiAgICAgICAgcmV0dXJuIHRvcG9NZXNoO1xyXG4gICAgfVxyXG4gICAgc2V0TmVpZ2hib3JNYXAoKSB7XHJcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgZmlsbHMgdGhpcy5uZWlnaGJvck1hcCBhZnRlciBkYXRhIGlzIGxvYWRlZFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgbGV0IGVkZ2VzID0gbmV3IEhhc2hUYWJsZSgpO1xyXG4gICAgICAgIGxldCBwYWlycyA9IG5ldyBIYXNoVGFibGUoKTtcclxuICAgICAgICAvLyAxIHwgcGVyIHRyaWFuZ2xlXHJcbiAgICAgICAgdGhpcy5tZXNoLmxpbmtzLmZvckVhY2hSb3coKGYsIGZhY2VJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZmFjZUVkZ2VzID0gW1xyXG4gICAgICAgICAgICAgICAgW2ZbMF0sIGZbMV1dLFxyXG4gICAgICAgICAgICAgICAgW2ZbMV0sIGZbMl1dLFxyXG4gICAgICAgICAgICAgICAgW2ZbMl0sIGZbMF1dLFxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICBmYWNlRWRnZXMuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgKDQsIDEpLCBvcmllbnRhdGlvbiBpcyBUcnVlIHwgaWYgKDEsIDQpLCBvcmllbnRhdGlvbiBpcyBGYWxzZVxyXG4gICAgICAgICAgICAgICAgbGV0IG9yaWVudGF0aW9uID0gZVswXSA+IGVbMV07XHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhpcyBtaW4gbWF4IGNvbnN0cnVjdGlvbiB0byBvbmx5IHN0b3JlIG9uZSBlZGdlIHBlciB0cmlhbmdsZSBwYWlyXHJcbiAgICAgICAgICAgICAgICAvLyBsZXQgZWRnZTogW251bWJlciwgbnVtYmVyXSA9IGUuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSBuZXcgSW50MzJBcnJheShbTWF0aC5taW4oLi4uZSksIE1hdGgubWF4KC4uLmUpXSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlZGdlKTtcclxuICAgICAgICAgICAgICAgIGlmICghZWRnZXMuaGFzKGVkZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3JpZW50YXRpb24sIGZpcnN0IHRyIElELCBzZWNvbmQgdHIgSURcclxuICAgICAgICAgICAgICAgICAgICBlZGdlcy5zZXQoZWRnZSwgW29yaWVudGF0aW9uLCBmYWNlSW5kZXgsIC0xXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBlZGdlIG1hdGNoIGlzIG1hZGUhXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJtYXRjaGVkIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb3RoZXIgPSBlZGdlcy5nZXQoZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5iT3JpZW50YXRpb24gPSBvdGhlclswXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmJJbmRleCA9IG90aGVyWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyWzJdID0gZmFjZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLnNldChlZGdlLCBvdGhlcik7IC8vIGVkZ2UgaXMgcHV0IGF3YXkgYWdhaW4sIGlmIGFuIGVkZ2UgbWFwIGlzIGV2ZXIgbmVlZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBuZWlnaGJvdXJzXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROYihmYWNlSW5kZXgsIGVkZ2UsIG5iSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TmIobmJJbmRleCwgZWRnZSwgZmFjZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhpcyBpbmZvIHRvIGZpbGwgc2VsZi5wYWlyc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG9yaWVudGF0aW9uICE9IG90aGVyIG9yaWVudGF0aW9uLCBlZGdlIGlzICdnb29kJyAtPiBGYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgLT4gVHJ1ZSwgb25lIG9mIHRoZSBuZWlnaGJvdXIgdHJpYW5nbGVzIG5lZWRzIHRvIGJlIGZsaXBwZWRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFpciA9IFtuYkluZGV4LCBmYWNlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhaXIuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhaXIgPSAoTWF0aC5taW4oLi4ucGFpciksIE1hdGgubWF4KC4uLnBhaXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiAhPSBuYk9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWlycy5zZXQocGFpciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpcnMuc2V0KHBhaXIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEb25lLiBHaXZlIGZlZWRiYWNrXHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAvLyBmb3IgcGFpciBpbiBwYWlycy5pdGVtcygpOlxyXG4gICAgICAgIC8vICAgICBpZiBub3QgcGFpcjogY291bnQgKz0xO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwibnVtYmVyIG9mICd3cm9uZycgZmFjZSBuZWlnaGJvdXJzOiBcIiwgY291bnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0cmlhbmdsZSBiYXNlZCBvbiBhIFVWIHBvaW50IHNvbWV3aGVyZSBvbiB0aGUgbWVzaC5cclxuICAgICAqIFJldHVybnMgLTEgaWYgdGhlIHBvaW50IGlzIG5vdCBvbiB0aGUgbWVzaCBUT0RPIE9SIElGIFRIRSBQQVRIIEhBUyBIT0xFUyBJTiBJVCBUT0RPIEZJWCBUSElTIVxyXG4gICAgICogQHBhcmFtICB7VmVjdG9yMn0gcG9pbnRcclxuICAgICAqIEByZXR1cm5zIHRyaWFuZ2xlSW5kZXgsIG9yIC0xIGlmIGZhaWx1cmVcclxuICAgICAqL1xyXG4gICAgd2Fsa1VWKHBvaW50KSB7XHJcbiAgICAgICAgLy8gc3RhcnQgd2hlcmUgd2UgbGFzdCBzdG9wcGVkXHJcbiAgICAgICAgbGV0IGZhY2VJbmRleCA9IHRoaXMubGFzdFRvdWNoZWQ7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIG5ldmVyIHRha2UgbW9yZSBzdGVwcyB0aGFuIHRyaWFuZ2xlcyBpbiB0aGUgdHJpYW5ndWxhdGlvbi5cclxuICAgICAgICAvLyB0aGlzIHdvdWxkIG1lYW4gc29tZXRoaW5nIHdlbnQgd3JvbmdcclxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLm1lc2gubGlua3MuY291bnQoKTtcclxuICAgICAgICBmb3IgKGxldCBfID0gMDsgXyA8IGNvdW50OyBfKyspIHtcclxuICAgICAgICAgICAgLy8gaSBkb250IGtub3cgaG93LCBidXQgaWYgd2UgYWNjaWRlbnRhbGx5IGxhbmRlZCBvdXRzaWRlIG9mIHRoZSBtZXNoXHJcbiAgICAgICAgICAgIGlmIChmYWNlSW5kZXggPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGogPSAoaSArIDEpICUgMztcclxuICAgICAgICAgICAgICAgIGxldCBmYWNlID0gdGhpcy5tZXNoLmxpbmtzLmdldFJvdyhmYWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVkZ2UgPSBbZmFjZVtpXSwgZmFjZVtqXV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYiA9IHRoaXMudXZzLmdldFZlY3RvcihlZGdlWzBdKTtcclxuICAgICAgICAgICAgICAgIGxldCBjID0gdGhpcy51dnMuZ2V0VmVjdG9yKGVkZ2VbMV0pO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpZ24gPSBwb2ludC5zaWduKGIsIGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjZUluZGV4ID0gdGhpcy5nZXROYihmYWNlSW5kZXgsIGVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0cyBvdXNpZGUsIHJldHVybiAtMVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWNlSW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiBnbyB0aGVyZSBpbW1pZGlhdGVseVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdFRvdWNoZWQgPSBmYWNlSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHJhbiAzIHRpbWVzLCB0aGUgcG9pbnQgbXVzdCBiZSB3aXRoaW4gdGhlIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWNlSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICAvLyBmaW5kIHRoZSBmYWNlcyBjbG9zZXN0IHRvIHRoZSBwb2ludFxyXG4gICAgLy8gLTEgaWYgdGhlIG1lc2ggZG9lcyBub3QgY29udGFpbiB0cmlhbmdsZXNcclxuICAgIGNsb3Nlc3RGYWNlcyhwb2ludCkge1xyXG4gICAgICAgIGxldCBjbG9zZXN0VmVydGV4SWQgPSB0aGlzLm1lc2gudmVydHMuY2xvc2VzdElkKHBvaW50KTtcclxuICAgICAgICAvLyBnZXQgYWxsIGZhY2UgaWRzIGNvbnRhaW5pbmcgY2xvc2VzdFZlcnRleCwgYWxvbmcgd2l0aCB0aGVpciBjZW50ZXJzXHJcbiAgICAgICAgbGV0IGNsb3Nlc3RGYWNlcyA9IFtdO1xyXG4gICAgICAgIC8vbGV0IGNlbnRlcnM6IFZlY3RvcjNbXSA9IFtdXHJcbiAgICAgICAgdGhpcy5tZXNoLmxpbmtzLmZvckVhY2hSb3coKHRyLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0ci5pbmNsdWRlcyhjbG9zZXN0VmVydGV4SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0RmFjZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgIC8vbGV0IGNlbnRlciA9IFZlY3RvcjNBcnJheS5mcm9tTGlzdCh0aGlzLmdldEZhY2VQb2ludHMoaSwgZmFsc2UpKS5hdmVyYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAvL2NlbnRlcnMucHVzaChjZW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc2VsZWN0IHRoZSB0cmlhbmdsZSB3aXRoIHRoZSBjbG9zZXN0IGJhcmljZW50ZXJcclxuICAgICAgICByZXR1cm4gY2xvc2VzdEZhY2VzO1xyXG4gICAgfVxyXG4gICAgZWxldmF0ZShwKSB7XHJcbiAgICAgICAgLy8gJ2VsZXZhdGUnIGEgcG9pbnQgaW4gVVYgc3BhY2UgdG8gdmVydGV4IHNwYWNlIHVzaW5nIGEgYmFyeWNlbnRyaWMgcmVtYXBcclxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoZXJlIHRoaXMgcG9pbnQgaXMgbG9jYXRlZCBvbiB0aGUgbWVzaFxyXG4gICAgICAgIGxldCBmYWNlID0gdGhpcy53YWxrVVYocCk7XHJcbiAgICAgICAgaWYgKGZhY2UgPT0gLTEpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiZ290IGEgcG9pbnQgbm90IG9uIHRyaWFuZ2xlLi4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0cjMgPSB0aGlzLmdldFRyaWFuZ2xlMyhmYWNlKTtcclxuICAgICAgICBsZXQgdHIyID0gdGhpcy5nZXRUcmlhbmdsZTIoZmFjZSk7XHJcbiAgICAgICAgbGV0IGJhcmkgPSB0cjIudG9CYXJ5Y2VudHJpYyhwKTtcclxuICAgICAgICByZXR1cm4gdHIzLmZyb21CYXJ5Y2VudHJpYyhiYXJpKTtcclxuICAgIH1cclxuICAgIGNsb3Nlc3RGYWNlKHApIHtcclxuICAgICAgICAvLyBOT1RFIHRoaXMgZG9lc250IHJlYWxseSB3b3JrIGFsbCB0aGF0IHdlbGwuLi5cclxuICAgICAgICBsZXQgZmFjZUlkcyA9IHRoaXMuY2xvc2VzdEZhY2VzKHApO1xyXG4gICAgICAgIGxldCBjbG9zZXN0UG9pbnRzID0gbmV3IFZlY3RvcjNBcnJheShmYWNlSWRzLmxlbmd0aCk7XHJcbiAgICAgICAgZmFjZUlkcy5mb3JFYWNoKChpZCwgaSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHIgPSB0aGlzLmdldFRyaWFuZ2xlMyhpZCk7XHJcbiAgICAgICAgICAgIGxldCBjcCA9IHRyLmNsb3Nlc3RQb2ludChwKTtcclxuICAgICAgICAgICAgY2xvc2VzdFBvaW50cy5zZXRWZWN0b3IoaSwgY3ApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIGNsb3Nlc3QgY2xvc2VzdCBwb2ludFxyXG4gICAgICAgIGxldCBpZCA9IGNsb3Nlc3RQb2ludHMuY2xvc2VzdElkKHApO1xyXG4gICAgICAgIHJldHVybiBmYWNlSWRzW2lkXTtcclxuICAgIH1cclxuICAgIC8vICdmbGF0dGVuJyBhIHBvaW50IGluIHZlcnRleCBzcGFjZSB0byB1diBzcGFjZSB1c2luZyBhIGJhcnljZW50cmljIHJlbWFwXHJcbiAgICAvLyBOT1RFIDogdGhpcyBpcyBub3QgZXhhY3RseSBhICdwcm9qZWN0IHRvIGNsb3Nlc3QgdHJpYW5nbGUnLCBzb21ldGhpbmcgbGlrZSB0aGF0IHdvdWxkbnQgYWx3YXlzIHdvcmtcclxuICAgIGZsYXR0ZW4ocCwgZmFjZSkge1xyXG4gICAgICAgIGxldCB0cjMgPSB0aGlzLmdldFRyaWFuZ2xlMyhmYWNlKTtcclxuICAgICAgICBsZXQgdHIyID0gdGhpcy5nZXRUcmlhbmdsZTIoZmFjZSk7XHJcbiAgICAgICAgbGV0IGJhcmkgPSB0cjMudG9CYXJ5Y2VudHJpYyhwKTtcclxuICAgICAgICByZXR1cm4gdHIyLmZyb21CYXJ5Y2VudHJpYyhiYXJpKTtcclxuICAgIH1cclxuICAgIC8vIGNvbWJvXHJcbiAgICBmbGF0dGVuQ2xvc2VzdFBvaW50KHApIHtcclxuICAgICAgICBsZXQgZmFjZSA9IHRoaXMuY2xvc2VzdEZhY2UocCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbihwLCBmYWNlKTtcclxuICAgIH1cclxuICAgIGNsb3Nlc3RQb2ludChwKSB7XHJcbiAgICAgICAgbGV0IGZhY2UgPSB0aGlzLmNsb3Nlc3RGYWNlKHApO1xyXG4gICAgICAgIGxldCB0cmlhbmdsZSA9IHRoaXMuZ2V0VHJpYW5nbGUzKGZhY2UpO1xyXG4gICAgICAgIGxldCBiYXJpID0gdHJpYW5nbGUudG9CYXJ5Y2VudHJpYyhwKTtcclxuICAgICAgICByZXR1cm4gdHJpYW5nbGUuZnJvbUJhcnljZW50cmljKGJhcmkpO1xyXG4gICAgfVxyXG4gICAgZ2V0VHJpYW5nbGUyKGlkKSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmdldEZhY2VQb2ludHMoaWQsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJpYW5nbGUyKHBbMF0sIHBbMV0sIHBbMl0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VHJpYW5nbGUzKGlkKSB7XHJcbiAgICAgICAgbGV0IHAgPSB0aGlzLmdldEZhY2VQb2ludHMoaWQsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRyaWFuZ2xlMyhwWzBdLCBwWzFdLCBwWzJdKTtcclxuICAgIH1cclxuICAgIHNldE5iKGZhY2VJbmRleCwgY29tbW9uRWRnZSwgbmJJbmRleCkge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tbW9uRWRnZS5pbmNsdWRlcyh0aGlzLm1lc2gubGlua3MuZ2V0KGZhY2VJbmRleCwgaikpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5laWdoYm9yTWFwLnNldChmYWNlSW5kZXgsIGosIG5iSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMubWVzaC5saW5rcy5nZXRSb3coZmFjZUluZGV4KSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coY29tbW9uRWRnZSk7XHJcbiAgICAgICAgdGhyb3cgXCJ0aGVzZSBhcmUgbm90IGFjdHVhbGx5IG5laWdoYm9ycyFcIjtcclxuICAgIH1cclxuICAgIGdldE5iKGZhY2VJbmRleCwgY29tbW9uRWRnZSkge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmICghY29tbW9uRWRnZS5pbmNsdWRlcyh0aGlzLm1lc2gubGlua3MuZ2V0KGZhY2VJbmRleCwgaikpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWlnaGJvck1hcC5nZXQoZmFjZUluZGV4LCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1lc2gubGlua3MuZ2V0Um93KGZhY2VJbmRleCkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGNvbW1vbkVkZ2UpO1xyXG4gICAgICAgIHRocm93IFwiY29tbW9uIGVkZ2UgZG9lcyBub3QgbWF0Y2ggdHJpYW5nbGUgaW5kZXghXCI7XHJcbiAgICB9XHJcbiAgICBnZXRGYWNlUG9pbnRzKHRyLCB1dikge1xyXG4gICAgICAgIGxldCBwb2ludElkcyA9IHRoaXMubWVzaC5saW5rcy5nZXRSb3codHIpO1xyXG4gICAgICAgIGlmICh1dikge1xyXG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudXZzLmdldFZlY3Rvcihwb2ludElkc1swXSksIHRoaXMudXZzLmdldFZlY3Rvcihwb2ludElkc1sxXSksIHRoaXMudXZzLmdldFZlY3Rvcihwb2ludElkc1syXSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzaC52ZXJ0cy5nZXRWZWN0b3IocG9pbnRJZHNbMF0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoLnZlcnRzLmdldFZlY3Rvcihwb2ludElkc1sxXSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2gudmVydHMuZ2V0VmVjdG9yKHBvaW50SWRzWzJdKSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gYXV0aG9yIDogSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2UgOiBjb250YWluIGFsbCBsb2dpYyByZWdhcmRpbmdcclxuaW1wb3J0IHsgUGxhbmUgfSBmcm9tIFwiLi4vZ2VvL3BsYW5lXCI7XHJcbmltcG9ydCB7IEdlb25NYXRoIH0gZnJvbSBcIi4uL21hdGgvbWF0aFwiO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IFJheSB9IGZyb20gXCIuLi9tYXRoL3JheVwiO1xyXG5pbXBvcnQgeyBWZWN0b3IyLCBWZWN0b3IzIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmV4cG9ydCBjbGFzcyBDYW1lcmEge1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCB6X29mZnNldCA9IDEsIGNhbk1vdmUgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuYW5nbGVBbHBoYSA9IDA7IC8vIHJvdGF0aW9uIHhcclxuICAgICAgICB0aGlzLmFuZ2xlQmV0YSA9IDA7IC8vIHJvdGF0aW9uIHlcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0gVmVjdG9yMi56ZXJvKCk7XHJcbiAgICAgICAgLy8gY2FtZXJhIG1hdHJpeCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5mb3YgPSAoMjAgKiBNYXRoLlBJKSAvIDEwMDtcclxuICAgICAgICB0aGlzLnpGYXIgPSAxMDAwMDtcclxuICAgICAgICB0aGlzLnpOZWFyID0gMC4xO1xyXG4gICAgICAgIC8vIG90aGVyIGNvbnN0c1xyXG4gICAgICAgIHRoaXMuc3BlZWQgPSAxO1xyXG4gICAgICAgIHRoaXMud29ybGRQbGFuZSA9IFBsYW5lLldvcmxkWFkoKTtcclxuICAgICAgICB0aGlzLmNhbk1vdmUgPSBjYW5Nb3ZlO1xyXG4gICAgICAgIHRoaXMucG9zID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy56X29mZnNldCA9IC16X29mZnNldDtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IzKDAsIDAsIC16X29mZnNldCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaWNlcyhjYW52YXMpO1xyXG4gICAgfVxyXG4gICAgbmV3KGNhbnZhcywgek9mZnNldCA9IDEsIGNhbk1vdmUgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FtZXJhKGNhbnZhcywgek9mZnNldCwgY2FuTW92ZSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRyb2xzKHN0YXRlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpY2VzKHN0YXRlLmNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVDbGljayhzdGF0ZSk7XHJcbiAgICAgICAgaWYgKHN0YXRlLklzS2V5UHJlc3NlZChcInBcIikpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYHByaW50aW5nIGNhbWVyYSBzdGF0dXMuIFxuICAgICAgICAgICAgICAgIHBvczogJHt0aGlzLnBvc30sIFxuICAgICAgICAgICAgICAgIG9mZnNldDogJHt0aGlzLm9mZnNldH0sIFxuICAgICAgICAgICAgICAgIHNwZWVkOiAke3RoaXMuc3BlZWR9LCBcbiAgICAgICAgICAgICAgICBhbHBoYSAke3RoaXMuYW5nbGVBbHBoYX0sXG4gICAgICAgICAgICAgICAgYmV0YTogJHt0aGlzLmFuZ2xlQmV0YX1gKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzcGVlZCBpcyBub3c6IFwiICsgdGhpcy5zcGVlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0KG9mZnNldCwgYWxwaGEsIGJldGEpIHtcclxuICAgICAgICB0aGlzLnpfb2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIHRoaXMuYW5nbGVBbHBoYSA9IGFscGhhO1xyXG4gICAgICAgIHRoaXMuYW5nbGVCZXRhID0gYmV0YTtcclxuICAgIH1cclxuICAgIHVwZGF0ZU1hdHJpY2VzKGNhbnZhcykge1xyXG4gICAgICAgIHRoaXMud29ybGRNYXRyaXggPSB0aGlzLmdldFdvcmxkTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0TWF0cml4ID0gdGhpcy5nZXRQcm9qZWN0aW9uTWF0cml4KGNhbnZhcyk7XHJcbiAgICAgICAgdGhpcy50b3RhbE1hdHJpeCA9IHRoaXMud29ybGRNYXRyaXgubXVsdGlwbGllZCh0aGlzLnByb2plY3RNYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgbG9va2F0KHBvc2l0aW9uLCB0YXJnZXQpIHtcclxuICAgICAgICAvLyBzZXQgbWF0cmljZXMgdG8gdGhlIHRoaW5nXHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IE1hdHJpeDQubmV3TG9va0F0KHBvc2l0aW9uLCB0YXJnZXQsIHRoaXMud29ybGRQbGFuZS5raGF0KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNsaWNrKHN0YXRlKSB7XHJcbiAgICAgICAgLy8gdG9kb1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ29udHJvbHMoc3RhdGUpIHtcclxuICAgICAgICBsZXQgZGVsdGFTY3JvbGwgPSBzdGF0ZS5zY3JvbGxWYWx1ZSAqIDEuMjtcclxuICAgICAgICB0aGlzLm9mZnNldC56ID0gTWF0aC5taW4oLTAuMDAxLCB0aGlzLnpfb2Zmc2V0IC0gZGVsdGFTY3JvbGwpO1xyXG4gICAgICAgIGlmIChzdGF0ZS5Jc0tleVByZXNzZWQoXCJTaGlmdFwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNwZWVkICo9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5Jc0tleVByZXNzZWQoXCJDb250cm9sXCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSBNYXRoLm1heCh0aGlzLnNwZWVkICogMC41LCAwLjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWFsIHdpdGggbW91c2VcclxuICAgICAgICBsZXQgcHJldlBvcyA9IHRoaXMubW91c2VQb3MuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0gc3RhdGUubW91c2VQb3MuY2xvbmUoKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSBwcmV2UG9zLmNsb25lKCkuc3ViKHRoaXMubW91c2VQb3MpO1xyXG4gICAgICAgIHRoaXMuZ2V0TW91c2VXb3JsZFJheShzdGF0ZS5jYW52YXMud2lkdGgsIHN0YXRlLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIGlmIChzdGF0ZS5tb3VzZVJpZ2h0RG93bikge1xyXG4gICAgICAgICAgICB0aGlzLmFuZ2xlQWxwaGEgPSBHZW9uTWF0aC5jbGFtcCh0aGlzLmFuZ2xlQWxwaGEgKyBkZWx0YS55ICogMC4wMSwgMCwgTWF0aC5QSSk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5nbGVCZXRhICs9IGRlbHRhLnggKiAtMC4wMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVsYXRpdmVVbml0WShhbmdsZSkge1xyXG4gICAgICAgICAgICBsZXQgbSA9IE1hdHJpeDQubmV3WlJvdGF0aW9uKGFuZ2xlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHlWZWN0b3IoVmVjdG9yMy51bml0WSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVsYXRpdmVVbml0WChhbmdsZSkge1xyXG4gICAgICAgICAgICBsZXQgbSA9IE1hdHJpeDQubmV3WlJvdGF0aW9uKGFuZ2xlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHlWZWN0b3IoVmVjdG9yMy51bml0WCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhbk1vdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuSXNLZXlEb3duKFwic1wiKSlcclxuICAgICAgICAgICAgdGhpcy5wb3MuYWRkKHJlbGF0aXZlVW5pdFkoLXRoaXMuYW5nbGVCZXRhKS5zY2FsZSgwLjAxICogdGhpcy5zcGVlZCkpO1xyXG4gICAgICAgIGlmIChzdGF0ZS5Jc0tleURvd24oXCJ3XCIpKVxyXG4gICAgICAgICAgICB0aGlzLnBvcy5hZGQocmVsYXRpdmVVbml0WSgtdGhpcy5hbmdsZUJldGEpLnNjYWxlKC0wLjAxICogdGhpcy5zcGVlZCkpO1xyXG4gICAgICAgIGlmIChzdGF0ZS5Jc0tleURvd24oXCJhXCIpKVxyXG4gICAgICAgICAgICB0aGlzLnBvcy5hZGQocmVsYXRpdmVVbml0WCgtdGhpcy5hbmdsZUJldGEpLnNjYWxlKDAuMDEgKiB0aGlzLnNwZWVkKSk7XHJcbiAgICAgICAgaWYgKHN0YXRlLklzS2V5RG93bihcImRcIikpXHJcbiAgICAgICAgICAgIHRoaXMucG9zLmFkZChyZWxhdGl2ZVVuaXRYKC10aGlzLmFuZ2xlQmV0YSkuc2NhbGUoLTAuMDEgKiB0aGlzLnNwZWVkKSk7XHJcbiAgICAgICAgaWYgKHN0YXRlLklzS2V5RG93bihcInFcIikpXHJcbiAgICAgICAgICAgIHRoaXMucG9zLnogKz0gMC4wMSAqIHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgaWYgKHN0YXRlLklzS2V5RG93bihcImVcIikpXHJcbiAgICAgICAgICAgIHRoaXMucG9zLnogLT0gMC4wMSAqIHRoaXMuc3BlZWQ7XHJcbiAgICB9XHJcbiAgICBnZXRDYW1lcmFQb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZE1hdHJpeC5pbnZlcnNlKCkubXVsdGlwbHlWZWN0b3IobmV3IFZlY3RvcjMoMCwgMCwgMCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TW91c2VXb3JsZFJheShjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCB1c2VNb3VzZSA9IHRydWUpIHtcclxuICAgICAgICAvLyBnZXQgYSByYXkgZnJvbSBvcmlnaW4gdGhyb3VnaCBtb3VzZXBvc1xyXG4gICAgICAgIC8vIG1vdXNlIHVuaXQgc2NyZWVuIHBvc2l0aW9uOlxyXG4gICAgICAgIC8vICAgICAgIC0tLS0tLS0tLS0tLS0tIC0wLjVcclxuICAgICAgICAvLyAgICAgICB8ICAgICAgICAgICAgfFxyXG4gICAgICAgIC8vICAgICAgIHwgICAgICAuKDAsMCl8XHJcbiAgICAgICAgLy8gICAgICAgfCAgICAgICAgICAgIHxcclxuICAgICAgICAvLyAgICAgICAtLS0tLS0tLS0tLS0tLSAwLjVcclxuICAgICAgICAvLyAgICAgLTAuNzIgICAgICAgIDAuNzJcclxuICAgICAgICAvLyAgICAoMC43MiA9IDAuNSAqIGFzcGVjdClcclxuICAgICAgICAvL1xyXG4gICAgICAgIGxldCBzaXplID0gMC41OyAvLyBzaXplIGluZGljYXRvciBvZiB0aGUgZnVzdHJ1bVxyXG4gICAgICAgIGxldCBtcCA9IHRoaXMubW91c2VQb3M7XHJcbiAgICAgICAgbGV0IGFzcGVjdCA9IGNhbnZhc1dpZHRoIC8gY2FudmFzSGVpZ2h0O1xyXG4gICAgICAgIGxldCBtb3VzZVVuaXRYID0gKC1zaXplICsgbXAueCAvIGNhbnZhc1dpZHRoKSAqIGFzcGVjdDtcclxuICAgICAgICBsZXQgbW91c2VVbml0WSA9IC1zaXplICsgbXAueSAvIGNhbnZhc0hlaWdodDtcclxuICAgICAgICBsZXQgZiA9IHNpemUgLyBNYXRoLnRhbih0aGlzLmZvdiAvIDIpOyAvLyBmb2NhbCBsZW5ndGhcclxuICAgICAgICBsZXQgaW52V29ybGQgPSB0aGlzLndvcmxkTWF0cml4LmludmVyc2UoKTtcclxuICAgICAgICBsZXQgb3JpZ2luID0gaW52V29ybGQubXVsdGlwbHlWZWN0b3IobmV3IFZlY3RvcjMoMCwgMCwgMCkpO1xyXG4gICAgICAgIC8vIFRPRE8gaW5zdGVhZCBvZiBkb2luZyB0aGlzLCBqdXN0IGV4dHJhY3QgdGhlIHgsIHksIGFuZCB6IGNvbHVtbnMgb2YgaW52V29ybGRcclxuICAgICAgICBsZXQgaURlc3RpbnkgPSBpbnZXb3JsZC5tdWx0aXBseVZlY3RvcihuZXcgVmVjdG9yMygxLCAwLCAwKSk7XHJcbiAgICAgICAgbGV0IGpEZXN0aW55ID0gaW52V29ybGQubXVsdGlwbHlWZWN0b3IobmV3IFZlY3RvcjMoMCwgMSwgMCkpO1xyXG4gICAgICAgIGxldCBrRGVzdGlueSA9IGludldvcmxkLm11bHRpcGx5VmVjdG9yKG5ldyBWZWN0b3IzKDAsIDAsIC0xKSk7XHJcbiAgICAgICAgbGV0IGloYXQgPSBpRGVzdGlueS5zdWIob3JpZ2luKS5ub3JtYWxpemUoKTtcclxuICAgICAgICBsZXQgamhhdCA9IGpEZXN0aW55LnN1YihvcmlnaW4pLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGxldCBraGF0ID0ga0Rlc3Rpbnkuc3ViKG9yaWdpbikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgLy8gcGFyZG9uIHRoaXMgaW5zYW5lbHkgdWdseSBzdGF0ZW1lbnRcclxuICAgICAgICBsZXQgc2NyZWVuUG9pbnQgPSB1c2VNb3VzZVxyXG4gICAgICAgICAgICA/IG9yaWdpblxyXG4gICAgICAgICAgICAgICAgLmFkZGVkKGtoYXQuc2NhbGVkKGYpKVxyXG4gICAgICAgICAgICAgICAgLmFkZChpaGF0LnNjYWxlZChtb3VzZVVuaXRYKSlcclxuICAgICAgICAgICAgICAgIC5hZGQoamhhdC5zY2FsZWQoLW1vdXNlVW5pdFkpKVxyXG4gICAgICAgICAgICA6IG9yaWdpbi5hZGRlZChraGF0LnNjYWxlZChmKSk7XHJcbiAgICAgICAgcmV0dXJuIFJheS5mcm9tUG9pbnRzKG9yaWdpbiwgc2NyZWVuUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0V29ybGRNYXRyaXgoKSB7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGxldCBhbmdsZUEgPSB0aGlzLmFuZ2xlQWxwaGE7XHJcbiAgICAgICAgbGV0IGFuZ2xlQiA9IHRoaXMuYW5nbGVCZXRhO1xyXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBzbyB6IG1lYW5zICd1cCdcclxuICAgICAgICBsZXQgeXpGbGlwID0gbmV3IE1hdHJpeDQoWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdKTtcclxuICAgICAgICAvLyB0cmFuc2xhdGVkIHRvIGZpdCBzY3JlZW5cclxuICAgICAgICBsZXQgcG9zaXRpb24gPSBNYXRyaXg0Lm5ld1RyYW5zbGF0aW9uKHRoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnopO1xyXG4gICAgICAgIGxldCBtT2Zmc2V0ID0gTWF0cml4NC5uZXdUcmFuc2xhdGlvbihvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56KTtcclxuICAgICAgICAvLyByb3RhdGVkIGJ5IHVzZXJcclxuICAgICAgICBsZXQgeF9yb3RhdGlvbiA9IE1hdHJpeDQubmV3WFJvdGF0aW9uKGFuZ2xlQSk7XHJcbiAgICAgICAgbGV0IHpfcm90YXRpb24gPSBNYXRyaXg0Lm5ld1pSb3RhdGlvbihhbmdsZUIpO1xyXG4gICAgICAgIGxldCByb3RhdGlvbiA9IHpfcm90YXRpb24ubXVsdGlwbHkoeF9yb3RhdGlvbik7XHJcbiAgICAgICAgLy8gbGV0IHRyYW5zZm9ybSA9IG1PZmZzZXQubXVsdGlwbHkocm90YXRpb24pLm11bHRpcGx5KHBvc2l0aW9uKTtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gcG9zaXRpb24ubXVsdGlwbHkocm90YXRpb24pLm11bHRpcGx5KG1PZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICBnZXRQcm9qZWN0aW9uTWF0cml4KGNhbnZhcykge1xyXG4gICAgICAgIC8vIGFzcGVjdHNcclxuICAgICAgICBsZXQgYXNwZWN0ID0gY2FudmFzLndpZHRoIC8gY2FudmFzLmhlaWdodDsgLy8gbm90ZTogdGhpcyBzaG91bGQgYmUgY29uc3RhbnRcclxuICAgICAgICAvLyBsZXQgel9wbGFuZSA9IC0xLiAvIE1hdGgudGFuKHBpIC8gOC4pO1xyXG4gICAgICAgIC8vIHByb2plY3Rpb24gdG8gc2NyZWVuXHJcbiAgICAgICAgLy8gbGV0IHByb2plY3Rpb24gPSBNYXRyaXg0Lm5ld09ydGhvZ3JhcGhpYygtMSwgMSwgLTEsIDEsIDAuMSwgMC4xKTtcclxuICAgICAgICBsZXQgcHJvamVjdGlvbiA9IE1hdHJpeDQubmV3UGVyc3BlY3RpdmUodGhpcy5mb3YsIGFzcGVjdCwgdGhpcy56TmVhciwgdGhpcy56RmFyKTtcclxuICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBjb21iby50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTpcclxuLy8gLSBjb21iaW5hdGlvbiBvZiBzdGF0ZSwgYnVmZmVyZWRTdGF0ZSwgYW5kIHJlbmRlcmVyOlxyXG4vL1xyXG4vLyAxLiAgICAgIHN0YXRlXHJcbi8vICAgICAgICAgICB8fFxyXG4vLyAgICAgICAgKGJ1ZmZlcilcclxuLy8gICAgICAgICAgIFxcL1xyXG4vLyAyLiAgICAgYnVmZmVyZWRcclxuLy8gICAgICAgICAgIHx8XHJcbi8vICAgICAgICAocmVuZGVyKVxyXG4vLyAgICAgICAgICAgXFwvXHJcbi8vIDMuIHJlbmRlcmVkIHRvIHNjcmVlblxyXG4vL1xyXG4vLyBUT0RPOiBtYXliZSBmaW5kIGEgYmV0dGVyIG5hbWUsIGJ1dCAnY29tYm8nIGlzIHF1aXRlIGRpc3RpbmN0IGluIGEgd2F5XHJcbi8vIHRvZG86IGZvcmNlIGJ1ZmZlcmluZyBhIGJpdCBtb3JlLiBtYWtlIGEgd2F5IHRoYXQgcmVxdWllcnMgdGhpcy5idWZmZXJlZCB0byBiZSBmaWxsZWRcclxuLy8gc3RhdGljY29tYm9cclxuLy8gZHluYWNvbWJvXHJcbi8vIG11bHRpc3RhaWMgY29tYm9cclxuLy8gVmVjdG9yMyAmIGRvdHJlbmRlcmVyXHJcbmV4cG9ydCBjbGFzcyBDb21iaSB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgc3RhdGUsIHJlbmRlckNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZCA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBbXTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJDb25zdHJ1Y3RvcihnbCk7XHJcbiAgICB9XHJcbiAgICBidWZmZXIoKSB7IH1cclxuICAgIHJlbmRlcihjb250ZXh0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLmJ1ZmZlcmVkW2ldO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEFuZFJlbmRlcihiLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIENvbWJvIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBzdGF0ZSwgcmVuZGVyQ29uc3RydWN0b3IpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyQ29uc3RydWN0b3IoZ2wpO1xyXG4gICAgfVxyXG4gICAgYnVmZmVyKCkgeyB9XHJcbiAgICByZW5kZXIoY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbi8vIENvbWJpXHJcbi8vIC8vIHNtYWxsIHRpZS10b2dldGhlciBvZiBkYXRhICYgcmVuZGVyZXIuXHJcbi8vIC8vIHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgcmVuZGVyaW5nIGJlaGF2aW91ciBvZiBhIHJlbmRlcmFibGVNZXNoLlxyXG4vLyAvLyBUT0RPOiB0eXBlY2hlY2sgaWYgZGF0YSAmIHJlbmRlcmVyIGFyZSBjb21wYXRpYmxlXHJcbi8vIGltcG9ydCB7IFJlbmRlcmVyLCBEcmF3U3BlZWQgfSBmcm9tIFwiLi9yZW5kZXJlclwiO1xyXG4vLyBpbXBvcnQgeyBTY2VuZSB9IGZyb20gXCIuL3NjZW5lXCI7XHJcbi8vIC8vIFRPRE8gYWRkIHRoaXMgaW5mb3JtYXRpb24gdG8gdGhlIG5ldyBSZW5kZXJhYmxlXHJcbi8vIGV4cG9ydCBjbGFzcyBTdGF0aWNSZW5kZXJVbml0PFIgZXh0ZW5kcyBSZW5kZXJlciwgRD4ge1xyXG4vLyAgICAgcmVuZGVyZXI6IFI7XHJcbi8vICAgICBkYXRhOiBEO1xyXG4vLyAgICAgY29uc3RydWN0b3IocmVuZGVyZXI6IFIsIGRhdGE6IEQpIHtcclxuLy8gICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbi8vICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuLy8gICAgIH1cclxuLy8gICAgIHN0YXRpYyBuZXc8QSBleHRlbmRzIFJlbmRlcmVyLCBCPihyZW5kZXJlcjogQSwgZGF0YTogQik6IFN0YXRpY1JlbmRlclVuaXQ8QSwgQj4ge1xyXG4vLyAgICAgICAgIHJldHVybiBuZXcgU3RhdGljUmVuZGVyVW5pdChyZW5kZXJlciwgZGF0YSk7XHJcbi8vICAgICB9XHJcbi8vICAgICBidWZmZXIoKSB7XHJcbi8vICAgICAgICAgdGhpcy5yZW5kZXJlci5idWZmZXIodGhpcy5kYXRhKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHJlbmRlcihjb250ZXh0OiBTY2VuZSkge1xyXG4vLyAgICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKGNvbnRleHQpO1xyXG4vLyAgICAgfVxyXG4vLyB9XHJcbi8vIGV4cG9ydCBjbGFzcyBEeW5hbWljUmVuZGVyVW5pdDxSIGV4dGVuZHMgUmVuZGVyZXIsIEQ+IHtcclxuLy8gICAgIHJlbmRlcmVyOiBSO1xyXG4vLyAgICAgZGF0YTogRDtcclxuLy8gICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyOiBSLCBkYXRhOiBEKSB7XHJcbi8vICAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4vLyAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbi8vICAgICB9XHJcbi8vICAgICBzdGF0aWMgbmV3PEEgZXh0ZW5kcyBSZW5kZXJlciwgQj4ocmVuZGVyZXI6IEEsIGRhdGE6IEIpOiBEeW5hbWljUmVuZGVyVW5pdDxBLCBCPiB7XHJcbi8vICAgICAgICAgcmV0dXJuIG5ldyBEeW5hbWljUmVuZGVyVW5pdChyZW5kZXJlciwgZGF0YSk7XHJcbi8vICAgICB9XHJcbi8vICAgICByZW5kZXIoY29udGV4dDogU2NlbmUpIHtcclxuLy8gICAgICAgICB0aGlzLnJlbmRlcmVyLmJ1ZmZlcigpO1xyXG4vLyAgICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKGNvbnRleHQpO1xyXG4vLyAgICAgfVxyXG4vLyB9XHJcbiIsIi8vIE5hbWU6ICAgIHNjZW5lLnRzXHJcbi8vIEF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG5pbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSBcIi4uL21hdGgvdmVjdG9yXCI7XHJcbmV4cG9ydCBjbGFzcyBMaWdodCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvbG9yLCBzcG90LCBkaXIpIHtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5zcG90ID0gc3BvdDtcclxuICAgICAgICB0aGlzLmRpciA9IGRpcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBuZXcocG9zLCBjb2xvciA9IFsxLCAxLCAxLCAxXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGlnaHQocG9zLCBjb2xvciwgZmFsc2UsIFZlY3RvcjMuemVybygpKTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgY2xhc3MgQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxufVxyXG4iLCIvLyB3ZWJnbC1oZWxwZXJzLnRzXHJcbi8vXHJcbi8vIGF1dGhvcjogSm9zIEZlZW5zdHJhXHJcbi8vIGNyZWRpdHMgdG8gOiBodHRwczovL3dlYmdsZnVuZGFtZW50YWxzLm9yZy9cclxuLy8gbm90ZTogaW0gc3RpbGwgZmlndXJpbmcgb3V0IGhvdyB0byBvcmdhbml6ZSB0aGlzXHJcbi8vIGltcG9ydCB7IFNjZW5lIH0gZnJvbSBcIi4vc2NlbmVcIjtcclxudmFyIG5leHRUZXh0dXJlSWQgPSAwO1xyXG52YXIgcmVuZGVyY2FsbHNwZXJmcmFtZSA9IDA7XHJcbmV4cG9ydCB2YXIgRHJhd1NwZWVkO1xyXG4oZnVuY3Rpb24gKERyYXdTcGVlZCkge1xyXG4gICAgRHJhd1NwZWVkW0RyYXdTcGVlZFtcIlN0YXRpY0RyYXdcIl0gPSAwXSA9IFwiU3RhdGljRHJhd1wiO1xyXG4gICAgRHJhd1NwZWVkW0RyYXdTcGVlZFtcIkR5bmFtaWNEcmF3XCJdID0gMV0gPSBcIkR5bmFtaWNEcmF3XCI7XHJcbn0pKERyYXdTcGVlZCB8fCAoRHJhd1NwZWVkID0ge30pKTtcclxuLy8gQHBhcmFtIFQgPSBkYXRhIHRvIGZlZWQgdGhlIHJlbmRlcmVyIGF0ICdzZXQnXHJcbmV4cG9ydCBjbGFzcyBSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U2NyaXB0LCBmcmFnbWVudFNjcmlwdCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBSZW5kZXJlci5jcmVhdGVQcm9ncmFtRnJvbVNjcmlwdHMoZ2wsIHZlcnRleFNjcmlwdCwgZnJhZ21lbnRTY3JpcHQpO1xyXG4gICAgfVxyXG4gICAgc2V0QW5kUmVuZGVyKHIsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNldChyLCBEcmF3U3BlZWQuRHluYW1pY0RyYXcpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgLy8gaGVscGVycy4gdGhlc2UgY291bGQgbGl2ZSBzb21ld2hlcmUgZWxzZS4uLiBtYXliZSBpbiBDb250ZXh0P1xyXG4gICAgLy8jcmVnaW9uXHJcbiAgICBzdGF0aWMgZ2V0TmV4dFRleHR1cmVJRCgpIHtcclxuICAgICAgICBsZXQgaWQgPSBuZXh0VGV4dHVyZUlkO1xyXG4gICAgICAgIG5leHRUZXh0dXJlSWQgKz0gMTtcclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVzaXplQ2FudmFzKGdsKSB7XHJcbiAgICAgICAgLy8gTG9va3VwIHRoZSBzaXplIHRoZSBicm93c2VyIGlzIGRpc3BsYXlpbmcgdGhlIGNhbnZhcyBpbiBDU1MgcGl4ZWxzLlxyXG4gICAgICAgIGxldCBjYW52YXMgPSBnbC5jYW52YXM7XHJcbiAgICAgICAgY29uc3QgZGlzcGxheVdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjYW52YXMgaXMgbm90IHRoZSBzYW1lIHNpemUuXHJcbiAgICAgICAgY29uc3QgbmVlZFJlc2l6ZSA9IGdsLmNhbnZhcy53aWR0aCAhPT0gZGlzcGxheVdpZHRoIHx8IGdsLmNhbnZhcy5oZWlnaHQgIT09IGRpc3BsYXlIZWlnaHQ7XHJcbiAgICAgICAgaWYgKG5lZWRSZXNpemUpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgY2FudmFzIHRoZSBzYW1lIHNpemVcclxuICAgICAgICAgICAgZ2wuY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xyXG4gICAgICAgICAgICBnbC5jYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGVsbCBXZWJHTCBob3cgdG8gY29udmVydCBmcm9tIGNsaXAgc3BhY2UgdG8gcGl4ZWxzXHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gbmVlZFJlc2l6ZTtcclxuICAgIH1cclxuICAgIGNvbnZlcnREcmF3U3BlZWQoc3BlZWQpIHtcclxuICAgICAgICBpZiAoc3BlZWQgPT0gRHJhd1NwZWVkLkR5bmFtaWNEcmF3KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsLkRZTkFNSUNfRFJBVztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsLlNUQVRJQ19EUkFXO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBpbml0V2ViZ2xDb250ZXh0KGNhbnZhcykge1xyXG4gICAgICAgIGxldCBwb3NzaWJseUdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiKTtcclxuICAgICAgICBpZiAocG9zc2libHlHbCA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ3ZWJnbCB1bmF2YWlsYWJsZS4uLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGdsID0gcG9zc2libHlHbDtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xyXG4gICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgICAgICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgZ2wuY2xlYXJEZXB0aCgxKTtcclxuICAgICAgICByZXR1cm4gZ2w7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tcGlsZVNoYWRlcihnbCwgc2hhZGVyU291cmNlLCBzaGFkZXJUeXBlKSB7XHJcbiAgICAgICAgbGV0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihzaGFkZXJUeXBlKTtcclxuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xyXG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgICBsZXQgc3VjY2VzcyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJjb3VsZCBub3QgY29tcGlsZSBzaGFkZXI6XCIgKyBzaGFkZXJTb3VyY2UgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xyXG4gICAgICAgIGxldCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgXCJwcm9ncmFtIGZhaWxlZCB0byBsaW5rOlwiICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZVByb2dyYW1Gcm9tU2NyaXB0cyhnbCwgdmVydGV4U2NyaXB0LCBmcmFnbWVudFNjcmlwdCkge1xyXG4gICAgICAgIGxldCB2ZXJ0ZXhTaGFkZXIgPSBSZW5kZXJlci5jb21waWxlU2hhZGVyKGdsLCB2ZXJ0ZXhTY3JpcHQsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGxldCBmcmFnbWVudFNoYWRlciA9IFJlbmRlcmVyLmNvbXBpbGVTaGFkZXIoZ2wsIGZyYWdtZW50U2NyaXB0LCBnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHJldHVybiBSZW5kZXJlci5jcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBiaWxsYm9hcmQtcmVuZGVyZXIudHNcclxuLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IFJlbmRlcmVyIGltYWdlcyBhcyBiaWxsYm9hcmRzLlxyXG5pbXBvcnQgeyBEcmF3U3BlZWQsIFJlbmRlcmVyIH0gZnJvbSBcIi4uL3JlbmRlci9yZW5kZXJlclwiO1xyXG4vLyB0aGlzIGlzIGp1c3QgYSB0ZW1wbGF0ZSBmb3IgY29weS1wYXN0aW5nXHJcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICBsZXQgdnMgPSBcIlwiO1xyXG4gICAgICAgIGxldCBmcyA9IFwiXCI7XHJcbiAgICAgICAgc3VwZXIoZ2wsIHZzLCBmcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KGdsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVJlbmRlcmVyKGdsKTtcclxuICAgIH1cclxuICAgIHNldChwLCBzcGVlZCkge1xyXG4gICAgICAgIC8vIFRPRE9cclxuICAgIH1cclxuICAgIHJlbmRlcihjb250ZXh0KSB7XHJcbiAgICAgICAgLy8gVE9ET1xyXG4gICAgfVxyXG4gICAgc2V0QW5kUmVuZGVyKHBhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNldChwYWNrLCBEcmF3U3BlZWQuU3RhdGljRHJhdyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuLy8gZXhwb3J0IGNsYXNzIFRleHRSZW5kZXJlciB7XHJcbi8vICAgICAvLyBUT0RPXHJcbi8vICAgICAvLyB1c2UgdGhlIGJpbGxib2FyZCByZW5kZXJlciB0byByZW5kZXIgc2VyaWVzIG9mIGFzY2lpIGNoYXJhY3RlcnMsXHJcbi8vICAgICAvLyBieSB1c2luZyBzdGFuZGFyZCBwb3NpdGlvbnMgb2YgY2VydGFpbiBmb250IGltYWdlcy5cclxuLy8gICAgIGJyOiBCaWxsQm9hcmRSZW5kZXJlcjtcclxuLy8gICAgIC8vIHRvZG8gaG9yaXpvbnRhbCBqdXN0aWZpY2F0aW9uXHJcbi8vICAgICAvLyB0b2RvIHZlcnRpY2FsIGp1c3RpZmljYXRpb25cclxuLy8gICAgIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQpIHtcclxuLy8gICAgICAgICB0aGlzLmJyID0gbmV3IEJpbGxCb2FyZFJlbmRlcmVyKGdsKTtcclxuLy8gICAgIH1cclxuLy8gICAgIHNldChzdHJpbmdzOiBzdHJpbmdbXSwgbG9jYXRpb25zOiBWZWN0b3IzQXJyYXkpIHtcclxuLy8gICAgICAgICBpZiAoc3RyaW5ncy5sZW5ndGggIT0gbG9jYXRpb25zLmNvdW50KCkpIHtcclxuLy8gICAgICAgICAgICAgY29uc29sZS53YXJuKFwiY291bGRudCBzZXQgVGV4dFJlbmRlcmVyOiBzdHJpbmdzIG5vdCBlcXVhbCB0byBsb2NhdGlvbnMuLi5cIik7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgICAgIGxldCBsZW5ndGggPSBzdHJpbmdzLmxlbmd0aDtcclxuLy8gICAgICAgICAvLyBUT0RPOiBzZXQgYSB3aG9sZSBidW5jaCBvZiBzdHVmZlxyXG4vLyAgICAgfVxyXG4vLyAgICAgcmVuZGVyKCkge31cclxuLy8gfVxyXG4iLCIvLyBqb3MgZmVlbnN0cmFcclxuaW1wb3J0IHsgUmVuZGVyZXIgfSBmcm9tIFwiLi4vcmVuZGVyL3JlbmRlcmVyXCI7XHJcbmV4cG9ydCBjbGFzcyBEb3RSZW5kZXJlcjIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgc2l6ZSA9IDUsIGNvbG9yID0gWzEsIDEsIDEsIDFdLCBzcXVhcmUgPSB0cnVlKSB7XHJcbiAgICAgICAgLy8gbm90ZTogSSBsaWtlIHZlcnRleCAmIGZyYWdtZW50cyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgc2NyaXB0IGl0c2VsZi5cclxuICAgICAgICAvLyB3aGVuIHlvdSBjaGFuZ2UgdmVydGV4IG9yIGZyYWdtZW50LCB0aGlzIGNsYXNzIGhhcyB0byBkZWFsIHdpdGggaXQuXHJcbiAgICAgICAgLy8gcHV0dGluZyB0aGVtIHNvbWV3aGVyZSBlbHNlIGRvZXNudCBtYWtlIHNlbnNlIHRvIG1lLFxyXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvdXBsZWQgMSB0byAxLlxyXG4gICAgICAgIGxldCB2ZXJ0ZXhTb3VyY2UgPSBgXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG4gICAgICAgIFxuICAgICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfc2l6ZTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMyIGNsaXBwZWQgPSAoKGFfcG9zaXRpb24gLyB1X3Jlc29sdXRpb24pICogMi4wKSAtIDEuMDtcbiAgICAgIFxuICAgICAgICAgICAgZ2xfUG9pbnRTaXplID0gdV9zaXplO1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBwZWQsIDAsIDEpO1xuICAgICAgICAgICAgLy8gZ2xfUG9zaXRpb24gPSB2ZWM0KDAsMCwwLDEpO1xuICAgICAgICB9XG4gICAgICAgIGA7XHJcbiAgICAgICAgbGV0IGZyYWdtZW50U291cmNlU3F1YXJlID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X0NvbG9yO1xuICAgICAgICB2ZWMyIGNlbnRlciA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMSwxLDEsMSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICBsZXQgZnJhZ21lbnRTb3VyY2VSb3VuZCA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHZlYzQgdV9Db2xvcjtcbiAgICAgICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UoY2VudGVyLCBnbF9Qb2ludENvb3JkKSA+IDAuNSkge1xuICAgICAgICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMSwxLDEsMSk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgaWYgKHNxdWFyZSkge1xyXG4gICAgICAgICAgICBzdXBlcihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZVNxdWFyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXBlcihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZVJvdW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51X3Jlc29sdXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcmVzb2x1dGlvblwiKTtcclxuICAgICAgICB0aGlzLnVfc2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9zaXplXCIpO1xyXG4gICAgICAgIHRoaXMudV9jb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICAvLyBCaW5kIGl0IHRvIEFSUkFZX0JVRkZFUiAodGhpbmsgb2YgaXQgYXMgQVJSQVlfQlVGRkVSID0gcG9zaXRpb25CdWZmZXIpXHJcbiAgICAgICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgIH1cclxuICAgIHNldCgpIHsgfVxyXG4gICAgcmVuZGVyKGNvbnRleHQpIHsgfVxyXG4gICAgLy8gcmVuZGVyIDEgaW1hZ2UgdG8gdGhlIHNjcmVlblxyXG4gICAgc2V0QW5kUmVuZGVyKGRvdHMsIGNvbnRleHQpIHtcclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIC8vIFRlbGwgaXQgdG8gdXNlIG91ciBwcm9ncmFtIChwYWlyIG9mIHNoYWRlcnMpXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIC8vIHNldCB1bmlmb3Jtc1xyXG4gICAgICAgIGdsLnVuaWZvcm0yZih0aGlzLnVfcmVzb2x1dGlvbiwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy51X3NpemUsIHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHRoaXMudV9jb2xvciwgdGhpcy5jb2xvclswXSwgdGhpcy5jb2xvclsxXSwgdGhpcy5jb2xvclsyXSwgdGhpcy5jb2xvclszXSk7XHJcbiAgICAgICAgLy8gLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyLlxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV9wb3NpdGlvbik7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIpO1xyXG4gICAgICAgIC8vIC8vIFRlbGwgdGhlIGF0dHJpYnV0ZSBob3cgdG8gZ2V0IGRhdGEgb3V0IG9mIHBvc2l0aW9uQnVmZmVyIChBUlJBWV9CVUZGRVIpXHJcbiAgICAgICAgdmFyIHNpemUgPSAyOyAvLyAyIGNvbXBvbmVudHMgcGVyIGl0ZXJhdGlvblxyXG4gICAgICAgIHZhciB0eXBlID0gZ2wuRkxPQVQ7IC8vIHRoZSBkYXRhIGlzIDMyYml0IGZsb2F0c1xyXG4gICAgICAgIHZhciBub3JtYWxpemUgPSBmYWxzZTsgLy8gZG9uJ3Qgbm9ybWFsaXplIHRoZSBkYXRhXHJcbiAgICAgICAgdmFyIHN0cmlkZSA9IDA7IC8vIDAgPSBtb3ZlIGZvcndhcmQgc2l6ZSAqIHNpemVvZih0eXBlKSBlYWNoIGl0ZXJhdGlvbiB0byBnZXQgdGhlIG5leHQgcG9zaXRpb25cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDsgLy8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYnVmZmVyXHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfcG9zaXRpb24sIHNpemUsIHR5cGUsIG5vcm1hbGl6ZSwgc3RyaWRlLCBvZmZzZXQpO1xyXG4gICAgICAgIC8vIGZpbGwgd2l0aCBkYXRhO1xyXG4gICAgICAgIGxldCBkYXRhID0gdGhpcy50b0Zsb2F0MzJBcnJheShkb3RzKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2wuRFlOQU1JQ19EUkFXKTtcclxuICAgICAgICAvLyBEcmF3IHRoZSBwb2ludC5cclxuICAgICAgICB2YXIgcHJpbWl0aXZlVHlwZSA9IGdsLlBPSU5UUztcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgY291bnQgPSBkb3RzLmxlbmd0aDtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKHByaW1pdGl2ZVR5cGUsIG9mZnNldCwgY291bnQpO1xyXG4gICAgfVxyXG4gICAgLy8gRmlsbCB0aGUgYnVmZmVyIHdpdGggdGhlIHZhbHVlcyB0aGF0IGRlZmluZSBhIHJlY3RhbmdsZS5cclxuICAgIHRvRmxvYXQzMkFycmF5KGRvdHMpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZG90cy5sZW5ndGggKiAyKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YVtpICogMl0gPSBkb3RzW2ldLng7XHJcbiAgICAgICAgICAgIGRhdGFbaSAqIDIgKyAxXSA9IGRvdHNbaV0ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICByYW5kb21JbnQocmFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZ2UpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIGpvcyBmZWVuc3RyYVxyXG5pbXBvcnQgeyBnZXRHZW5lcmFsRmxvYXRNYXRyaXggfSBmcm9tIFwiLi4vZGF0YS92ZWN0b3ItYXJyYXlcIjtcclxuaW1wb3J0IHsgRHJhd1NwZWVkLCBSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXIvcmVuZGVyZXJcIjtcclxuZXhwb3J0IGNsYXNzIERvdFJlbmRlcmVyMyBleHRlbmRzIFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCByYWRpdXMgPSA1LCBjb2xvciA9IFsxLCAxLCAxLCAxXSwgc3F1YXJlID0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIG5vdGU6IEkgbGlrZSB2ZXJ0ZXggJiBmcmFnbWVudHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHNjcmlwdCBpdHNlbGYuXHJcbiAgICAgICAgLy8gd2hlbiB5b3UgY2hhbmdlIHZlcnRleCBvciBmcmFnbWVudCwgdGhpcyBjbGFzcyBoYXMgdG8gZGVhbCB3aXRoIGl0LlxyXG4gICAgICAgIC8vIHB1dHRpbmcgdGhlbSBzb21ld2hlcmUgZWxzZSBkb2VzbnQgbWFrZSBzZW5zZSB0byBtZSxcclxuICAgICAgICAvLyB0aGV5IGFyZSBjb3VwbGVkIDEgdG8gMS5cclxuICAgICAgICBsZXQgdmVydGV4U291cmNlID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gbWF0NCB1X3RyYW5zZm9ybTtcbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zaXplO1xuXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFfdmVydGV4O1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgc2l6ZSBvZiBhIHJlbmRlcmVkIHBvaW50LlxuICAgICAgICAgICAgZ2xfUG9pbnRTaXplID0gdV9zaXplO1xuXG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIGxvY2F0aW9uIG9mIHRoZSB2ZXJ0ZXguXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfdHJhbnNmb3JtICogdmVjNChhX3ZlcnRleCwgMS4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGA7XHJcbiAgICAgICAgbGV0IGZyYWdtZW50U291cmNlU3F1YXJlID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xuICAgICAgICAvLyB2ZWMyIGNlbnRlciA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICBsZXQgZnJhZ21lbnRTb3VyY2VSb3VuZCA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcbiAgICAgICAgdmVjMiBjZW50ZXIgPSB2ZWMyKDAuNSwgMC41KTtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UoY2VudGVyLCBnbF9Qb2ludENvb3JkKSA+IDAuNSkge1xuICAgICAgICAgICAgICAgZGlzY2FyZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgaWYgKHNxdWFyZSkge1xyXG4gICAgICAgICAgICBzdXBlcihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZVNxdWFyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdXBlcihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZVJvdW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51X3RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90cmFuc2Zvcm1cIik7XHJcbiAgICAgICAgdGhpcy51X3NpemUgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfc2l6ZVwiKTtcclxuICAgICAgICB0aGlzLnVfY29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAvLyBCaW5kIGl0IHRvIEFSUkFZX0JVRkZFUiAodGhpbmsgb2YgaXQgYXMgQVJSQVlfQlVGRkVSID0gcG9zaXRpb25CdWZmZXIpXHJcbiAgICAgICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfdmVydGV4XCIpO1xyXG4gICAgICAgIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICB9XHJcbiAgICBzZXQocG9pbnRzLCBzcGVlZCkge1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIHBvc3NpYmxlIGVudHJpZXMgdG8gYSBnZW5lcmFsIGVudHJ5XHJcbiAgICAgICAgbGV0IGFycmF5ID0gZ2V0R2VuZXJhbEZsb2F0TWF0cml4KHBvaW50cyk7XHJcbiAgICAgICAgLy8gZnJvbSBzb21lIG90aGVyIHRoaW5nXHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGFycmF5LmNvdW50KCk7XHJcbiAgICAgICAgLy8gLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyLlxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV9wb3NpdGlvbik7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3Bvc2l0aW9uLCBhcnJheS5fd2lkdGgsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFycmF5LmRhdGEsIHN1cGVyLmNvbnZlcnREcmF3U3BlZWQoc3BlZWQpKTtcclxuICAgIH1cclxuICAgIHJlbmRlcihjKSB7XHJcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICBsZXQgbWF0cml4ID0gYy5jYW1lcmEudG90YWxNYXRyaXg7XHJcbiAgICAgICAgLy8gVGVsbCBpdCB0byB1c2Ugb3VyIHByb2dyYW0gKHBhaXIgb2Ygc2hhZGVycylcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2cobWF0cml4LmRhdGEpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy51X3RyYW5zZm9ybSwgZmFsc2UsIG1hdHJpeC5kYXRhKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYodGhpcy51X3NpemUsIHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHRoaXMudV9jb2xvciwgdGhpcy5jb2xvclswXSwgdGhpcy5jb2xvclsxXSwgdGhpcy5jb2xvclsyXSwgdGhpcy5jb2xvclszXSk7XHJcbiAgICAgICAgLy8gLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyLlxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfcG9zaXRpb24pO1xyXG4gICAgICAgIC8vIERyYXcgdGhlIHBvaW50LlxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB0aGlzLmNvdW50KTtcclxuICAgIH1cclxuICAgIHNldEFuZFJlbmRlcihkYXRhLCBjKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoZGF0YSwgRHJhd1NwZWVkLkR5bmFtaWNEcmF3KTtcclxuICAgICAgICB0aGlzLnJlbmRlcihjKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBzaW1wbGUtbGluZS1yZW5kZXJlci50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogV2ViR0wgYmFzZWQgcmVuZGVyaW5nIG9mIGxpbmVzLlxyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IERyYXdTcGVlZCwgUmVuZGVyZXIgfSBmcm9tIFwiLi4vcmVuZGVyL3JlbmRlcmVyXCI7XHJcbmltcG9ydCB7IE1lc2ggfSBmcm9tIFwiLi4vbWVzaC9tZXNoXCI7XHJcbmV4cG9ydCBjbGFzcyBMaW5lUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgY29sb3IgPSBbMSwgMCwgMCwgMC41XSkge1xyXG4gICAgICAgIC8vIG5vdGU6IEkgbGlrZSB2ZXJ0ZXggJiBmcmFnbWVudHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHNjcmlwdCBpdHNlbGYuXHJcbiAgICAgICAgLy8gd2hlbiB5b3UgY2hhbmdlIHZlcnRleCBvciBmcmFnbWVudCwgdGhpcyBjbGFzcyBoYXMgdG8gZGVhbCB3aXRoIGl0LlxyXG4gICAgICAgIC8vIHB1dHRpbmcgdGhlbSBzb21ld2hlcmUgZWxzZSBkb2VzbnQgbWFrZSBzZW5zZSB0byBtZSxcclxuICAgICAgICAvLyB0aGV5IGFyZSBjb3VwbGVkIDEgdG8gMS5cclxuICAgICAgICBjb25zdCB2cyA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIG1hdDQgdV90cmFuc2Zvcm07XG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV90cmFuc2Zvcm0gKiBhX3Bvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGA7XHJcbiAgICAgICAgY29uc3QgZnMgPSBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGludDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgc3VwZXIoZ2wsIHZzLCBmcyk7XHJcbiAgICAgICAgdGhpcy51X3RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90cmFuc2Zvcm1cIik7XHJcbiAgICAgICAgdGhpcy51X2NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG4gICAgICAgIC8vIHdlIG5lZWQgMiBidWZmZXJzXHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zIHdoaWNoIHdvbnQgY2hhbmdlXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLnVfY29sb3IsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIGNvbG9yWzNdKTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnZlcnRDb3VudCA9IDA7XHJcbiAgICB9XHJcbiAgICBzZXQoZGF0YSwgc3BlZWQgPSBEcmF3U3BlZWQuU3RhdGljRHJhdywgcGVyc29uYWwgPSBNYXRyaXg0Lm5ld0lkZW50aXR5KCkpIHtcclxuICAgICAgICAvLyBzYXZlIGhvdyBtYW55IGZhY2VzIG5lZWQgdG8gYmUgZHJhd25cclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGxldCBsaW5rcztcclxuICAgICAgICBsZXQgdmVydHM7XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBNZXNoKSB7XHJcbiAgICAgICAgICAgIHZlcnRzID0gZGF0YS52ZXJ0cztcclxuICAgICAgICAgICAgbGlua3MgPSBkYXRhLmxpbmtzLmdldERhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZlcnRzID0gZGF0YS52ZXJ0cztcclxuICAgICAgICAgICAgbGlua3MgPSBkYXRhLmxpbmtzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhsaW5rcyk7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsaW5rcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy52ZXJ0Q291bnQgPSB2ZXJ0cy5fd2lkdGg7XHJcbiAgICAgICAgbGV0IGRyYXdzcGVlZCA9IHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCk7XHJcbiAgICAgICAgLy8gdmVydGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgdGhpcy52ZXJ0Q291bnQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRzLmRhdGEsIGRyYXdzcGVlZCk7XHJcbiAgICAgICAgLy8gaW5kaWNlc1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBsaW5rcy5idWZmZXIsIGRyYXdzcGVlZCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoYykge1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IGMuY2FtZXJhLnRvdGFsTWF0cml4O1xyXG4gICAgICAgIC8vIFRlbGwgaXQgdG8gdXNlIG91ciBwcm9ncmFtIChwYWlyIG9mIHNoYWRlcnMpXHJcbiAgICAgICAgLy8gUE9JTlRFUlMgTVVTVCBBTFNPIEJFIFNFVCwgRE8gRVZFUllUSElORyBFWENFUFQgR0wuQlVGRkVSREFUQVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfcG9zaXRpb24pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3Bvc2l0aW9uLCB0aGlzLnZlcnRDb3VudCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICAvLyBzZXQgdW5pZm9ybXNcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudV90cmFuc2Zvcm0sIGZhbHNlLCBtYXRyaXguZGF0YSk7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgcG9pbnQuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCB0aGlzLmNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbiAgICBzZXRBbmRSZW5kZXIoZGF0YSwgYykge1xyXG4gICAgICAgIHRoaXMuc2V0KGRhdGEsIERyYXdTcGVlZC5EeW5hbWljRHJhdyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoYyk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gbmFtZTogICAgbWVzaC1yZW5kZXJlci50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogV2ViR0wgYmFzZWQgcmVuZGVyaW5nIG9mIGEgbWVzaC5cclxuaW1wb3J0IHsgRHJhd1NwZWVkLCBSZW5kZXJlciB9IGZyb20gXCIuLi9saWJcIjtcclxuZXhwb3J0IGNsYXNzIFNpbXBsZU1lc2hSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBjb2xvciA9IFsxLCAwLCAwLCAwLjI1XSkge1xyXG4gICAgICAgIGNvbnN0IHZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XG4gICAgICAgIHVuaWZvcm0gbWF0NCB1X3RyYW5zZm9ybTtcbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3RyYW5zZm9ybSAqIGFfcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICBjb25zdCBmcyA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIC8vIHNldHVwIHByb2dyYW1cclxuICAgICAgICBzdXBlcihnbCwgdnMsIGZzKTtcclxuICAgICAgICB0aGlzLnVfdHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3RyYW5zZm9ybVwiKTtcclxuICAgICAgICB0aGlzLnVfY29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGdsLnVuaWZvcm00Zih0aGlzLnVfY29sb3IsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIGNvbG9yWzNdKTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIC8vIHdlIG5lZWQgMiBidWZmZXJzXHJcbiAgICAgICAgLy8gLT4gMSBmbG9hdCBidWZmZXIgZm9yIHRoZSBwb3NpdGlvbnMgb2YgYWxsIHZlcnRpY2VzLlxyXG4gICAgICAgIC8vIC0+IDEgaW50IGJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGFsbCB0cmlhbmdsZXNcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb25fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIH1cclxuICAgIHNldChtZXNoLCBzcGVlZCA9IERyYXdTcGVlZC5TdGF0aWNEcmF3KSB7XHJcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICAvLyBzYXZlIGhvdyBtYW55IGZhY2VzIG5lZWQgdG8gYmUgZHJhd25cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IG1lc2gubGlua3MuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgLy8gdmVydGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMztcclxuICAgICAgICB2YXIgdHlwZSA9IGdsLkZMT0FUO1xyXG4gICAgICAgIHZhciBub3JtYWxpemUgPSBmYWxzZTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgdGhpcy5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnZlcnRzLmRhdGEsIHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCkpO1xyXG4gICAgICAgIC8vIGluZGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4X2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5saW5rcy5kYXRhLCB0aGlzLmNvbnZlcnREcmF3U3BlZWQoc3BlZWQpKTtcclxuICAgIH1cclxuICAgIC8vIHJlbmRlciAxIGltYWdlIHRvIHRoZSBzY3JlZW5cclxuICAgIHJlbmRlcihjKSB7XHJcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICBsZXQgbWF0cml4ID0gYy5jYW1lcmEudG90YWxNYXRyaXg7XHJcbiAgICAgICAgLy8gVGVsbCBpdCB0byB1c2Ugb3VyIHByb2dyYW0gKHBhaXIgb2Ygc2hhZGVycylcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfcG9zaXRpb24sIHRoaXMuc2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4X2J1ZmZlcik7XHJcbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVfdHJhbnNmb3JtLCBmYWxzZSwgbWF0cml4LmRhdGEpO1xyXG4gICAgICAgIC8vIERyYXcgdGhlIHBvaW50LlxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxuICAgIHNldEFuZFJlbmRlcihyLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5zZXQociwgRHJhd1NwZWVkLkR5bmFtaWNEcmF3KTtcclxuICAgICAgICB0aGlzLnJlbmRlcihjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBzaW1wbGUtbGluZS1yZW5kZXJlci50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogV2ViR0wgYmFzZWQgcmVuZGVyaW5nIG9mIGxpbmVzLlxyXG5pbXBvcnQgeyBWZWN0b3IzQXJyYXkgfSBmcm9tIFwiLi4vZGF0YS92ZWN0b3ItYXJyYXlcIjtcclxuaW1wb3J0IHsgTm9ybWFsS2luZCB9IGZyb20gXCIuLi9tZXNoL3JlbmRlci1tZXNoXCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgZ2V0RGVmYXVsdEluZGljZXMgfSBmcm9tIFwiLi4vbWVzaC9saW5lLWFycmF5XCI7XHJcbmltcG9ydCB7IERyYXdTcGVlZCwgUmVuZGVyZXIgfSBmcm9tIFwiLi4vcmVuZGVyL3JlbmRlcmVyXCI7XHJcbmV4cG9ydCBjbGFzcyBOb3JtYWxSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgLy8gbm90ZTogSSBsaWtlIHZlcnRleCAmIGZyYWdtZW50cyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgc2NyaXB0IGl0c2VsZi5cclxuICAgICAgICAvLyB3aGVuIHlvdSBjaGFuZ2UgdmVydGV4IG9yIGZyYWdtZW50LCB0aGlzIGNsYXNzIGhhcyB0byBkZWFsIHdpdGggaXQuXHJcbiAgICAgICAgLy8gcHV0dGluZyB0aGVtIHNvbWV3aGVyZSBlbHNlIGRvZXNudCBtYWtlIHNlbnNlIHRvIG1lLFxyXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvdXBsZWQgMSB0byAxLlxyXG4gICAgICAgIGNvbnN0IHZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4O1xuICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX3ZlcnRleF9jb2xvcjtcblxuICAgICAgICB1bmlmb3JtIG1hdDQgdV90cmFuc2Zvcm07XG5cbiAgICAgICAgdmFyeWluZyB2ZWM0IHZfY29sb3I7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3RyYW5zZm9ybSAqIGFfdmVydGV4O1xuICAgICAgICAgICAgdl9jb2xvciA9IGFfdmVydGV4X2NvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGA7XHJcbiAgICAgICAgY29uc3QgZnMgPSBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGludDtcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgdmFyeWluZyB2ZWM0IHZfY29sb3I7XG5cbiAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgc3VwZXIoZ2wsIHZzLCBmcyk7XHJcbiAgICAgICAgdGhpcy51X3RyYW5zZm9ybSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90cmFuc2Zvcm1cIik7XHJcbiAgICAgICAgLy8gd2UgbmVlZCAyIGJ1ZmZlcnNcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV92ZXJ0ZXhcIik7XHJcbiAgICAgICAgdGhpcy5hX2NvbG9yID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfdmVydGV4X2NvbG9yXCIpO1xyXG4gICAgICAgIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmFfY29sb3JfYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZXJ0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSAwLjQ7XHJcbiAgICB9XHJcbiAgICAvLyB0YWtlIGEgZ2VuZXJhbCByZW5kZXIgbWVzaCwgYW5kIGV4dHJhY3Qgbm9ybWFsc1xyXG4gICAgc2V0KHJlbmQsIHNwZWVkID0gRHJhd1NwZWVkLlN0YXRpY0RyYXcpIHtcclxuICAgICAgICAvLyBzYXZlIGhvdyBtYW55IHZlcnRzIG5lZWQgdG8gYmUgZHJhd25cclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICBsZXQgZHJhd3NwZWVkID0gdGhpcy5jb252ZXJ0RHJhd1NwZWVkKHNwZWVkKTtcclxuICAgICAgICB0aGlzLnZlcnRDb3VudCA9IDM7XHJcbiAgICAgICAgbGV0IGxpbmV2ZXJ0cztcclxuICAgICAgICBsZXQgbm9ybWFscztcclxuICAgICAgICAvLyBkaWZmZXJlbnQgYnVmZmVyIGZpbGxzIGJhc2VkIHVwb24gbm9ybWFsIGtpbmRcclxuICAgICAgICBsZXQgbm9ybWFsS2luZCA9IHJlbmQuZ2V0Tm9ybWFsVHlwZSgpO1xyXG4gICAgICAgIGlmIChub3JtYWxLaW5kID09IE5vcm1hbEtpbmQuRmFjZSkge1xyXG4gICAgICAgICAgICBsZXQgZmFjZUNvdW50ID0gcmVuZC5tZXNoLmxpbmtzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSBmYWNlQ291bnQgKiAyO1xyXG4gICAgICAgICAgICBsaW5ldmVydHMgPSBuZXcgVmVjdG9yM0FycmF5KHRoaXMuY291bnQpO1xyXG4gICAgICAgICAgICBub3JtYWxzID0gbmV3IFZlY3RvcjNBcnJheSh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBmYWNlQ291bnQ7IGYrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IHJlbmQuZ2V0RmFjZVZlcnRpY2VzKGYpLmF2ZXJhZ2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBub3JtYWwgPSByZW5kLm5vcm1zLmdldFZlY3RvcihmKTtcclxuICAgICAgICAgICAgICAgIGxldCBpMSA9IGYgKiAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkyID0gZiAqIDIgKyAxO1xyXG4gICAgICAgICAgICAgICAgbGluZXZlcnRzLnNldFZlY3RvcihpMSwgY2VudGVyKTtcclxuICAgICAgICAgICAgICAgIGxpbmV2ZXJ0cy5zZXRWZWN0b3IoaTIsIGNlbnRlci5hZGQobm9ybWFsLnNjYWxlZCh0aGlzLnNjYWxlKSkpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gbm9ybWFsLmFkZChuZXcgVmVjdG9yMygxLCAxLCAxKS5kaXYoMikpO1xyXG4gICAgICAgICAgICAgICAgbm9ybWFscy5zZXRWZWN0b3IoaTEsIGNvbG9yKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHMuc2V0VmVjdG9yKGkyLCBjb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9ybWFsS2luZCA9PSBOb3JtYWxLaW5kLlZlcnRleCkge1xyXG4gICAgICAgICAgICBsZXQgdmVydENvdW50ID0gcmVuZC5tZXNoLnZlcnRzLmNvdW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSB2ZXJ0Q291bnQgKiAyO1xyXG4gICAgICAgICAgICBsaW5ldmVydHMgPSBuZXcgVmVjdG9yM0FycmF5KHRoaXMuY291bnQpO1xyXG4gICAgICAgICAgICBub3JtYWxzID0gbmV3IFZlY3RvcjNBcnJheSh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbnRlciA9IHJlbmQubWVzaC52ZXJ0cy5nZXRWZWN0b3IoaSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsID0gcmVuZC5ub3Jtcy5nZXRWZWN0b3IoaSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaTEgPSBpICogMjtcclxuICAgICAgICAgICAgICAgIGxldCBpMiA9IGkgKiAyICsgMTtcclxuICAgICAgICAgICAgICAgIGxpbmV2ZXJ0cy5zZXRWZWN0b3IoaTEsIGNlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBsaW5ldmVydHMuc2V0VmVjdG9yKGkyLCBjZW50ZXIuYWRkKG5vcm1hbC5zY2FsZWQodGhpcy5zY2FsZSkpKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IG5vcm1hbC5hZGQobmV3IFZlY3RvcjMoMSwgMSwgMSkpLmRpdigyKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHMuc2V0VmVjdG9yKGkxLCBjb2xvcik7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxzLnNldFZlY3RvcihpMiwgY29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5vcm1hbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibm8gbm9ybWFscyBmb3IgdHlwZVwiLCBub3JtYWxLaW5kKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdmVydGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgdGhpcy52ZXJ0Q291bnQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGxpbmV2ZXJ0cy5kYXRhLCBkcmF3c3BlZWQpO1xyXG4gICAgICAgIC8vIG5vcm1hbHNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX2NvbG9yX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX2NvbG9yKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9jb2xvciwgdGhpcy52ZXJ0Q291bnQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vcm1hbHMuZGF0YSwgZHJhd3NwZWVkKTtcclxuICAgICAgICAvLyBpbmRpY2VzXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleF9idWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdldERlZmF1bHRJbmRpY2VzKHRoaXMuY291bnQpLCBkcmF3c3BlZWQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKGMpIHtcclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBjLmNhbWVyYS50b3RhbE1hdHJpeDtcclxuICAgICAgICBsZXQgY2FtZXJhID0gYy5jYW1lcmE7XHJcbiAgICAgICAgLy8gVGVsbCBpdCB0byB1c2Ugb3VyIHByb2dyYW0gKHBhaXIgb2Ygc2hhZGVycylcclxuICAgICAgICAvLyBQT0lOVEVSUyBNVVNUIEFMU08gQkUgU0VULCBETyBFVkVSWVRISU5HIEVYQ0VQVCBHTC5CVUZGRVJEQVRBXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIC8vIGJ1ZmZlciAxXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV9wb3NpdGlvbik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfcG9zaXRpb24sIHRoaXMudmVydENvdW50LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIC8vIGJ1ZmZlciAyXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV9jb2xvcl9idWZmZXIpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV9jb2xvcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfY29sb3IsIHRoaXMudmVydENvdW50LCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIC8vIGluZGV4IGJ1ZmZlclxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICAvLyBzZXQgdW5pZm9ybXNcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudV90cmFuc2Zvcm0sIGZhbHNlLCBtYXRyaXguZGF0YSk7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgcG9pbnQuXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLkxJTkVTLCB0aGlzLmNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRHJhd1NwZWVkIH0gZnJvbSBcIi4uL2xpYlwiO1xyXG5leHBvcnQgY2xhc3MgTWV0YVJlbmRlcmVyIHtcclxuICAgIHNldEFuZFJlbmRlcihyLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5zZXQociwgRHJhd1NwZWVkLkR5bmFtaWNEcmF3KTtcclxuICAgICAgICB0aGlzLnJlbmRlcihjb250ZXh0KTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBtZXNoLXJlbmRlcmVyLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBXZWJHTCBiYXNlZCByZW5kZXJpbmcgb2YgYSBtZXNoLlxyXG5pbXBvcnQgeyBMaW5lQXJyYXkgfSBmcm9tIFwiLi4vbWVzaC9saW5lLWFycmF5XCI7XHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgRHJhd1NwZWVkIH0gZnJvbSBcIi4uL3JlbmRlci9yZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBMaW5lUmVuZGVyZXIgfSBmcm9tIFwiLi9saW5lLXJlbmRlcmVyXCI7XHJcbmltcG9ydCB7IFNpbXBsZU1lc2hSZW5kZXJlciB9IGZyb20gXCIuL3NpbXBsZS1tZXNoLXJlbmRlcmVyXCI7XHJcbmltcG9ydCB7IE5vcm1hbFJlbmRlcmVyIH0gZnJvbSBcIi4vbWVzaC1ub3JtYWxzLXJlbmRlcmVyXCI7XHJcbmltcG9ydCB7IE1ldGFSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXIvbWV0YS1yZW5kZXJlclwiO1xyXG5leHBvcnQgY2xhc3MgTWVzaERlYnVnUmVuZGVyZXIgZXh0ZW5kcyBNZXRhUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIGZhY2VDb2xvciA9IFsxLCAwLCAwLCAwLjI1XSwgZWRnZUNvbG9yID0gWzEsIDAsIDAsIDFdLCByZW5kZXJOb3JtYWwgPSB0cnVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmZhY2VSZW5kID0gbmV3IFNpbXBsZU1lc2hSZW5kZXJlcihnbCwgZmFjZUNvbG9yKTtcclxuICAgICAgICB0aGlzLmxpbmVSZW5kID0gbmV3IExpbmVSZW5kZXJlcihnbCwgZWRnZUNvbG9yKTtcclxuICAgICAgICB0aGlzLnBlcnNvbmFsID0gTWF0cml4NC5uZXdJZGVudGl0eSgpO1xyXG4gICAgICAgIGlmIChyZW5kZXJOb3JtYWwpXHJcbiAgICAgICAgICAgIHRoaXMubm9ybVJlbmQgPSBuZXcgTm9ybWFsUmVuZGVyZXIoZ2wpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhnbCwgZmFjZUNvbG9yID0gWzEsIDAsIDAsIDAuMjVdLCBlZGdlQ29sb3IgPSBbMSwgMCwgMCwgMV0sIHJlbmRlck5vcm1hbCA9IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1lc2hEZWJ1Z1JlbmRlcmVyKGdsLCBmYWNlQ29sb3IsIGVkZ2VDb2xvciwgcmVuZGVyTm9ybWFsKTtcclxuICAgIH1cclxuICAgIHNldChkYXRhLCBzcGVlZCA9IERyYXdTcGVlZC5TdGF0aWNEcmF3KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMucGVyc29uYWwgPSBkYXRhLnBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMuZmFjZVJlbmQuc2V0KGRhdGEubWVzaCk7XHJcbiAgICAgICAgdGhpcy5saW5lUmVuZC5zZXQoTGluZUFycmF5LmZyb21NZXNoKGRhdGEpLCBzcGVlZCk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5ub3JtUmVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldChkYXRhLCBzcGVlZCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoYykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB0aGlzLmZhY2VSZW5kLnJlbmRlcihjKTtcclxuICAgICAgICB0aGlzLmxpbmVSZW5kLnJlbmRlcihjKTtcclxuICAgICAgICAoX2EgPSB0aGlzLm5vcm1SZW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVuZGVyKGMpO1xyXG4gICAgfVxyXG4gICAgc2V0QW5kUmVuZGVyKHIsIGMpIHtcclxuICAgICAgICB0aGlzLnNldChyLCBEcmF3U3BlZWQuRHluYW1pY0RyYXcpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKGMpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIGpvcyBmZWVuc3RyYVxyXG5pbXBvcnQgeyBSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXIvcmVuZGVyZXJcIjtcclxuZXhwb3J0IGNsYXNzIFJlY3RhbmdsZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICAvLyBub3RlOiBJIGxpa2UgdmVydGV4ICYgZnJhZ21lbnRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzY3JpcHQgaXRzZWxmLlxyXG4gICAgICAgIC8vIHdoZW4geW91IGNoYW5nZSB2ZXJ0ZXggb3IgZnJhZ21lbnQsIHRoaXMgY2xhc3MgaGFzIHRvIGRlYWwgd2l0aCBpdC5cclxuICAgICAgICAvLyBwdXR0aW5nIHRoZW0gc29tZXdoZXJlIGVsc2UgZG9lc250IG1ha2Ugc2Vuc2UgdG8gbWUsXHJcbiAgICAgICAgLy8gdGhleSBhcmUgY291cGxlZCAxIHRvIDEuXHJcbiAgICAgICAgbGV0IHZlcnRleFNvdXJjZSA9IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcblxuICAgICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHJlY3RhbmdsZSBmcm9tIHBpeGVscyB0byAwLjAgdG8gMS4wXG4gICAgICAgICAgICB2ZWMyIHplcm9Ub09uZSA9ICgoYV9wb3NpdGlvbiAvIHVfcmVzb2x1dGlvbikgKiAyLjApIC0gMS4wO1xuXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXG4gICAgICAgICAgICAvLyB2ZWMyIHplcm9Ub1R3byA9IHplcm9Ub09uZSAqIDIuMDtcblxuICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIDAtPjIgdG8gLTEtPisxIChjbGlwc3BhY2UpXG4gICAgICAgICAgICAvLyB2ZWMyIGNsaXBTcGFjZSA9IHplcm9Ub1R3byAtIDEuMDtcblxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHplcm9Ub09uZSAqIHZlYzIoMSwgLTEpLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIGxldCBmcmFnbWVudFNvdXJjZSA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWM0IHVfY29sb3I7XG4gICAgICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHVfY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgc3VwZXIoZ2wsIHZlcnRleFNvdXJjZSwgZnJhZ21lbnRTb3VyY2UpO1xyXG4gICAgICAgIC8vIGxvb2sgdXAgd2hlcmUgdGhlIHZlcnRleCBkYXRhIG5lZWRzIHRvIGdvLlxyXG4gICAgICAgIHRoaXMuYV9wb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMuYV9wb3NpdGlvbl9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLnVfcmVzb2x1dGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMudV9jb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBidWZmZXIgdG8gcHV0IHRocmVlIDJkIGNsaXAgc3BhY2UgcG9pbnRzIGluXHJcbiAgICAgICAgLy8gQmluZCBpdCB0byBBUlJBWV9CVUZGRVIgKHRoaW5rIG9mIGl0IGFzIEFSUkFZX0JVRkZFUiA9IHBvc2l0aW9uQnVmZmVyKVxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgIH1cclxuICAgIHNldCgpIHtcclxuICAgICAgICB0aHJvdyBcIm5vdCB1c2VkXCI7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdGhyb3cgXCJub3QgdXNlZCFcIjtcclxuICAgIH1cclxuICAgIHNldEFuZFJlbmRlcihycywgYykge1xyXG4gICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNcclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy8gVGVsbCBpdCB0byB1c2Ugb3VyIHByb2dyYW0gKHBhaXIgb2Ygc2hhZGVycylcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgLy8gVHVybiBvbiB0aGUgYXR0cmlidXRlXHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC51bmlmb3JtMmYodGhpcy51X3Jlc29sdXRpb24sIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgLy8gQmluZCB0aGUgcG9zaXRpb24gYnVmZmVyLlxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgICAgICAvLyBUZWxsIHRoZSBhdHRyaWJ1dGUgaG93IHRvIGdldCBkYXRhIG91dCBvZiBwb3NpdGlvbkJ1ZmZlciAoQVJSQVlfQlVGRkVSKVxyXG4gICAgICAgIHZhciBzaXplID0gMjsgLy8gMiBjb21wb25lbnRzIHBlciBpdGVyYXRpb25cclxuICAgICAgICB2YXIgdHlwZSA9IGdsLkZMT0FUOyAvLyB0aGUgZGF0YSBpcyAzMmJpdCBmbG9hdHNcclxuICAgICAgICB2YXIgbm9ybWFsaXplID0gZmFsc2U7IC8vIGRvbid0IG5vcm1hbGl6ZSB0aGUgZGF0YVxyXG4gICAgICAgIHZhciBzdHJpZGUgPSAwOyAvLyAwID0gbW92ZSBmb3J3YXJkIHNpemUgKiBzaXplb2YodHlwZSkgZWFjaCBpdGVyYXRpb24gdG8gZ2V0IHRoZSBuZXh0IHBvc2l0aW9uXHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7IC8vIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGJ1ZmZlclxyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3Bvc2l0aW9uLCBzaXplLCB0eXBlLCBub3JtYWxpemUsIHN0cmlkZSwgb2Zmc2V0KTtcclxuICAgICAgICAvLyBkcmF3IDUwIHJhbmRvbSByZWN0YW5nbGVzIGluIHJhbmRvbSBjb2xvcnNcclxuICAgICAgICBmb3IgKGxldCByIG9mIHJzKSB7XHJcbiAgICAgICAgICAgIC8vIFNldHVwIGEgcmFuZG9tIHJlY3RhbmdsZVxyXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgd3JpdGUgdG8gcG9zaXRpb25CdWZmZXIgYmVjYXVzZVxyXG4gICAgICAgICAgICAvLyBpdHMgdGhlIGxhc3QgdGhpbmcgd2UgYm91bmQgb24gdGhlIEFSUkFZX0JVRkZFUlxyXG4gICAgICAgICAgICAvLyBiaW5kIHBvaW50XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVjdGFuZ2xlKGdsLCByKTtcclxuICAgICAgICAgICAgLy8gU2V0IGEgcmFuZG9tIGNvbG9yLlxyXG4gICAgICAgICAgICBnbC51bmlmb3JtNGYodGhpcy51X2NvbG9yLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCAxKTtcclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlVHlwZSA9IGdsLlRSSUFOR0xFUztcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IDY7XHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMocHJpbWl0aXZlVHlwZSwgb2Zmc2V0LCBjb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRmlsbCB0aGUgYnVmZmVyIHdpdGggdGhlIHZhbHVlcyB0aGF0IGRlZmluZSBhIHJlY3RhbmdsZS5cclxuICAgIHNldFJlY3RhbmdsZShnbCwgcikge1xyXG4gICAgICAgIGxldCB2ZXJ0cyA9IHIuZ2V0VmVydGljZXMoKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAgICAgICAgIHZlcnRzWzBdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzBdLnksXHJcbiAgICAgICAgICAgIHZlcnRzWzFdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzFdLnksXHJcbiAgICAgICAgICAgIHZlcnRzWzJdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzJdLnksXHJcbiAgICAgICAgICAgIHZlcnRzWzJdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzJdLnksXHJcbiAgICAgICAgICAgIHZlcnRzWzFdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzFdLnksXHJcbiAgICAgICAgICAgIHZlcnRzWzNdLngsXHJcbiAgICAgICAgICAgIHZlcnRzWzNdLnksXHJcbiAgICAgICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuICAgIHJhbmRvbUludChyYW5nZSkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gbmFtZTogICAgbWVzaC1yZW5kZXJlci50c1xyXG4vLyBhdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gcHVycG9zZTogQSBzaGFkZXIgd3JhcHBlciBmb3IgcmVuZGVyaW5nIHNoYWRlZCwgdGV4dHVyZWQsIG1lc2hlc1xyXG5pbXBvcnQgeyBnZXREZWZhdWx0SW5kaWNlcyB9IGZyb20gXCIuLi9tZXNoL2xpbmUtYXJyYXlcIjtcclxuaW1wb3J0IHsgVmVjdG9yM0FycmF5IH0gZnJvbSBcIi4uL2RhdGEvdmVjdG9yLWFycmF5XCI7XHJcbmltcG9ydCB7IE5vcm1hbEtpbmQgfSBmcm9tIFwiLi4vbWVzaC9yZW5kZXItbWVzaFwiO1xyXG5pbXBvcnQgeyBNYXRyaXg0IH0gZnJvbSBcIi4uL21hdGgvbWF0cml4XCI7XHJcbmltcG9ydCB7IERyYXdTcGVlZCwgUmVuZGVyZXIgfSBmcm9tIFwiLi4vcmVuZGVyL3JlbmRlcmVyXCI7XHJcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tIFwiLi4vbWF0aC92ZWN0b3JcIjtcclxuaW1wb3J0IHsgQ29uc3QgfSBmcm9tIFwiLi4vbGliXCI7XHJcbmV4cG9ydCBjbGFzcyBTaGFkZWRNZXNoUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIGNvbnN0IHZzID0gYFxuXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfdmVydGV4X3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3ZlcnRleF9ub3JtYWw7XG4gICAgICAgIGF0dHJpYnV0ZSBmbG9hdCBhX3ZlcnRleF9hbWJpO1xuICAgIFxuICAgICAgICB1bmlmb3JtIG1hdDQgdV9ub3JtYWxfbWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdV9wZXJzb25hbF9tYXRyaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0NCB1X21vZGVsX3ZpZXdfbWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdV9wcm9qZWN0aW9uX21hdHJpeDtcblxuICAgICAgICAvLyBzaG91bGQgYmUgdW5pZm9ybXMgY29uc3RhbmNlc1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV9hbWJpZW50X2xpZ2h0O1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV9kaXJfbGlnaHRfY29sb3I7XG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X2Rpcl9saWdodF92ZWN0b3I7ICBcblxuICAgICAgICAvLyB2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlX2Nvb3JkO1xuICAgICAgICB2YXJ5aW5nIHZlYzMgdl9saWdodGluZztcbiAgICBcbiAgICAgICAgdm9pZCBtYWluKHZvaWQpIHtcblxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3Byb2plY3Rpb25fbWF0cml4ICogdV9tb2RlbF92aWV3X21hdHJpeCAqIHVfcGVyc29uYWxfbWF0cml4ICogYV92ZXJ0ZXhfcG9zaXRpb247XG4gICAgICAgICAgICAvLyB2X3RleHR1cmVfY29vcmQgPSBhX3RleHR1cmVfY29vcmQ7XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gQXBwbHkgbGlnaHRpbmcgZWZmZWN0XG4gICAgICAgICAgICAvLyBoaWdocHIgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgdmVjNCB0cmFuc2Zvcm1lZE5vcm1hbCA9IHVfbm9ybWFsX21hdHJpeCAqIHZlYzQoYV92ZXJ0ZXhfbm9ybWFsLCAxLjApO1xuICAgICAgICAgICAgZmxvYXQgZGlyZWN0aW9uYWwgPSBtYXgoZG90KHRyYW5zZm9ybWVkTm9ybWFsLnh5eiwgdV9kaXJfbGlnaHRfdmVjdG9yKSwgMC4wKTtcbiAgICAgICAgICAgIHZfbGlnaHRpbmcgPSAodV9hbWJpZW50X2xpZ2h0ICsgKHVfZGlyX2xpZ2h0X2NvbG9yICogZGlyZWN0aW9uYWwpKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIGNvbnN0IGZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBkaWZmdXNlIGZhY3RvciBwcm9kdWNlZCBieSB0aGUgbGlnaHQgaWxsdW1pbmF0aW9uICBcbiAgICAgICAgLy8gaWYgZG9uZSBsaWtlIHRoaXMsIGNvbG9yIGNvdWxkIGxvb2sgbmljZXJcbiAgICAgICAgLy8gZmxvYXQgZGlmZnVzZUZhY3Rvcih2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodF9kaXJlY3Rpb24pIHtcbiAgICAgICAgLy8gICAgIGZsb2F0IGRmID0gZG90KG5vcm1hbGl6ZShub3JtYWwpLCBub3JtYWxpemUobGlnaHRfZGlyZWN0aW9uKSk7XG4gICAgICAgIC8vICAgICBpZiAoZ2xfRnJvbnRGYWNpbmcpIHtcbiAgICAgICAgLy8gICAgICAgICBkZiA9IC1kZjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybiBtYXgoMC4wLCBkZik7XG4gICAgICAgIC8vIH1cblxuICAgICAgICB2YXJ5aW5nIHZlYzMgdl9saWdodGluZztcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG5cbiAgICAgICAgICAgIC8vIEZyYWdtZW50IHNoYWRlciBvdXRwdXRcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodl9saWdodGluZywgMS4wKTtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIC8vIHNldHVwIHByb2dyYW1cclxuICAgICAgICBzdXBlcihnbCwgdnMsIGZzKTtcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICAvLyBpbml0IHVuaWZvcm1zXHJcbiAgICAgICAgdGhpcy51X25vcm1hbF9tYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfbm9ybWFsX21hdHJpeFwiKTtcclxuICAgICAgICB0aGlzLnVfbW9kZWxfdmlld19tYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfbW9kZWxfdmlld19tYXRyaXhcIik7XHJcbiAgICAgICAgdGhpcy51X3Byb2plY3Rpb25fbWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3Byb2plY3Rpb25fbWF0cml4XCIpO1xyXG4gICAgICAgIHRoaXMudV9wZXJzb25hbF9tYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcGVyc29uYWxfbWF0cml4XCIpO1xyXG4gICAgICAgIC8vIGxpZ2h0IHVuaWZvcm1zXHJcbiAgICAgICAgdGhpcy51X2FtYmllbnRfbGlnaHQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfYW1iaWVudF9saWdodFwiKTtcclxuICAgICAgICB0aGlzLnVfZGlyX2xpZ2h0X2NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X2Rpcl9saWdodF9jb2xvclwiKTtcclxuICAgICAgICB0aGlzLnVfZGlyX2xpZ2h0X3ZlY3RvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9kaXJfbGlnaHRfdmVjdG9yXCIpO1xyXG4gICAgICAgIC8vIGluaXQgYXR0cmlidXRlczogdmVydHMgfCBub3JtYWxzIHwgYW1iaVxyXG4gICAgICAgIHRoaXMuYV92ZXJ0ZXhfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV92ZXJ0ZXhfcG9zaXRpb25cIik7XHJcbiAgICAgICAgdGhpcy5hX3ZlcnRleF9wb3N0aXRpb25fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5hX3ZlcnRleF9ub3JtYWwgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV92ZXJ0ZXhfbm9ybWFsXCIpO1xyXG4gICAgICAgIHRoaXMuYV92ZXJ0ZXhfbm9ybWFsX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuYV92ZXJ0ZXhfYW1iaSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3ZlcnRleF9hbWJpXCIpO1xyXG4gICAgICAgIHRoaXMuYV92ZXJ0ZXhfYW1iaV9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4X2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgfVxyXG4gICAgc2V0KHJlbmQsIHNwZWVkID0gRHJhd1NwZWVkLlN0YXRpY0RyYXcpIHtcclxuICAgICAgICAvLyBOT1RFOiBwcm9jZXNzaW5nIHRpbWUgaXMgbG9uZ2VyOiB3ZSB1c2UgRHJhd0FycmF5IGluc3RlYWQgb2YgRHJhd0VsZW1lbnRzLCB0byBkZWFsIHdpdGggbm9ybWFscyAmIHV2IGRhdGFcclxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHRoaXMuc2V0U2hhbGxvdyhnbCwgcmVuZCk7XHJcbiAgICAgICAgbGV0IG5vcm1hbFR5cGUgPSByZW5kLmdldE5vcm1hbFR5cGUoKTtcclxuICAgICAgICBpZiAobm9ybWFsVHlwZSA9PSBOb3JtYWxLaW5kLkZhY2UpIHtcclxuICAgICAgICAgICAgLy8gc2F2ZSBob3cgbWFueSB2ZXJ0cyBuZWVkIHRvIGJlIGRyYXduXHJcbiAgICAgICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IHJlbmQubWVzaC5saW5rcy5kYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGRzID0gdGhpcy5jb252ZXJ0RHJhd1NwZWVkKHNwZWVkKTtcclxuICAgICAgICAgICAgLy8gY29udmVydCB0byBub24taW5kZXhlZCB2ZXJ0cyAmIG5vcm1zXHJcbiAgICAgICAgICAgIGxldCB2ZXJ0cyA9IG5ldyBWZWN0b3IzQXJyYXkodGhpcy5jb3VudCk7XHJcbiAgICAgICAgICAgIGxldCBub3JtcyA9IG5ldyBWZWN0b3IzQXJyYXkodGhpcy5jb3VudCk7XHJcbiAgICAgICAgICAgIGxldCBhbWJpID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgbGV0IGZhY2VDb3VudCA9IHJlbmQubWVzaC5saW5rcy5jb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmQubWVzaC5saW5rcy5jb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBub3JtID0gcmVuZC5ub3Jtcy5nZXRWZWN0b3IoaSk7XHJcbiAgICAgICAgICAgICAgICByZW5kLm1lc2gubGlua3MuZ2V0Um93KGkpLmZvckVhY2goKHYsIGopID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaWQgPSBpICogMyArIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydHMuc2V0VmVjdG9yKGlkLCByZW5kLm1lc2gudmVydHMuZ2V0VmVjdG9yKHYpKTtcclxuICAgICAgICAgICAgICAgICAgICBub3Jtcy5zZXRWZWN0b3IoaWQsIG5vcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFtYmlbaWRdID0gMTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlciAxXHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfdmVydGV4X3Bvc3RpdGlvbl9idWZmZXIpO1xyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV92ZXJ0ZXhfcG9zaXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0cy5kYXRhLmJ1ZmZlciwgZHMpO1xyXG4gICAgICAgICAgICAvLyBidWZmZXIgMlxyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3ZlcnRleF9ub3JtYWxfYnVmZmVyKTtcclxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfdmVydGV4X25vcm1hbCwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5vcm1zLmRhdGEuYnVmZmVyLCBkcyk7XHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlciAzXHJcbiAgICAgICAgICAgIC8vIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfdmVydGV4X2FtYmlfYnVmZmVyKTtcclxuICAgICAgICAgICAgLy8gZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfdmVydGV4X2FtYmksIDEsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIC8vIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBhbWJpLCBkcyk7XHJcbiAgICAgICAgICAgIC8vIGluZGV4XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2V0RGVmYXVsdEluZGljZXModGhpcy5jb3VudCksIHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub3JtYWxUeXBlID09IE5vcm1hbEtpbmQuVmVydGV4KSB7XHJcbiAgICAgICAgICAgIC8vIHNhdmUgaG93IG1hbnkgdmVydHMgbmVlZCB0byBiZSBkcmF3blxyXG4gICAgICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIGxldCBkcyA9IHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdG8gbm9uLWluZGV4ZWQgdmVydHMgJiBub3Jtc1xyXG4gICAgICAgICAgICBsZXQgYW1iaSA9IHJlbmQuYW1iaTtcclxuICAgICAgICAgICAgbGV0IGZhY2VDb3VudCA9IHJlbmQubWVzaC5saW5rcy5jb3VudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gcmVuZC5tZXNoLmxpbmtzLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZW5kLm1lc2gubGlua3MpO1xyXG4gICAgICAgICAgICAvLyBidWZmZXIgMVxyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3ZlcnRleF9wb3N0aXRpb25fYnVmZmVyKTtcclxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfdmVydGV4X3Bvc2l0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgcmVuZC5tZXNoLnZlcnRzLmRhdGEsIGRzKTtcclxuICAgICAgICAgICAgLy8gYnVmZmVyIDJcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV92ZXJ0ZXhfbm9ybWFsX2J1ZmZlcik7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3ZlcnRleF9ub3JtYWwsIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCByZW5kLm5vcm1zLmRhdGEsIGRzKTtcclxuICAgICAgICAgICAgLy8gYnVmZmVyIDNcclxuICAgICAgICAgICAgLy8gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV92ZXJ0ZXhfYW1iaV9idWZmZXIpO1xyXG4gICAgICAgICAgICAvLyBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV92ZXJ0ZXhfYW1iaSwgMSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAgICAgLy8gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGFtYmksIGRzKTtcclxuICAgICAgICAgICAgLy8gaW5kZXhcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleF9idWZmZXIpO1xyXG4gICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCByZW5kLm1lc2gubGlua3MuZGF0YSwgZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYW5ub3QgcmVuZGVyIHdpdGggdGhpcyBub3JtYWwgZGF0YVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbmV2ZXIgcmVuZGVyIG1vcmUgdGhhbiBwb3NzaWJsZVxyXG4gICAgICAgIGlmICh0aGlzLmNvdW50ID4gQ29uc3QuTUFYX1UxNikge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gQ29uc3QuTUFYX1UxNjtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwibWVzaCBtYXggcmVhY2hlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc2V0IG9ubHkgdGhlIGJhc2ljIGVsZW1lbnRzLlxyXG4gICAgLy8gdXNlIHRoaXMgdG8gZHluYW1pY2x5IGFsdGVyIHRoaW5ncyBsaWtlIHBvc2l0aW9uIGFuZCBjb2xvcixcclxuICAgIC8vIHdpdGhvdXQgcmVmaWxsaW5nIGFsbCBidWZmZXJzIHdpdGggaXRcclxuICAgIHNldFNoYWxsb3coZ2wsIHJlbmQpIHtcclxuICAgICAgICAvLyB1c2UgdGhlIHByb2dyYW1cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgLy8gcG9zaXRpb25cclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudV9wZXJzb25hbF9tYXRyaXgsIGZhbHNlLCByZW5kLnBvc2l0aW9uLmRhdGEpO1xyXG4gICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgbGV0IGNvbG9yID0gcmVuZC5jb2xvcjtcclxuICAgICAgICAvLyBzaGlmdCBzaGFkb3cgdG8gZGFya2VyLCBzbGlnaHRseSB0byBibHVlXHJcbiAgICAgICAgbGV0IHNoYWRvd0NvbG9yID0gY29sb3IubWFwKCh4KSA9PiB4ICogMC4yNSk7XHJcbiAgICAgICAgc2hhZG93Q29sb3JbMl0gPSBNYXRoLm1pbigxLCBzaGFkb3dDb2xvclsyXSAqIDEuMDUpO1xyXG4gICAgICAgIC8vIHNoaWZ0IGJyaWdodCBjb2xvciBzbGlnaHRseSB0byB5ZWxsb3dcclxuICAgICAgICBsZXQgYnJpZ2h0Q29sb3IgPSBjb2xvci5tYXAoKHgpID0+IHgpO1xyXG4gICAgICAgIGJyaWdodENvbG9yWzBdID0gTWF0aC5taW4oMSwgYnJpZ2h0Q29sb3JbMF0gKiAxLjA1KTtcclxuICAgICAgICBicmlnaHRDb2xvclsxXSA9IE1hdGgubWluKDEsIGJyaWdodENvbG9yWzFdICogMS4wNSk7XHJcbiAgICAgICAgYnJpZ2h0Q29sb3JbMl0gPSBNYXRoLm1pbigxLCBicmlnaHRDb2xvclsyXSAqIDEpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0zZnYodGhpcy51X2FtYmllbnRfbGlnaHQsIHNoYWRvd0NvbG9yLnNsaWNlKDAsIDMpKTtcclxuICAgICAgICBnbC51bmlmb3JtM2Z2KHRoaXMudV9kaXJfbGlnaHRfY29sb3IsIGJyaWdodENvbG9yLnNsaWNlKDAsIDMpKTtcclxuICAgIH1cclxuICAgIC8vIHJlbmRlciB0aGUgcHJldmlvdXMgc2V0IGRhdGEgdG8gdGhlIHNjcmVlblxyXG4gICAgcmVuZGVyKGMpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcInJlbmRlcmluZy4uXCIpO1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgbGV0IGNhbWVyYSA9IGMuY2FtZXJhO1xyXG4gICAgICAgIC8vIHVzZSB0aGUgcHJvZ3JhbVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAvLyBzZXQgdW5pZm9ybXNcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudV9ub3JtYWxfbWF0cml4LCBmYWxzZSwgTWF0cml4NC5uZXdJZGVudGl0eSgpLmRhdGEpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy51X21vZGVsX3ZpZXdfbWF0cml4LCBmYWxzZSwgY2FtZXJhLndvcmxkTWF0cml4LmRhdGEpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy51X3Byb2plY3Rpb25fbWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3RNYXRyaXguZGF0YSk7XHJcbiAgICAgICAgLy8gc2V0IGxpZ2h0IGRpcmVjdGlvblxyXG4gICAgICAgIGxldCB2ZWMgPSBjYW1lcmEuZ2V0TW91c2VXb3JsZFJheShnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQsIGZhbHNlKS5ub3JtYWw7XHJcbiAgICAgICAgZ2wudW5pZm9ybTNmdih0aGlzLnVfZGlyX2xpZ2h0X3ZlY3RvciwgVmVjdG9yMy51bml0WCgpLmFkZChWZWN0b3IzLnVuaXRZKCkpLmFkZChWZWN0b3IzLnVuaXRaKCkpLm5vcm1hbGl6ZSgpLnRvQXJyYXkoKSk7XHJcbiAgICAgICAgLy8gYnVmZmVyIDFcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfdmVydGV4X3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3ZlcnRleF9wb3N0aXRpb25fYnVmZmVyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV92ZXJ0ZXhfcG9zaXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgLy8gYnVmZmVyIDJcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfdmVydGV4X25vcm1hbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV92ZXJ0ZXhfbm9ybWFsX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfdmVydGV4X25vcm1hbCwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAvLyBidWZmZXIgM1xyXG4gICAgICAgIC8vIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV92ZXJ0ZXhfYW1iaSk7XHJcbiAgICAgICAgLy8gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV92ZXJ0ZXhfYW1iaV9idWZmZXIpO1xyXG4gICAgICAgIC8vIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3ZlcnRleF9ub3JtYWwsIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgLy8gaW5kaWNlc1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICAvLyBkcmF3IVxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIHRoaXMuY291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBuYW1lOiAgICBtZXNoLXJlbmRlcmVyLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBXZWJHTCBiYXNlZCByZW5kZXJpbmcgb2YgYSBtZXNoLlxyXG5pbXBvcnQgeyBEcmF3U3BlZWQsIFJlbmRlcmVyIH0gZnJvbSBcIi4uL3JlbmRlci9yZW5kZXJlclwiO1xyXG5leHBvcnQgY2xhc3MgVGV4dHVyZU1lc2hSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgY29uc3QgdnMgPSBgXG4gICAgICAgIC8vIHByZWNpc2lvbiBtZWRpdW1wIGludDtcbiAgICAgICAgLy8gcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYV90ZXhjb29yZDtcblxuICAgICAgICB1bmlmb3JtIG1hdDQgdV90cmFuc2Zvcm07XG5cbiAgICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB1X3RyYW5zZm9ybSAqIGFfcG9zaXRpb247XG4gICAgICAgICAgICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIGNvbnN0IGZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcblxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmU7XG5cbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZSwgdl90ZXhjb29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICAvLyBzZXR1cCBwcm9ncmFtXHJcbiAgICAgICAgc3VwZXIoZ2wsIHZzLCBmcyk7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgLy8gaW5pdCB1bmlmb3Jtc1xyXG4gICAgICAgIHRoaXMudV90cmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfdHJhbnNmb3JtXCIpO1xyXG4gICAgICAgIHRoaXMudV90ZXh0dXJlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3RleHR1cmVcIik7XHJcbiAgICAgICAgLy8gaW5pdCB0aHJlZSBidWZmZXJzOiB2ZXJ0cyB8IHV2cyB8IGxpbmtzXHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XHJcbiAgICAgICAgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuYV90ZXhjb29yZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3RleGNvb3JkXCIpO1xyXG4gICAgICAgIHRoaXMuYV90ZXhjb29yZF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4X2J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIC8vIGluaXQgdGV4dHVyZVxyXG4gICAgICAgIHRoaXMudGV4dHVyZV9pZCA9IFJlbmRlcmVyLmdldE5leHRUZXh0dXJlSUQoKTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KGdsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlTWVzaFJlbmRlcmVyKGdsKTtcclxuICAgIH1cclxuICAgIHNldChyLCBzcGVlZCkge1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgaWYgKCFyLnRleHR1cmUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTWVzaCBkb2VzIG5vdCBjb250YWluIGEgdGV4dHVyZSFcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2F2ZSBob3cgbWFueSBmYWNlcyBuZWVkIHRvIGJlIGRyYXduXHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSByLm1lc2gubGlua3MuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgLy8gYnVmZmVyIDFcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfcG9zaXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHIubWVzaC52ZXJ0cy5kYXRhLCB0aGlzLmNvbnZlcnREcmF3U3BlZWQoc3BlZWQpKTtcclxuICAgICAgICAvLyBidWZmZXIgMlxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfdGV4Y29vcmRfYnVmZmVyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV90ZXhjb29yZCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgci51dnMuZGF0YSwgdGhpcy5jb252ZXJ0RHJhd1NwZWVkKHNwZWVkKSk7XHJcbiAgICAgICAgLy8gYnVmZmVyIDNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4X2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IFVpbnQxNkFycmF5KHIubWVzaC5saW5rcy5kYXRhKSwgdGhpcy5jb252ZXJ0RHJhd1NwZWVkKHNwZWVkKSk7XHJcbiAgICAgICAgLy8gdGV4dHVyZVxyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLnRleHR1cmVfaWQpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByLnRleHR1cmUpO1xyXG4gICAgICAgIC8vIGFsdGVybmF0aXZlIHRleHR1cmUgLT4gRmlsbCB0aGUgdGV4dHVyZSB3aXRoIGEgMXgxIGJsdWUgcGl4ZWwuXHJcbiAgICAgICAgLy8gZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBuZXcgVWludDhBcnJheShbMCwgMTI4LCAxMjgsIDI1NV0pKTtcclxuICAgICAgICAvLyBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG1lc2gudGV4dHVyZS5kYXRhKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoY29udGV4dCkge1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgbGV0IGNhbWVyYSA9IGNvbnRleHQuY2FtZXJhO1xyXG4gICAgICAgIGxldCBtYXRyaXggPSBjYW1lcmEudG90YWxNYXRyaXg7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJyZW5kZXJpbmcuLlwiKTtcclxuICAgICAgICAvLyB1c2UgdGhlIHByb2dyYW1cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVfdHJhbnNmb3JtLCBmYWxzZSwgbWF0cml4LmRhdGEpO1xyXG4gICAgICAgIC8vIHNldCB0ZXh0dXJlXHJcbiAgICAgICAgZ2wudW5pZm9ybTFpKHRoaXMudV90ZXh0dXJlLCB0aGlzLnRleHR1cmVfaWQpO1xyXG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLnRleHR1cmVfaWQpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZSk7XHJcbiAgICAgICAgLy8gYnVmZmVyIDFcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfcG9zaXRpb24pO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgMywgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAvLyBidWZmZXIgMlxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYV90ZXhjb29yZCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYV90ZXhjb29yZF9idWZmZXIpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3RleGNvb3JkLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIC8vIGJ1ZmZlciAzXHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleF9idWZmZXIpO1xyXG4gICAgICAgIC8vIGRyYXchXHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgdGhpcy5jb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG4gICAgc2V0QW5kUmVuZGVyKHIsIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnNldChyLCBEcmF3U3BlZWQuRHluYW1pY0RyYXcpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIG5hbWU6ICAgIG1lc2gtcmVuZGVyZXIudHNcclxuLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IFdlYkdMIGJhc2VkIHJlbmRlcmluZyBvZiBhIG1lc2guXHJcbmltcG9ydCB7IERyYXdTcGVlZCB9IGZyb20gXCIuLi9yZW5kZXIvcmVuZGVyZXJcIjtcclxuaW1wb3J0IHsgTGluZVJlbmRlcmVyIH0gZnJvbSBcIi4vbGluZS1yZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBTaW1wbGVNZXNoUmVuZGVyZXIgfSBmcm9tIFwiLi9zaW1wbGUtbWVzaC1yZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBOb3JtYWxSZW5kZXJlciB9IGZyb20gXCIuL21lc2gtbm9ybWFscy1yZW5kZXJlclwiO1xyXG5pbXBvcnQgeyBEb3RSZW5kZXJlcjMgfSBmcm9tIFwiLi9kb3QtcmVuZGVyZXIzXCI7XHJcbmltcG9ydCB7IE1ldGFSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXIvbWV0YS1yZW5kZXJlclwiO1xyXG5leHBvcnQgY2xhc3MgR3JhcGhEZWJ1Z1JlbmRlcmVyIGV4dGVuZHMgTWV0YVJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBmYWNlQ29sb3IgPSBbMSwgMCwgMCwgMC4yNV0sIGVkZ2VDb2xvciA9IFsxLCAwLCAwLCAxXSwgcmVuZGVyTm9ybWFsID0gdHJ1ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5mYWNlUmVuZCA9IG5ldyBTaW1wbGVNZXNoUmVuZGVyZXIoZ2wsIGZhY2VDb2xvcik7XHJcbiAgICAgICAgdGhpcy5saW5lUmVuZCA9IG5ldyBMaW5lUmVuZGVyZXIoZ2wsIGVkZ2VDb2xvcik7XHJcbiAgICAgICAgdGhpcy5wb2ludFJlbmQgPSBuZXcgRG90UmVuZGVyZXIzKGdsLCA3LCBlZGdlQ29sb3IsIGZhbHNlKTtcclxuICAgICAgICBpZiAocmVuZGVyTm9ybWFsKVxyXG4gICAgICAgICAgICB0aGlzLm5vcm1SZW5kID0gbmV3IE5vcm1hbFJlbmRlcmVyKGdsKTtcclxuICAgIH1cclxuICAgIHNldChncmFwaCwgc3BlZWQgPSBEcmF3U3BlZWQuU3RhdGljRHJhdykge1xyXG4gICAgICAgIC8vdGhpcy5mYWNlUmVuZC5zZXRNZXNoKGdsLCBtZXNoKTtcclxuICAgICAgICB0aGlzLnBvaW50UmVuZC5zZXQoZ3JhcGguYWxsVmVydFBvc2l0aW9ucygpLCBzcGVlZCk7XHJcbiAgICAgICAgdGhpcy5saW5lUmVuZC5zZXQoZ3JhcGgudG9MaW5lcygpLCBzcGVlZCk7XHJcbiAgICAgICAgLy8gdGhpcy5ub3JtUmVuZD8uc2V0V2l0aExpc3RzKGdyYXBoLmFsbFZlcnRQb3NpdGlvbnMoKSwgZ3JhcGguYWxsTm9ybXMoKSwgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLy8gcmVuZGVyIDEgaW1hZ2UgdG8gdGhlIHNjcmVlblxyXG4gICAgcmVuZGVyKGMpIHtcclxuICAgICAgICB0aGlzLnBvaW50UmVuZC5yZW5kZXIoYyk7XHJcbiAgICAgICAgLy8gdGhpcy5mYWNlUmVuZC5yZW5kZXIoZ2wsIGNhbWVyYS50b3RhbE1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5saW5lUmVuZC5yZW5kZXIoYyk7XHJcbiAgICAgICAgLy8gdGhpcy5ub3JtUmVuZD8ucmVuZGVyKGdsLCBjYW1lcmEpO1xyXG4gICAgfVxyXG4gICAgc2V0QW5kUmVuZGVyKHIsIGNvbnRleHQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2Qgbm90IGltcGxlbWVudGVkLlwiKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBkb213cmFwcGVycy50c1xyXG4vLyBhdXRob3IgOiBKb3MgRmVlbnN0cmFcclxuLy8gcHVycHVzZSA6IHdyYXAgY2VydGFpbiBET00gZnVuY3Rpb25hbGl0aWVzXHJcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZERyb3BGaWxlRXZlbnRMaXN0ZW5lcnMoY2FudmFzLCBmaWxlc0NhbGxiYWNrKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcInNldHRpbmcgdXAgZHJhZyBldmVudHMuLi5cIik7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdlbnRlclwiLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZW50ZXJpbmcgZW50ZXJpbmcuLi5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LCB0cnVlKTtcclxuICAgIC8vIHNldHVwIGZpbGUgdXBsb2FkXHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vYWRkIGhvdmVyIGNsYXNzIHdoZW4gZHJhZyBvdmVyXHJcbiAgICAgICAgLy8gZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm92ZXIgZHJhZy4uLi5cIik7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LCB0cnVlKTtcclxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ2xlYXZlXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vcmVtb3ZlIGhvdmVyIGNsYXNzIHdoZW4gZHJhZyBvdXRcclxuICAgICAgICAvLyBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwibGVhdmluZyBkcmFnLi4uLlwiKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0sIHRydWUpO1xyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vcHJldmVudCBicm93c2VyIGZyb20gb3BlbiB0aGUgZmlsZSB3aGVuIGRyb3Agb2ZmXHJcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAvL3JldHJpZXZlIHVwbG9hZGVkIGZpbGVzIGRhdGFcclxuICAgICAgICB2YXIgZmlsZXMgPSBldi5kYXRhVHJhbnNmZXIuZmlsZXM7XHJcbiAgICAgICAgZmlsZXNDYWxsYmFjayhmaWxlcyk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBsb2FkSW1hZ2VUZXN0KGZpbGVzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBpbWFnZSA9IHlpZWxkIGxvYWRJbWFnZUZyb21GaWxlKGZpbGVzLml0ZW0oMCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRUZXh0RnJvbUZpbGUoZmlsZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRKU09ORnJvbUZpbGUoZmlsZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcclxuICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycm9yKSA9PiByZWplY3QoZXJyb3IpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRJbWFnZUZyb21GaWxlKGZpbGUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IGxvYWRJbWFnZUhlbHBlcjEocmVhZGVyKS50aGVuKChpbWFnZURhdGEpID0+IHJlc29sdmUoaW1hZ2VEYXRhKSwgKGVycm9yKSA9PiByZWplY3QoZXJyb3IpKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VGcm9tQmxvYihibG9iKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiBsb2FkSW1hZ2VIZWxwZXIxKHJlYWRlcikudGhlbigoaW1hZ2VEYXRhKSA9PiByZXNvbHZlKGltYWdlRGF0YSksIChlcnJvcikgPT4gcmVqZWN0KGVycm9yKSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBsb2FkSW1hZ2VIZWxwZXIxKGZpbGVSZWFkZXIpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgbGV0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgICAgaW1nLnNyYyA9IGZpbGVSZWFkZXIucmVzdWx0O1xyXG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGxvYWRJbWFnZUhlbHBlcjIoaW1nKSk7XHJcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKGBTY3JpcHQgbG9hZCBlcnJvciBmb3IgJHtpbWd9YCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gbG9hZEltYWdlSGVscGVyMihpbWFnZSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gdHVybiBpdCBpbnRvIGltYWdlIGRhdGEgYnkgYnVpbGRpbmcgYSBjb21wbGV0ZSBjYW52YXMgYW5kIHNhbXBsaW5nIGl0XHJcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XHJcbiAgICBsZXQgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAoX2EgPSBjYW52YXMucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUNoaWxkKGNhbnZhcyk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG4iLCIvLyBDYW52YXNJbnB1dEhhbmRsZXIudHNcclxuLy8gYXV0aG9yIDogSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2UgOiBoYW5kbGUgYWxsIGlucHV0IGV2ZW50cy5cclxuaW1wb3J0IHsgVmVjdG9yMiB9IGZyb20gXCIuLi9tYXRoL3ZlY3RvclwiO1xyXG52YXIgS2V5O1xyXG4oZnVuY3Rpb24gKEtleSkge1xyXG4gICAgS2V5W0tleVtcIkFcIl0gPSAwXSA9IFwiQVwiO1xyXG4gICAgS2V5W0tleVtcIkJcIl0gPSAxXSA9IFwiQlwiO1xyXG4gICAgS2V5W0tleVtcIkNcIl0gPSAyXSA9IFwiQ1wiO1xyXG4gICAgS2V5W0tleVtcIkRcIl0gPSAzXSA9IFwiRFwiO1xyXG4gICAgS2V5W0tleVtcIkVcIl0gPSA0XSA9IFwiRVwiO1xyXG4gICAgS2V5W0tleVtcIkZcIl0gPSA1XSA9IFwiRlwiO1xyXG4gICAgS2V5W0tleVtcIkdcIl0gPSA2XSA9IFwiR1wiO1xyXG4gICAgS2V5W0tleVtcIkhcIl0gPSA3XSA9IFwiSFwiO1xyXG4gICAgS2V5W0tleVtcIklcIl0gPSA4XSA9IFwiSVwiO1xyXG4gICAgS2V5W0tleVtcIkpcIl0gPSA5XSA9IFwiSlwiO1xyXG4gICAgS2V5W0tleVtcIktcIl0gPSAxMF0gPSBcIktcIjtcclxuICAgIEtleVtLZXlbXCJMXCJdID0gMTFdID0gXCJMXCI7XHJcbiAgICBLZXlbS2V5W1wiTVwiXSA9IDEyXSA9IFwiTVwiO1xyXG4gICAgS2V5W0tleVtcIk5cIl0gPSAxM10gPSBcIk5cIjtcclxuICAgIEtleVtLZXlbXCJPXCJdID0gMTRdID0gXCJPXCI7XHJcbiAgICBLZXlbS2V5W1wiUFwiXSA9IDE1XSA9IFwiUFwiO1xyXG4gICAgS2V5W0tleVtcIlFcIl0gPSAxNl0gPSBcIlFcIjtcclxuICAgIEtleVtLZXlbXCJSXCJdID0gMTddID0gXCJSXCI7XHJcbiAgICBLZXlbS2V5W1wiU1wiXSA9IDE4XSA9IFwiU1wiO1xyXG4gICAgS2V5W0tleVtcIlRcIl0gPSAxOV0gPSBcIlRcIjtcclxuICAgIEtleVtLZXlbXCJVXCJdID0gMjBdID0gXCJVXCI7XHJcbiAgICBLZXlbS2V5W1wiVlwiXSA9IDIxXSA9IFwiVlwiO1xyXG4gICAgS2V5W0tleVtcIldcIl0gPSAyMl0gPSBcIldcIjtcclxuICAgIEtleVtLZXlbXCJYXCJdID0gMjNdID0gXCJYXCI7XHJcbiAgICBLZXlbS2V5W1wiWVwiXSA9IDI0XSA9IFwiWVwiO1xyXG4gICAgS2V5W0tleVtcIlpcIl0gPSAyNV0gPSBcIlpcIjtcclxuICAgIEtleVtLZXlbXCJVcFwiXSA9IDI2XSA9IFwiVXBcIjtcclxuICAgIEtleVtLZXlbXCJEb3duXCJdID0gMjddID0gXCJEb3duXCI7XHJcbiAgICBLZXlbS2V5W1wiTGVmdFwiXSA9IDI4XSA9IFwiTGVmdFwiO1xyXG4gICAgS2V5W0tleVtcIlJpZ2h0XCJdID0gMjldID0gXCJSaWdodFwiO1xyXG4gICAgS2V5W0tleVtcIlNwYWNlXCJdID0gMzBdID0gXCJTcGFjZVwiO1xyXG4gICAgS2V5W0tleVtcIkNvbnRyb2xcIl0gPSAzMV0gPSBcIkNvbnRyb2xcIjtcclxuICAgIEtleVtLZXlbXCJBbHRcIl0gPSAzMl0gPSBcIkFsdFwiO1xyXG4gICAgS2V5W0tleVtcIlNoaWZ0XCJdID0gMzNdID0gXCJTaGlmdFwiO1xyXG4gICAgS2V5W0tleVtcIkVudGVyXCJdID0gMzRdID0gXCJFbnRlclwiO1xyXG4gICAgS2V5W0tleVtcIkVzY1wiXSA9IDM1XSA9IFwiRXNjXCI7XHJcbiAgICBLZXlbS2V5W1wiTjFcIl0gPSAzNl0gPSBcIk4xXCI7XHJcbiAgICBLZXlbS2V5W1wiTjJcIl0gPSAzN10gPSBcIk4yXCI7XHJcbiAgICBLZXlbS2V5W1wiTjNcIl0gPSAzOF0gPSBcIk4zXCI7XHJcbiAgICBLZXlbS2V5W1wiTjRcIl0gPSAzOV0gPSBcIk40XCI7XHJcbiAgICBLZXlbS2V5W1wiTjVcIl0gPSA0MF0gPSBcIk41XCI7XHJcbiAgICBLZXlbS2V5W1wiTjZcIl0gPSA0MV0gPSBcIk42XCI7XHJcbiAgICBLZXlbS2V5W1wiTjdcIl0gPSA0Ml0gPSBcIk43XCI7XHJcbiAgICBLZXlbS2V5W1wiTjhcIl0gPSA0M10gPSBcIk44XCI7XHJcbiAgICBLZXlbS2V5W1wiTjlcIl0gPSA0NF0gPSBcIk45XCI7XHJcbiAgICBLZXlbS2V5W1wiTjBcIl0gPSA0NV0gPSBcIk4wXCI7XHJcbiAgICBLZXlbS2V5W1wiUGx1c1wiXSA9IDQ2XSA9IFwiUGx1c1wiO1xyXG4gICAgS2V5W0tleVtcIk1pbnVzXCJdID0gNDddID0gXCJNaW51c1wiO1xyXG4gICAgS2V5W0tleVtcIkJhY2tzcGFjZVwiXSA9IDQ4XSA9IFwiQmFja3NwYWNlXCI7XHJcbn0pKEtleSB8fCAoS2V5ID0ge30pKTtcclxuZnVuY3Rpb24gdG9NYXBwaW5nKGtleSkge1xyXG4gICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICBjYXNlIEtleS5BOlxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICBjYXNlIEtleS5COlxyXG4gICAgICAgICAgICByZXR1cm4gMjtcclxuICAgICAgICBjYXNlIEtleS5DOlxyXG4gICAgICAgICAgICByZXR1cm4gMztcclxuICAgICAgICBjYXNlIEtleS5EOlxyXG4gICAgICAgICAgICByZXR1cm4gNDtcclxuICAgICAgICBjYXNlIEtleS5FOlxyXG4gICAgICAgICAgICByZXR1cm4gNTtcclxuICAgICAgICBjYXNlIEtleS5GOlxyXG4gICAgICAgICAgICByZXR1cm4gNjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgSW5wdXRTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMpIHtcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0gVmVjdG9yMi56ZXJvKCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZURlbHRhID0gVmVjdG9yMi56ZXJvKCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZUxlZnREb3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZUxlZnRQcmVzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZUxlZnRQcmV2ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZVJpZ2h0RG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2VSaWdodFByZXNzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1vdXNlUmlnaHRQcmV2ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZU1pZGRsZURvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1vdXNlTWlkZGxlUHJlc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2VNaWRkbGVQcmV2ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5rZXlzRG93biA9IHt9O1xyXG4gICAgICAgIHRoaXMua2V5c1ByZXNzZWQgPSBbXTtcclxuICAgICAgICB0aGlzLnNjcm9sbFZhbHVlID0gMDtcclxuICAgICAgICAvLyBsaW5rXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgLy8gdGltZVxyXG4gICAgICAgIHRoaXMudGljayA9IDA7XHJcbiAgICAgICAgdGhpcy5vbGRUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB0aGlzLm5ld1RpbWUgPSB0aGlzLm9sZFRpbWU7XHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIHRoaXMubWluaW11bVRpY2sgPSAxMDAwIC8gMTQ0O1xyXG4gICAgICAgIC8vIG1vdXNlXHJcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5zZXRNb3VzZVBvcy5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCB0aGlzLnNldE1vdXNlRG93bi5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5zZXRNb3VzZVVwLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuc2V0TW91c2VQb3MuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCB0aGlzLnNldE1vdXNlU2Nyb2xsLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuc2V0VG91Y2guYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuc2V0VG91Y2guYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnNldFRvdWNoVXAuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMjM7IGkrKylcclxuICAgICAgICAgICAgdGhpcy5rZXlzRG93bltpXSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGtleWJvYXJkXHJcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub25LZXlEb3duLmJpbmQodGhpcykpO1xyXG4gICAgICAgIC8vIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NlZFwiLCB0aGlzLm9uS2V5UHJlc3NlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMub25LZXlVcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvLyBmaW5hbFxyXG4gICAgICAgIGNhbnZhcy5mb2N1cygpO1xyXG4gICAgfVxyXG4gICAgcHJlVXBkYXRlKCkge1xyXG4gICAgICAgIC8vIHRoaXMgbXVzdCBiZSBjYWxsZWQgZXZlcnkgdGljayB3aXRoaW4gd2hhdGV2ZXIgY29udGV4dCB0aGlzIGlzIHVzZWRcclxuICAgICAgICAvLyB1cGRhdGUgdGltZVxyXG4gICAgICAgIHRoaXMubmV3VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy50aWNrID0gdGhpcy5uZXdUaW1lIC0gdGhpcy5vbGRUaW1lO1xyXG4gICAgICAgIHRoaXMub2xkVGltZSA9IHRoaXMubmV3VGltZTtcclxuICAgICAgICAvLyB1cGRhdGUgbW91c2VcclxuICAgICAgICB0aGlzLm1vdXNlTGVmdFByZXNzZWQgPSB0aGlzLm1vdXNlTGVmdFByZXYgIT0gdGhpcy5tb3VzZUxlZnREb3duICYmIHRoaXMubW91c2VMZWZ0RG93bjtcclxuICAgICAgICB0aGlzLm1vdXNlUmlnaHRQcmVzc2VkID0gdGhpcy5tb3VzZVJpZ2h0UHJldiAhPSB0aGlzLm1vdXNlUmlnaHREb3duICYmIHRoaXMubW91c2VSaWdodERvd247XHJcbiAgICAgICAgdGhpcy5tb3VzZU1pZGRsZVByZXNzZWQgPVxyXG4gICAgICAgICAgICB0aGlzLm1vdXNlTWlkZGxlUHJldiAhPSB0aGlzLm1vdXNlTWlkZGxlRG93biAmJiB0aGlzLm1vdXNlTWlkZGxlRG93bjtcclxuICAgICAgICB0aGlzLm1vdXNlTGVmdFByZXYgPSB0aGlzLm1vdXNlTGVmdERvd247XHJcbiAgICAgICAgdGhpcy5tb3VzZVJpZ2h0UHJldiA9IHRoaXMubW91c2VSaWdodERvd247XHJcbiAgICAgICAgdGhpcy5tb3VzZU1pZGRsZVByZXYgPSB0aGlzLm1vdXNlTWlkZGxlRG93bjtcclxuICAgIH1cclxuICAgIHBvc3RVcGRhdGUoKSB7XHJcbiAgICAgICAgLy8gdGhpcyBhbHNvIG11c3QgYmUgY2FsbGVkIGZvciBrZXlJc1ByZXNzZWQgdG8gd29ya1xyXG4gICAgICAgIC8vIHJlZnJlc2gga2V5cHJlc3Nlc1xyXG4gICAgICAgIHRoaXMua2V5c1ByZXNzZWQgPSBbXTtcclxuICAgIH1cclxuICAgIElzS2V5RG93bihrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzRG93bltrZXldO1xyXG4gICAgfVxyXG4gICAgSXNLZXlQcmVzc2VkKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmtleXNQcmVzc2VkLmluY2x1ZGVzKGtleSk7XHJcbiAgICB9XHJcbiAgICBvbktleURvd24oZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmtleXNEb3duW2Uua2V5XSA9PSB0cnVlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc29sZS5sb2coZS5rZXkpO1xyXG4gICAgICAgIHRoaXMua2V5c0Rvd25bZS5rZXkudG9Mb3dlckNhc2UoKV0gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMua2V5c1ByZXNzZWQucHVzaChlLmtleSk7XHJcbiAgICB9XHJcbiAgICBvbktleVVwKGUpIHtcclxuICAgICAgICB0aGlzLmtleXNEb3duW2Uua2V5LnRvTG93ZXJDYXNlKCldID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBvbktleVByZXNzZWQoZSkge1xyXG4gICAgICAgIC8vIE5PVEU6IGkgbWFkZSBhIGRpZmZlcmVudCBzeXN0ZW0gdG8gaGFuZGxlIHRoaXMsIHNlZSBvbktleURvd25cclxuICAgIH1cclxuICAgIHNldFRvdWNoKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZVBvcyA9IG5ldyBWZWN0b3IyKGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XHJcbiAgICAgICAgdGhpcy5tb3VzZUxlZnREb3duID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldFRvdWNoVXAoZSkge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLm1vdXNlTGVmdERvd24gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHNldE1vdXNlU2Nyb2xsKGUpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIndlIGJlIHNjcm9sbGluJyBub3cuLi5cIilcclxuICAgICAgICAvLyBub3JtYWxpemUgYWxsIHNjcm9sbGluZyBiZWhhdmlvdXJcclxuICAgICAgICBsZXQgdmFsdWUgPSAwLjE7XHJcbiAgICAgICAgaWYgKGUuZGVsdGFZIDwgMClcclxuICAgICAgICAgICAgdmFsdWUgPSAtMC4xO1xyXG4gICAgICAgIC8vIHdlIGRvbnQgd2FudCBuZWdhdGl2ZSBzY3JvbGwgdmFsdWVzLi4uXHJcbiAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZSA9IE1hdGgubWF4KDAsIHRoaXMuc2Nyb2xsVmFsdWUgKyB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzZXRNb3VzZVBvcyhlKSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBhIGJpdCBtZXNzeSwgQlVULCBtdWx0aXBseSBieSBjYW1lcmEgcGFyYW1ldGVyc1xyXG4gICAgICAgIHRoaXMubW91c2VQb3MgPSBuZXcgVmVjdG9yMihlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcbiAgICB9XHJcbiAgICBzZXRNb3VzZVVwKGUpIHtcclxuICAgICAgICBsZXQgY29kZSA9IGUuYnV0dG9ucztcclxuICAgICAgICBpZiAoY29kZSA8IDQpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZU1pZGRsZURvd24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGUgPCAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VSaWdodERvd24gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGUgPCAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW91c2VMZWZ0RG93biA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldE1vdXNlRG93bihlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuZm9jdXMoKTtcclxuICAgICAgICBsZXQgY29kZSA9IGUuYnV0dG9ucztcclxuICAgICAgICBpZiAoY29kZSA+PSA0KSB7XHJcbiAgICAgICAgICAgIGNvZGUgLT0gNDtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZU1pZGRsZURvd24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZSA+PSAyKSB7XHJcbiAgICAgICAgICAgIGNvZGUgLT0gMjtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZVJpZ2h0RG93biA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2RlID49IDEpIHtcclxuICAgICAgICAgICAgY29kZSAtPSAxO1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlTGVmdERvd24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIEZwc0NvdW50ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5mcHMgPSAwO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRXZlcnlYVGlja3MgPSAxMDA7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkID0gMDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmZyYW1lcyArPSAxO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZCArPSBzdGF0ZS50aWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmVsYXBzZWQgPiB0aGlzLnVwZGF0ZUV2ZXJ5WFRpY2tzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RnBzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRGcHMoKSB7XHJcbiAgICAgICAgdGhpcy5mcHMgPSBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lcyAvIHRoaXMuZWxhcHNlZCkgKiAxMDAwKTtcclxuICAgIH1cclxuICAgIGdldEZwcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcHM7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gQXV0aG9yOiBKb3MgRmVlbnN0cmFcclxuLy8gUHVycG9zZTogVGhlIENvcmUgYXBwLiBUaGlzIGNhbiBob2xkIG11bHRpcGxlIG90aGVyIGFwcHMgd2l0aCB0aGVpciBvd24gVXBkYXRlIGFuZCBEcmF3IGNhbGxzLlxyXG4vLyBVc2UgdGhpcyB0byBzd2l0Y2ggYmV0d2VlbiBBcHBzLCBvciBydW4gbXVsdGlwbGUgQXBwcy5cclxuaW1wb3J0IHsgSW5wdXRTdGF0ZSB9IGZyb20gXCIuL2lucHV0LXN0YXRlXCI7XHJcbmltcG9ydCB7IEZwc0NvdW50ZXIgfSBmcm9tIFwiLi9mcHNDb3VudGVyXCI7XHJcbmltcG9ydCB7IFVJIH0gZnJvbSBcIi4vdWlcIjtcclxuZXhwb3J0IGNsYXNzIENvcmUge1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCBnbCwgdWlGcmFtZSkge1xyXG4gICAgICAgIHRoaXMuU1RPUCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IElucHV0U3RhdGUoY2FudmFzKTtcclxuICAgICAgICB0aGlzLmZwc0NvdW50ZXIgPSBuZXcgRnBzQ291bnRlcigpO1xyXG4gICAgICAgIHRoaXMudWkgPSBuZXcgVUkodWlGcmFtZSk7XHJcbiAgICAgICAgdGhpcy5hcHBzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLy8gdG9kbzogY3ljbGUgdGhyb3VnaCBhcHBzXHJcbiAgICBhZGRBcHAoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHBzLnNldChhcHAubmFtZSwgYXBwKTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlQXBwKGFwcCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVBcHAoYXBwTmFtZSkge1xyXG4gICAgICAgIHRoaXMudWkucmVtb3ZlQ29udGV4dChhcHBOYW1lKTtcclxuICAgICAgICB0aGlzLmFwcHMuZGVsZXRlKGFwcE5hbWUpO1xyXG4gICAgfVxyXG4gICAgYWN0aXZhdGVBcHAoYXBwKSB7XHJcbiAgICAgICAgdGhpcy51aS5hZGRDb250ZXh0KGFwcC5uYW1lKTtcclxuICAgICAgICB0aGlzLnVpLmFkZFRleHQoYXBwLmRlc2NyaXB0aW9uKTtcclxuICAgICAgICBhcHAudWkodGhpcy51aSk7XHJcbiAgICAgICAgYXBwLnN0YXJ0KCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5wcmVVcGRhdGUoKTtcclxuICAgICAgICB0aGlzLmZwc0NvdW50ZXIudXBkYXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLklzS2V5UHJlc3NlZChcIkVzY1wiKSlcclxuICAgICAgICAgICAgdGhpcy5TVE9QID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmFwcHMuZm9yRWFjaCgoYXBwKSA9PiB7XHJcbiAgICAgICAgICAgIGFwcC51cGRhdGUodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3N0VXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICAvLyBwdXQgZnBzIGluIHRoZSB0aXRsZVxyXG4gICAgICAgIC8vIGRvY3VtZW50LnRpdGxlID0gXCJmcHM6IFwiICsgdGhpcy5mcHNDb3VudGVyLmdldEZwcygpO1xyXG4gICAgICAgIC8vIHByZS1nbCBidXNpbmVzc1xyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJIZWlnaHQgIT0gY2FudmFzLmhlaWdodCB8fCB3aW5kb3cuaW5uZXJXaWR0aCAhPSBjYW52YXMud2lkdGgpIHtcclxuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgLy8gY2FudmFzLmNsaWVudEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgLy8gY2FudmFzLmNsaWVudFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW5kZXJlci5yZXNpemVDYW52YXModGhpcy5nbCk7XHJcbiAgICAgICAgdGhpcy5nbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuZ2wuY2xlYXIodGhpcy5nbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAvLyByZW5kZXIgYWxsIGFwcHNcclxuICAgICAgICAvLyBUT0RPIDogcmV2ZXJzZSBvcmRlclxyXG4gICAgICAgIHRoaXMuYXBwcy5mb3JFYWNoKChhcHApID0+IHtcclxuICAgICAgICAgICAgYXBwLmRyYXcodGhpcy5nbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUmVjdGFuZ2xlMywgUGxhbmUsIFZlY3RvcjMsIERvbWFpbjIsIE1lc2gsIFRleHR1cmVNZXNoUmVuZGVyZXIsIH0gZnJvbSBcIi4uL2xpYlwiO1xyXG5pbXBvcnQgeyBDb21iaSB9IGZyb20gXCIuLi9yZW5kZXIvY29tYm9cIjtcclxuZXhwb3J0IGNsYXNzIEltYWdlQ29tYmkgZXh0ZW5kcyBDb21iaSB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIHN1cGVyKGdsLCBbXSwgVGV4dHVyZU1lc2hSZW5kZXJlci5uZXcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhnbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VDb21iaShnbCk7XHJcbiAgICB9XHJcbiAgICBidWZmZXIoKSB7XHJcbiAgICAgICAgLy8gaSB3YXMgaGF2aW5nIHRyb3VibGUgcmVuZGVyaW5nIGltYWdlcy4uLiB0aGlzIGlzIGEgd29ya2Fyb3VuZDpcclxuICAgICAgICAvLyBjb252ZXJ0IHRoZSB0aGlzLmltYWdlc1tdIGxpc3QgaW50byB0aGUgdGhpcy5pbWFnZU1lc2hlcyBsaXN0LiB0aGVuIHJlbmRlciB0aGF0IHdpdGggdGhlIG5vcm1hbCByZW5kZXJlclxyXG4gICAgICAgIHRoaXMuYnVmZmVyZWQgPSBbXTtcclxuICAgICAgICBsZXQgc2l6ZSA9IDI1NjtcclxuICAgICAgICBsZXQgYWNjSGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRlLmZvckVhY2goKHMsIGkpID0+IHtcclxuICAgICAgICAgICAgbGV0IGhlaWdodCA9IHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzLndpZHRoO1xyXG4gICAgICAgICAgICBsZXQgcmVjID0gbmV3IFJlY3RhbmdsZTMoUGxhbmUuZnJvbVBWVihuZXcgVmVjdG9yMygwLCAwLCAwKSwgbmV3IFZlY3RvcjMoMCwgMCwgMSksIG5ldyBWZWN0b3IzKC0xLCAwLCAwKSksIERvbWFpbjIuZnJvbUJvdW5kcygxMCwgMTAgKyB3aWR0aCwgYWNjSGVpZ2h0LCBhY2NIZWlnaHQgKyBoZWlnaHQpKTtcclxuICAgICAgICAgICAgbGV0IG1lc2ggPSBNZXNoLmZyb21SZWN0KHJlYyk7XHJcbiAgICAgICAgICAgIG1lc2guc2V0VGV4dHVyZShzLnJlc2l6ZShzaXplLCBzaXplKS50b0ltYWdlRGF0YSgpKTsgLy8gbm90ZTogd2ViZ2wgY2FuIG9ubHkgd29yayB3aXRoIDJeeCAqIDUxMiBpbWFnZXNcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZC5wdXNoKG1lc2gpO1xyXG4gICAgICAgICAgICBhY2NIZWlnaHQgKz0gaGVpZ2h0ICsgMTA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gcHVycG9zZTogbWFrZSBzdXJlIHRoZSBlbnRpcmUgbGlicmFyeSBpcyBjYWxsYWJsZSBmcm9tIG9uZSBwb2ludC5cclxuZXhwb3J0ICogZnJvbSBcIi4vYWxnb3JpdGhtcy9tYXJjaGluZy1jdWJlc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hbGdvcml0aG1zL3Blcmxpbi1ub2lzZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9hcHAvYXBwXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2FwcC9zd2FwLWFwcFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9kYXRhL2Zsb2F0LW1hdHJpeFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9kYXRhL2hhc2gtdGFibGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZGF0YS9pbnQtY3ViZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9kYXRhL2ludC1tYXRyaXhcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZGF0YS9saW5rZWQtbGlzdFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9kYXRhL3ZlY3Rvci1hcnJheVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nZW8vY2lyY2xlMlwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nZW8vY2lyY2xlM1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nZW8vY3ViZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nZW8vZ2VvXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2dlby9pbnRlcnNlY3RcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2VvL2xpbmVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vZ2VvL3BsYW5lXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2dlby9wb2x5bGluZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9nZW8vcmVjdGFuZ2xlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL2dlby90cmlhbmdsZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9pbWcvSW1hZ2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vaW1nL2tlcm5lbHNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC9jb25zdFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9tYXRoL2RvbWFpblwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9tYXRoL21hdGhcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC9tYXRyaXhcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC9xdWF0ZXJuaW9uXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL21hdGgvcmF5XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL21hdGgvc3RhdGlzdGljc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9tYXRoL3V0aWxcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWF0aC92ZWN0b3JcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWVzaC9ncmFwaFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9tZXNoL2xpbmUtYXJyYXlcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWVzaC9tZXNoXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL21lc2gvcmVuZGVyLW1lc2hcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vbWVzaC90b3BvLW1lc2hcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vcmVuZGVyL2NhbWVyYVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9yZW5kZXIvY29tYm9cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vcmVuZGVyL2xpZ2h0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlci9jb250ZXh0XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlci9yZW5kZXJlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9yZW5kZXJlcnMvYmlsbGJvYXJkLXJlbmRlcmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy9kb3QtcmVuZGVyZXIyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy9kb3QtcmVuZGVyZXIzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy9saW5lLXJlbmRlcmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy9tZXNoLWRlYnVnLXJlbmRlcmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy9tZXNoLW5vcm1hbHMtcmVuZGVyZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vcmVuZGVyZXJzL3JlY3RhbmdsZS1yZW5kZXJlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9yZW5kZXJlcnMvc2hhZGVkLW1lc2gtcmVuZGVyZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vcmVuZGVyZXJzL3NpbXBsZS1tZXNoLXJlbmRlcmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmVycy90ZXh0dXJlLW1lc2gtcmVuZGVyZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vcmVuZGVyZXJzL2dyYXBoLWRlYnVnLXJlbmRlcmVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3N5c3RlbS9kb213cmFwcGVyc1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9zeXN0ZW0vZnBzQ291bnRlclwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi9zeXN0ZW0vaW5wdXQtc3RhdGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vc3lzdGVtL3VpXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3N5c3RlbS9jb3JlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuL3JlbmRlcmNvbWJvcy9pbWFnZS1jb21iaVwiO1xyXG4iLCJpbXBvcnQgeyBJbnRNYXRyaXgsIE1lc2gsIFBsYW5lLCBWZWN0b3IzIH0gZnJvbSBcIi4uLy4uLy4uL3NyYy9saWJcIjtcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyYXBoKGxpZnRUeXBlLCBzdWJjb3VudCwgcXVhZHN1YmNvdW50LCByYW5kb21FZGdlcykge1xyXG4gICAgLy8gMCB8IHNldHVwXHJcbiAgICBjb25zdCBtZXNoID0gTWVzaC5uZXdJY29zYWhlZHJvbigwLjUpO1xyXG4gICAgbGV0IGdyYXBoID0gbWVzaC50b0dyYXBoKCk7XHJcbiAgICBsZXQgY2VudGVyID0gbmV3IFZlY3RvcjMoMCwgMCwgMCk7XHJcbiAgICBsZXQgcmFkaXVzID0gMTtcclxuICAgIC8vIDEgfCBzdWJkaXZpZGVcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViY291bnQ7IGkrKykge1xyXG4gICAgICAgIGdyYXBoLnN1YmRpdmlkZSgpO1xyXG4gICAgICAgIC8vIGxpZnQgdG8gc3BoZXJlIGFmdGVyIGV2ZXJ5IHN1YmRpdmlzaW9uXHJcbiAgICAgICAgaWYgKGxpZnRUeXBlID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgY291bnQgPSBncmFwaC5nZXRWZXJ0ZXhDb3VudCgpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb3MgPSBncmFwaC5nZXRWZXJ0ZXhQb3MoaSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9ybWFsID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRpcyA9IGNlbnRlci5kaXNUbyhwb3MpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpZnQgPSByYWRpdXMgLSBkaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlmdFR5cGUgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zLmFkZChub3JtYWwuc2NhbGVkKGxpZnQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcy5hZGQobm9ybWFsLm5vcm1hbGl6ZWQoKS5zY2FsZWQobGlmdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gMiB8IHJlbW92ZSByYW5kb20gZWRnZXNcclxuICAgIGlmIChyYW5kb21FZGdlcyA9PSAxKSB7XHJcbiAgICAgICAgcXVhZGlmaWNhdGlvbihncmFwaCk7XHJcbiAgICB9XHJcbiAgICAvLyAzIHwgc3ViZGl2aWRlIHF1YWRcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZHN1YmNvdW50OyBpKyspIHtcclxuICAgICAgICBncmFwaC5zdWJkaXZpZGVRdWFkKCk7XHJcbiAgICB9XHJcbiAgICAvLyBsaWZ0IHRvIHNwaGVyZSBhZnRlciBldmVyeSBzdWJkaXZpc2lvblxyXG4gICAgaWYgKGxpZnRUeXBlID4gMCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IGdyYXBoLmdldFZlcnRleENvdW50KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBwb3MgPSBncmFwaC5nZXRWZXJ0ZXhQb3MoaSk7XHJcbiAgICAgICAgICAgIGxldCBub3JtYWwgPSBncmFwaC5nZXRWZXJ0ZXhOb3JtYWwoaSk7XHJcbiAgICAgICAgICAgIGxldCBkaXMgPSBjZW50ZXIuZGlzVG8ocG9zKTtcclxuICAgICAgICAgICAgbGV0IGxpZnQgPSByYWRpdXMgLSBkaXM7XHJcbiAgICAgICAgICAgIGlmIChsaWZ0VHlwZSA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHBvcy5hZGQobm9ybWFsLnNjYWxlZChsaWZ0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb3MuYWRkKG5vcm1hbC5ub3JtYWxpemVkKCkuc2NhbGVkKGxpZnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHF1YWQgcmVsYXhhdGlvbiBmcm9tIGJlZ2lubmluZz9cclxuICAgIHJldHVybiBncmFwaDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGlsZVdvcmxkKGNvdW50LCBoZWlnaHQpIHtcclxuICAgIGxldCBtID0gbmV3IEludE1hdHJpeChjb3VudCwgaGVpZ2h0KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5faGVpZ2h0OyBpKyspIHtcclxuICAgICAgICBsZXQgdmFsID0gcmFuZG9tSW50KG0uX3dpZHRoICsgMSk7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtLl93aWR0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIGlmIChqIDwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICBtLnNldChpLCBqLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG0uc2V0KGksIGosIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG07XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIG1lc2hpZnlHcmFwaFN1cmZhY2UoZ3JhcGgpIHtcclxuICAgIC8vIGluaXQgcmVzdWx0XHJcbiAgICBsZXQgbWVzaGVzID0gW107XHJcbiAgICAvLyBwZXIgcXVhZFxyXG4gICAgbGV0IGxvb3BzID0gZ3JhcGguYWxsVmVydExvb3BzQXNJbnRzKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbG9vcCA9IGxvb3BzW2ldO1xyXG4gICAgICAgIGlmIChsb29wLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkc1wiKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2ZWNzID0gbG9vcC5tYXAoKGopID0+IGdyYXBoLmdldFZlcnRleFBvcyhqKSk7XHJcbiAgICAgICAgbGV0IG0gPSBNZXNoLm5ld1F1YWQoW3ZlY3NbMF0sIHZlY3NbM10sIHZlY3NbMV0sIHZlY3NbMl1dKTtcclxuICAgICAgICBtZXNoZXMucHVzaChtKTtcclxuICAgIH1cclxuICAgIGxldCByZW5kID0gTWVzaC5mcm9tSm9pbihtZXNoZXMpLnRvUmVuZGVyYWJsZSgpO1xyXG4gICAgcmVuZC5jYWxjdWxhdGVWZXJ0ZXhOb3JtYWxzKCk7XHJcbiAgICByZXR1cm4gcmVuZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gbWVzaGlmeVRpbGVXb3JsZChncmFwaCwgdGlsZXMsIHJhZGl1cywgLy8gYmFzZVxyXG5zdG9yZXlIZWlnaHQpIHtcclxuICAgIC8vIGluaXQgcmVzdWx0XHJcbiAgICBsZXQgbWVzaGVzID0gW107XHJcbiAgICAvLyBwZXIgcXVhZFxyXG4gICAgbGV0IGxvb3BzID0gZ3JhcGguYWxsVmVydExvb3BzQXNJbnRzKCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbG9vcCA9IGxvb3BzW2ldO1xyXG4gICAgICAgIGlmIChsb29wLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkc1wiKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2ZWNzID0gbG9vcC5tYXAoKGopID0+IGdyYXBoLmdldFZlcnRleFBvcyhqKSk7XHJcbiAgICAgICAgbGV0IHJvdyA9IHRpbGVzLmdldFJvdyhpKTtcclxuICAgICAgICAvLyBmaWxsIHJvd1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGlsZXMuX3dpZHRoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV0IHRpbGVUeXBlID0gcm93W2pdO1xyXG4gICAgICAgICAgICBpZiAodGlsZVR5cGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGxldmVsID0gcmFkaXVzICsgaiAqIHN0b3JleUhlaWdodDtcclxuICAgICAgICAgICAgbGV0IGxldmVsMiA9IHJhZGl1cyArIChqICsgMSkgKiBzdG9yZXlIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBtID0gTWVzaC5uZXdPY3QoW1xyXG4gICAgICAgICAgICAgICAgdmVjc1swXS5zY2FsZWQobGV2ZWwpLFxyXG4gICAgICAgICAgICAgICAgdmVjc1sxXS5zY2FsZWQobGV2ZWwpLFxyXG4gICAgICAgICAgICAgICAgdmVjc1szXS5zY2FsZWQobGV2ZWwpLFxyXG4gICAgICAgICAgICAgICAgdmVjc1syXS5zY2FsZWQobGV2ZWwpLFxyXG4gICAgICAgICAgICAgICAgdmVjc1swXS5zY2FsZWQobGV2ZWwyKSxcclxuICAgICAgICAgICAgICAgIHZlY3NbMV0uc2NhbGVkKGxldmVsMiksXHJcbiAgICAgICAgICAgICAgICB2ZWNzWzNdLnNjYWxlZChsZXZlbDIpLFxyXG4gICAgICAgICAgICAgICAgdmVjc1syXS5zY2FsZWQobGV2ZWwyKSxcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIG1lc2hlcy5wdXNoKG0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCByZW5kID0gTWVzaC5mcm9tSm9pbihtZXNoZXMpLnRvUmVuZGVyYWJsZSgpO1xyXG4gICAgcmVuZC5jYWxjdWxhdGVWZXJ0ZXhOb3JtYWxzKCk7XHJcbiAgICByZXR1cm4gcmVuZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29uc3RydWN0TWVzaEZyb21TcGhlcmVHcmFwaChncmFwaCwgcmFkaXVzLCAvLyB0byBwcm9qZWN0IGJhY2tcclxubGlmdEJvdCwgLy9cclxubGlmdFRvcCwgLy9cclxucmFuZCkge1xyXG4gICAgLy8gcmVjYWxjdWxhdGUgd29ybGQgbWVzaFxyXG4gICAgbGV0IHNjYWxlcjEgPSAxICsgbGlmdEJvdCAvIHJhZGl1cztcclxuICAgIGxldCBzY2FsZXIyID0gMSArIGxpZnRUb3AgLyByYWRpdXM7XHJcbiAgICBsZXQgbWVzaGVzID0gW107XHJcbiAgICBsZXQgbG9vcHMgPSBncmFwaC5hbGxWZXJ0TG9vcHNBc0ludHMoKTtcclxuICAgIGZvciAobGV0IGxvb3Agb2YgbG9vcHMpIHtcclxuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IHJhbmQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb29wLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2ZWNzID0gbG9vcC5tYXAoKGopID0+IGdyYXBoLmdldFZlcnRleFBvcyhqKSk7XHJcbiAgICAgICAgbGV0IG0gPSBNZXNoLm5ld09jdChbXHJcbiAgICAgICAgICAgIHZlY3NbMF0uc2NhbGVkKHNjYWxlcjEpLFxyXG4gICAgICAgICAgICB2ZWNzWzFdLnNjYWxlZChzY2FsZXIxKSxcclxuICAgICAgICAgICAgdmVjc1szXS5zY2FsZWQoc2NhbGVyMSksXHJcbiAgICAgICAgICAgIHZlY3NbMl0uc2NhbGVkKHNjYWxlcjEpLFxyXG4gICAgICAgICAgICB2ZWNzWzBdLnNjYWxlZChzY2FsZXIyKSxcclxuICAgICAgICAgICAgdmVjc1sxXS5zY2FsZWQoc2NhbGVyMiksXHJcbiAgICAgICAgICAgIHZlY3NbM10uc2NhbGVkKHNjYWxlcjIpLFxyXG4gICAgICAgICAgICB2ZWNzWzJdLnNjYWxlZChzY2FsZXIyKSxcclxuICAgICAgICBdKTtcclxuICAgICAgICBtZXNoZXMucHVzaChtKTtcclxuICAgIH1cclxuICAgIGxldCByZW5kID0gTWVzaC5mcm9tSm9pbihtZXNoZXMpO1xyXG4gICAgcmV0dXJuIHJlbmQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGF2ZXJhZ2VFZGdlTGVuZ3RoKGdyYXBoKSB7XHJcbiAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBncmFwaC5mb3JFdmVyeUVkZ2VWZXJ0cygoYSwgYikgPT4ge1xyXG4gICAgICAgIHN1bSArPSBhLmRpc1RvKGIpO1xyXG4gICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICB9KTtcclxuICAgIGxldCBhdmVyYWdlID0gc3VtIC8gY291bnQ7XHJcbiAgICByZXR1cm4gYXZlcmFnZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZWRnZVNtb290aChncmFwaCwgYXZlcmFnZSwgc2NhbGUpIHtcclxuICAgIGdyYXBoLmZvckV2ZXJ5RWRnZVZlcnRzKChhLCBiKSA9PiB7XHJcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gYS5kaXNUbyhiKTtcclxuICAgICAgICBsZXQgZGlmZiA9IGF2ZXJhZ2UgLSBkaXN0YW5jZTtcclxuICAgICAgICBsZXQgdmVjdG9yID0gYi5zdWJiZWQoYSk7XHJcbiAgICAgICAgYS5hZGQodmVjdG9yLnNjYWxlZCgtZGlmZiAqIHNjYWxlKSk7XHJcbiAgICAgICAgYi5hZGQodmVjdG9yLnNjYWxlZChkaWZmICogc2NhbGUpKTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBsYVBsYWNpYW4oZ3JhcGgpIHtcclxuICAgIGxldCBjb3VudCA9IGdyYXBoLmdldFZlcnRleENvdW50KCk7XHJcbiAgICBsZXQgbmV3cyA9IFtdO1xyXG4gICAgLy8gZ2V0IGNlbnRlciBvZiBuYnNcclxuICAgIGZvciAobGV0IHZpID0gMDsgdmkgPCBjb3VudDsgdmkrKykge1xyXG4gICAgICAgIGxldCB2ID0gZ3JhcGguZ2V0VmVydCh2aSk7XHJcbiAgICAgICAgaWYgKHYuZGVhZClcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgbGV0IHN1bSA9IFZlY3RvcjMuemVybygpO1xyXG4gICAgICAgIGxldCBuYnMgPSBncmFwaC5nZXRWZXJ0TmVpZ2hib3JzKHZpKTtcclxuICAgICAgICBmb3IgKGxldCBuYiBvZiBuYnMpIHtcclxuICAgICAgICAgICAgc3VtLmFkZChncmFwaC5nZXRWZXJ0ZXhQb3MobmIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VtLnNjYWxlKDEgLyBuYnMubGVuZ3RoKTtcclxuICAgICAgICBuZXdzLnB1c2goc3VtKTtcclxuICAgIH1cclxuICAgIC8vIHNldFxyXG4gICAgZm9yIChsZXQgdmkgPSAwOyB2aSA8IGNvdW50OyB2aSsrKSB7XHJcbiAgICAgICAgZ3JhcGguZ2V0VmVydGV4UG9zKHZpKS5jb3B5KG5ld3NbdmldKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJpZmljYXRpb24oZ3JhcGgsIGNlbnRlckNvcm5lckF2ZXJhZ2UpIHtcclxuICAgIC8vIG1ha2UgdGhlIHF1YWQgZ3JhcGggYXMgJ3NxdWFyZScgYXMgcG9zc2libGVcclxuICAgIC8vIHByZXBhcmVcclxuICAgIGxldCBmYWNlcyA9IGdyYXBoLmFsbFZlcnRMb29wc0FzSW50cygpO1xyXG4gICAgbGV0IGNvdW50ID0gZmFjZXMubGVuZ3RoO1xyXG4gICAgbGV0IGNlbnRlcnMgPSBuZXcgQXJyYXkoY291bnQpO1xyXG4gICAgbGV0IG1vdmVycyA9IG5ldyBBcnJheShncmFwaC52ZXJ0cy5sZW5ndGgpO1xyXG4gICAgbGV0IGNvdW50ZXJzID0gbmV3IEFycmF5KGdyYXBoLnZlcnRzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1vdmVyc1tpXSA9IFZlY3RvcjMubmV3KDAsIDAsIDApO1xyXG4gICAgICAgIGNvdW50ZXJzW2ldID0gMDtcclxuICAgIH1cclxuICAgIGxldCBjY2EgPSAwO1xyXG4gICAgLy8gaXRlcmF0ZSBwZXIgZmFjZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgLy8gZ2V0IGZhY2UsIGNlbnRlciBhbmQgY29ybmVyc1xyXG4gICAgICAgIGxldCBjZW50ZXIgPSBjZW50ZXJzW2ldO1xyXG4gICAgICAgIGxldCBmYWNlID0gZmFjZXNbaV07XHJcbiAgICAgICAgbGV0IGZhY2VDb3VudCA9IGZhY2UubGVuZ3RoO1xyXG4gICAgICAgIGlmIChmYWNlLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IFwiSEVMUCwgV0UgQVJFIE5PVCBERUFMSU5HIFdJVEggUVVBRFMgSEVSRSFcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2VudGVyID0gVmVjdG9yMy5uZXcoMCwgMCwgMCk7XHJcbiAgICAgICAgbGV0IGNvcm5lcnMgPSBuZXcgQXJyYXkoZmFjZUNvdW50KTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIGxldCB2aSA9IGZhY2Vbal07XHJcbiAgICAgICAgICAgIGNvcm5lcnNbal0gPSBncmFwaC5nZXRWZXJ0ZXhQb3ModmkpO1xyXG4gICAgICAgICAgICBjZW50ZXIuYWRkKGNvcm5lcnNbal0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjZW50ZXIuc2NhbGUoMSAvIGZhY2VDb3VudCk7XHJcbiAgICAgICAgLy8gbm93IHRoYXQgd2UgaGF2ZSBjZW50ZXIsIGNhbGN1bGF0ZSBjY2FcclxuICAgICAgICBsZXQgbG9jYWxfY2NhID0gMDtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIGxvY2FsX2NjYSA9IGNlbnRlci5kaXNUbyhjb3JuZXJzW2pdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9jYWxfY2NhIC89IGZhY2VDb3VudDtcclxuICAgICAgICBjY2EgKz0gbG9jYWxfY2NhO1xyXG4gICAgICAgIC8vIGJ1dCB1c2UgdGhlIGdpdmVuIG9uZSBpZiBwcmVzZW50XHJcbiAgICAgICAgbGV0IHNjYWxlcjtcclxuICAgICAgICBsZXQgY2NhX2RpZmY7XHJcbiAgICAgICAgaWYgKGNlbnRlckNvcm5lckF2ZXJhZ2UpIHtcclxuICAgICAgICAgICAgc2NhbGVyID0gY2VudGVyQ29ybmVyQXZlcmFnZTtcclxuICAgICAgICAgICAgY2NhX2RpZmYgPSBjZW50ZXJDb3JuZXJBdmVyYWdlIC0gbG9jYWxfY2NhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGVyID0gbG9jYWxfY2NhO1xyXG4gICAgICAgICAgICBjY2FfZGlmZiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJvdGF0ZSBhbGwgY29ybmVycyBpbnRvIHRoZSBzYW1lIHNwYWNlLCBhbmQgZ2V0IHRoZSBhdmVyYWdlIG9mIHRoYXRcclxuICAgICAgICAvLyBUT0RPIFNBVkUgVElNRSBCWSBET0lORyBUSElTOlxyXG4gICAgICAgIC8vIG5ldyBWZWN0b3IyKHYuZG90KGloYXQpLCB2LmRvdChqaGF0KSkuYW5nbGUoKVxyXG4gICAgICAgIGxldCBwbGFuZSA9IFBsYW5lLmZyb20zcHQoY2VudGVyLCBjb3JuZXJzWzBdLCBjb3JuZXJzWzFdKTtcclxuICAgICAgICBsZXQgbm9ybWVkQ29ybmVycyA9IG5ldyBBcnJheShmYWNlLmxlbmd0aCk7XHJcbiAgICAgICAgbGV0IG5vcm1lZENlbnRlciA9IFZlY3RvcjMubmV3KDAsIDAsIDApO1xyXG4gICAgICAgIGxldCBkZWx0YSA9IDIgLyBmYWNlQ291bnQ7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmYWNlQ291bnQ7IGorKykge1xyXG4gICAgICAgICAgICBub3JtZWRDb3JuZXJzW2pdID0gcGxhbmUucm90YXRlVmVjdG9yKGNvcm5lcnNbal0sIGogKiBNYXRoLlBJICogZGVsdGEpO1xyXG4gICAgICAgICAgICBub3JtZWRDZW50ZXIuYWRkKG5vcm1lZENvcm5lcnNbal0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzY2FsZSB0aGlzIGF2ZXJhZ2VkIHRvIHRoZSBjZW50ZXIgY29ybmVyIGF2ZXJhZ2VcclxuICAgICAgICBub3JtZWRDZW50ZXIuc2NhbGUoMSAvIDQpO1xyXG4gICAgICAgIGxldCBub3JtYWwgPSBub3JtZWRDZW50ZXIuc3ViYmVkKGNlbnRlcikubm9ybWFsaXplKCk7XHJcbiAgICAgICAgbGV0IHBlcmZlY3RDb3JuZXIgPSBjZW50ZXIuYWRkZWQobm9ybWFsLnNjYWxlZChsb2NhbF9jY2EpKTtcclxuICAgICAgICAvLyBpbmNyZWF0ZSBndW5mYWN0b3IgaWYgc3F1YXJlIGlzIHZlcnkgc21hbGwgKGF3d3cpXHJcbiAgICAgICAgbGV0IGd1bmZhY3RvciA9IDE7XHJcbiAgICAgICAgbGV0IGVxdWFsaXplciA9IDIwMDtcclxuICAgICAgICBndW5mYWN0b3IgKz0gTWF0aC5tYXgoLTEgKiBjY2FfZGlmZiAqIGVxdWFsaXplciwgMCk7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZ3VuZmFjdG9yKTtcclxuICAgICAgICAvLyByb3RhdGUgdGhpcyBhdmVyYWdlIGJhY2ssIGFuZCBhZGQgaXQgdG8gdGhlIG1vdmVycyBvZiBldmVyeSB2ZXJ0ZXhcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgIGxldCB2aSA9IGZhY2Vbal07XHJcbiAgICAgICAgICAgIGxldCB2ID0gcGxhbmUucm90YXRlVmVjdG9yKHBlcmZlY3RDb3JuZXIsIGogKiBNYXRoLlBJICogZGVsdGEpO1xyXG4gICAgICAgICAgICBtb3ZlcnNbdmldLmFkZCh2LnNjYWxlZChndW5mYWN0b3IpKTtcclxuICAgICAgICAgICAgY291bnRlcnNbdmldICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gbm93LCBtb3ZlIHRoZSBncmFwaFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3ZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgbW92ZXIgPSBtb3ZlcnNbaV07XHJcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBjb3VudGVyc1tpXTtcclxuICAgICAgICBpZiAoY291bnRlciA8IDEpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB2ID0gZ3JhcGguZ2V0VmVydGV4UG9zKGkpO1xyXG4gICAgICAgIHYuYWRkKG1vdmVyLnNjYWxlKDEgLyBjb3VudGVyKSk7XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gdGhlIGNlbnRlciBjb3JuZXIgYXZlcmFnZSwgdG8gYmUgdXNlZCBpbiB0aGUgbmV4dCBjeWNsZVxyXG4gICAgY2NhIC89IGNvdW50O1xyXG4gICAgcmV0dXJuIGNjYTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcXVhZGlmaWNhdGlvbihncmFwaCkge1xyXG4gICAgLy8gZWRnZSBkZWxldGlvbiBoZXVyaXN0aWM6XHJcbiAgICAvLyByZW1vdmUgZWRnZXMgYmV0d2VlbiB0d28gdHJpYW5nbGVzIHRvIGNyZWF0ZSBhIHF1YWQuXHJcbiAgICAvLyBrZWVwIHJlbW92aW5nIGVkZ2VzIHVudGlsIG5vIHRyaWFuZ2xlIG5laWdoYm9ycyBhbm90aGVyIHRyaWFuZ2xlLlxyXG4gICAgLy8gcHJlcGFyZVxyXG4gICAgbGV0IGNvdW50ID0gZ3JhcGguZWRnZXMubGVuZ3RoO1xyXG4gICAgbGV0IGVkZ2VJZHMgPSBuZXcgQXJyYXkoY291bnQpO1xyXG4gICAgbGV0IHZpc2l0ZWQgPSBuZXcgQXJyYXkoY291bnQpO1xyXG4gICAgZ3JhcGguZWRnZXMuZm9yRWFjaCgoZSwgaSkgPT4ge1xyXG4gICAgICAgIGVkZ2VJZHNbaV0gPSBpO1xyXG4gICAgICAgIHZpc2l0ZWRbaV0gPSBmYWxzZTtcclxuICAgIH0pO1xyXG4gICAgLy8gc2h1ZmZsZVxyXG4gICAgbGV0IHNodWZmbGVyID0gKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gMC41IC0gTWF0aC5yYW5kb20oKTtcclxuICAgIH07XHJcbiAgICBlZGdlSWRzLnNvcnQoc2h1ZmZsZXIpO1xyXG4gICAgLy8gcGVyIGVkZ2VcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgIGxldCBlaSA9IGVkZ2VJZHNbaV07XHJcbiAgICAgICAgbGV0IGUgPSBncmFwaC5lZGdlc1tlaV07XHJcbiAgICAgICAgaWYgKGUuZGVhZCB8fCB2aXNpdGVkW2VpXSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvb3BzID0gZ3JhcGguZ2V0TG9vcHNBZGphY2VudFRvRWRnZShlaSk7XHJcbiAgICAgICAgLy8gb25seSBkZWxldGUgZWRnZXMgYmV0d2VlbiB0cmlhbmdsZXNcclxuICAgICAgICBpZiAobG9vcHNbMF0ubGVuZ3RoID4gMyB8fCBsb29wc1sxXS5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgZWRnZXMgb2YgdGhpcyBuZXcgcXVhZCBzaG91bGQgbm90IGJlIHRvdWNoZWQhXHJcbiAgICAgICAgZm9yIChsZXQgbG9vcCBvZiBsb29wcykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlZGdlSW5kZXggb2YgbG9vcCkge1xyXG4gICAgICAgICAgICAgICAgdmlzaXRlZFtlZGdlSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3cgcmVtb3ZlIHRoaXMgZWRnZSBpdHNlbGZcclxuICAgICAgICBncmFwaC5kZWxldGVFZGdlQnlJbmRleChlaSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcclxuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xyXG59XHJcbiIsIi8vIG5hbWU6ICAgIHNpbXBsZS1saW5lLXJlbmRlcmVyLnRzXHJcbi8vIGF1dGhvcjogIEpvcyBGZWVuc3RyYVxyXG4vLyBwdXJwb3NlOiBXZWJHTCBiYXNlZCByZW5kZXJpbmcgb2YgbGluZXMuXHJcbmltcG9ydCB7IE1hdHJpeDQgfSBmcm9tIFwiLi4vbWF0aC9tYXRyaXhcIjtcclxuaW1wb3J0IHsgRHJhd1NwZWVkLCBSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXIvcmVuZGVyZXJcIjtcclxuZXhwb3J0IGNsYXNzIFRyYW5zZm9ybUxpbmVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBjb2xvciA9IFsxLCAwLCAwLCAwLjVdKSB7XHJcbiAgICAgICAgLy8gbm90ZTogSSBsaWtlIHZlcnRleCAmIGZyYWdtZW50cyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgc2NyaXB0IGl0c2VsZi5cclxuICAgICAgICAvLyB3aGVuIHlvdSBjaGFuZ2UgdmVydGV4IG9yIGZyYWdtZW50LCB0aGlzIGNsYXNzIGhhcyB0byBkZWFsIHdpdGggaXQuXHJcbiAgICAgICAgLy8gcHV0dGluZyB0aGVtIHNvbWV3aGVyZSBlbHNlIGRvZXNudCBtYWtlIHNlbnNlIHRvIG1lLFxyXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvdXBsZWQgMSB0byAxLlxyXG4gICAgICAgIGNvbnN0IHZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XG4gICAgICAgIHVuaWZvcm0gbWF0NCB1X3RyYW5zZm9ybTtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHVfcGVyc29uYWw7XG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdV90cmFuc2Zvcm0gKiB1X3BlcnNvbmFsICogYV9wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIGNvbnN0IGZzID0gYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBpbnQ7XG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xuXG4gICAgICAgIHZvaWQgbWFpbiAoKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB1X2NvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGA7XHJcbiAgICAgICAgLy8gc2V0dXAgcHJvZ3JhbVxyXG4gICAgICAgIHN1cGVyKGdsLCB2cywgZnMpO1xyXG4gICAgICAgIHRoaXMudV90cmFuc2Zvcm0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfdHJhbnNmb3JtXCIpO1xyXG4gICAgICAgIHRoaXMudV9wZXJzb25hbCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9wZXJzb25hbFwiKTtcclxuICAgICAgICB0aGlzLnVfY29sb3IgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcbiAgICAgICAgLy8gd2UgbmVlZCAyIGJ1ZmZlcnNcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb25fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICAvLyBzZXQgdW5pZm9ybXMgd2hpY2ggd29udCBjaGFuZ2VcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy52ZXJ0Q291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVyc29uYWwgPSBNYXRyaXg0Lm5ld0lkZW50aXR5KCk7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5ldyhnbCwgY29sb3IgPSBbMSwgMCwgMCwgMC41XSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtTGluZVJlbmRlcmVyKGdsLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgICBzZXQoZGF0YSwgc3BlZWQgPSBEcmF3U3BlZWQuU3RhdGljRHJhdykge1xyXG4gICAgICAgIC8vIHNhdmUgaG93IG1hbnkgZmFjZXMgbmVlZCB0byBiZSBkcmF3blxyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgbGV0IGxpbmtzO1xyXG4gICAgICAgIGxldCB2ZXJ0cztcclxuICAgICAgICAvLyBleHRyYWN0XHJcbiAgICAgICAgdmVydHMgPSBkYXRhLm1lc2gudmVydHM7XHJcbiAgICAgICAgbGlua3MgPSBkYXRhLm1lc2gudG9MaW5lcygpLmxpbmtzLmdldERhdGEoKTtcclxuICAgICAgICB0aGlzLnBlcnNvbmFsID0gZGF0YS5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLmNvbG9yID0gZGF0YS5saW5lY29sb3I7XHJcbiAgICAgICAgLy8gc2V0IGl0XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsaW5rcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy52ZXJ0Q291bnQgPSB2ZXJ0cy5fd2lkdGg7XHJcbiAgICAgICAgbGV0IGRyYXdzcGVlZCA9IHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCk7XHJcbiAgICAgICAgLy8gdmVydGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgdGhpcy52ZXJ0Q291bnQsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRzLmRhdGEsIGRyYXdzcGVlZCk7XHJcbiAgICAgICAgLy8gaW5kaWNlc1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBsaW5rcy5idWZmZXIsIGRyYXdzcGVlZCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIoYykge1xyXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgbGV0IG1hdHJpeCA9IGMuY2FtZXJhLnRvdGFsTWF0cml4O1xyXG4gICAgICAgIC8vIFRlbGwgaXQgdG8gdXNlIG91ciBwcm9ncmFtIChwYWlyIG9mIHNoYWRlcnMpXHJcbiAgICAgICAgLy8gUE9JTlRFUlMgTVVTVCBBTFNPIEJFIFNFVCwgRE8gRVZFUllUSElORyBFWENFUFQgR0wuQlVGRkVSREFUQVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFfcG9zaXRpb25fYnVmZmVyKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFfcG9zaXRpb24pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hX3Bvc2l0aW9uLCB0aGlzLnZlcnRDb3VudCwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhfYnVmZmVyKTtcclxuICAgICAgICBnbC51bmlmb3JtNGYodGhpcy51X2NvbG9yLCB0aGlzLmNvbG9yWzBdLCB0aGlzLmNvbG9yWzFdLCB0aGlzLmNvbG9yWzJdLCB0aGlzLmNvbG9yWzNdKTtcclxuICAgICAgICAvLyBzZXQgdW5pZm9ybXNcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudV90cmFuc2Zvcm0sIGZhbHNlLCBtYXRyaXguZGF0YSk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVfcGVyc29uYWwsIGZhbHNlLCB0aGlzLnBlcnNvbmFsLmRhdGEpO1xyXG4gICAgICAgIC8vIERyYXcgdGhlIHBvaW50LlxyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5MSU5FUywgdGhpcy5jb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIG5hbWU6ICAgIG1lc2gtcmVuZGVyZXIudHNcclxuLy8gYXV0aG9yOiAgSm9zIEZlZW5zdHJhXHJcbi8vIHB1cnBvc2U6IFdlYkdMIGJhc2VkIHJlbmRlcmluZyBvZiBhIG1lc2guXHJcbmltcG9ydCB7IERyYXdTcGVlZCwgTWF0cml4NCwgUmVuZGVyZXIgfSBmcm9tIFwiLi4vbGliXCI7XHJcbmV4cG9ydCBjbGFzcyBUcmFuc2Zvcm1NZXNoUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgY29sb3IgPSBbMSwgMCwgMCwgMC4yNV0pIHtcclxuICAgICAgICBjb25zdCB2cyA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICBhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIG1hdDQgdV90cmFuc2Zvcm07XG4gICAgICAgIHVuaWZvcm0gbWF0NCB1X3BlcnNvbmFsO1xuICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHVfdHJhbnNmb3JtICogdV9wZXJzb25hbCAqIGFfcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgYDtcclxuICAgICAgICBjb25zdCBmcyA9IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgaW50O1xuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHZlYzQgdV9jb2xvcjtcblxuICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdV9jb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBgO1xyXG4gICAgICAgIC8vIHNldHVwIHByb2dyYW1cclxuICAgICAgICBzdXBlcihnbCwgdnMsIGZzKTtcclxuICAgICAgICB0aGlzLnVfdHJhbnNmb3JtID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X3RyYW5zZm9ybVwiKTtcclxuICAgICAgICB0aGlzLnVfcGVyc29uYWwgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcInVfcGVyc29uYWxcIik7XHJcbiAgICAgICAgdGhpcy51X2NvbG9yID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIC8vIHdlIG5lZWQgMiBidWZmZXJzXHJcbiAgICAgICAgLy8gLT4gMSBmbG9hdCBidWZmZXIgZm9yIHRoZSBwb3NpdGlvbnMgb2YgYWxsIHZlcnRpY2VzLlxyXG4gICAgICAgIC8vIC0+IDEgaW50IGJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGFsbCB0cmlhbmdsZXNcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcclxuICAgICAgICB0aGlzLmFfcG9zaXRpb25fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5pbmRleF9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLnBlcnNvbmFsID0gTWF0cml4NC5uZXdJZGVudGl0eSgpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuICAgIHNldChkYXRhLCBzcGVlZCA9IERyYXdTcGVlZC5TdGF0aWNEcmF3KSB7XHJcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICBsZXQgbWVzaCA9IGRhdGEubWVzaDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gZGF0YS5jb2xvcjtcclxuICAgICAgICB0aGlzLnBlcnNvbmFsID0gZGF0YS5wb3NpdGlvbjtcclxuICAgICAgICAvLyBzYXZlIGhvdyBtYW55IGZhY2VzIG5lZWQgdG8gYmUgZHJhd25cclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IG1lc2gubGlua3MuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgLy8gdmVydGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMztcclxuICAgICAgICB2YXIgdHlwZSA9IGdsLkZMT0FUO1xyXG4gICAgICAgIHZhciBub3JtYWxpemUgPSBmYWxzZTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYV9wb3NpdGlvbiwgdGhpcy5zaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBtZXNoLnZlcnRzLmRhdGEsIHRoaXMuY29udmVydERyYXdTcGVlZChzcGVlZCkpO1xyXG4gICAgICAgIC8vIGluZGljZXNcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4X2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbWVzaC5saW5rcy5kYXRhLCB0aGlzLmNvbnZlcnREcmF3U3BlZWQoc3BlZWQpKTtcclxuICAgIH1cclxuICAgIC8vIHJlbmRlciAxIGltYWdlIHRvIHRoZSBzY3JlZW5cclxuICAgIHJlbmRlcihjKSB7XHJcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcclxuICAgICAgICBsZXQgbWF0cml4ID0gYy5jYW1lcmEudG90YWxNYXRyaXg7XHJcbiAgICAgICAgLy8gVGVsbCBpdCB0byB1c2Ugb3VyIHByb2dyYW0gKHBhaXIgb2Ygc2hhZGVycylcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hX3Bvc2l0aW9uKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hX3Bvc2l0aW9uX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFfcG9zaXRpb24sIHRoaXMuc2l6ZSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLmluZGV4X2J1ZmZlcik7XHJcbiAgICAgICAgLy8gc2V0IHVuaWZvcm1zXHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVfdHJhbnNmb3JtLCBmYWxzZSwgbWF0cml4LmRhdGEpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodGhpcy51X3BlcnNvbmFsLCBmYWxzZSwgdGhpcy5wZXJzb25hbC5kYXRhKTtcclxuICAgICAgICBnbC51bmlmb3JtNGYodGhpcy51X2NvbG9yLCB0aGlzLmNvbG9yWzBdLCB0aGlzLmNvbG9yWzFdLCB0aGlzLmNvbG9yWzJdLCB0aGlzLmNvbG9yWzNdKTtcclxuICAgICAgICAvLyBEcmF3IHRoZSBwb2ludC5cclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCB0aGlzLmNvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgMCk7XHJcbiAgICB9XHJcbiAgICBzZXRBbmRSZW5kZXIociwgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuc2V0KHIsIERyYXdTcGVlZC5EeW5hbWljRHJhdyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoY29udGV4dCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tYm8sIE1lc2gsIH0gZnJvbSBcIi4uL2xpYlwiO1xyXG5pbXBvcnQgeyBEcmF3U3BlZWQgfSBmcm9tIFwiLi4vcmVuZGVyL3JlbmRlcmVyXCI7XHJcbmltcG9ydCB7IFRyYW5zZm9ybUxpbmVSZW5kZXJlciB9IGZyb20gXCIuLi9yZW5kZXJlcnMvdHJhbnNmb3JtLWxpbmUtcmVuZGVyZXJcIjtcclxuaW1wb3J0IHsgVHJhbnNmb3JtTWVzaFJlbmRlcmVyIH0gZnJvbSBcIi4uL3JlbmRlcmVycy90cmFuc2Zvcm0tbWVzaC1yZW5kZXJlclwiO1xyXG5leHBvcnQgY2xhc3MgU3RhdGljTWVzaENvbWJvIGV4dGVuZHMgQ29tYm8ge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICBzdXBlcihnbCwgTWVzaC5uZXdFbXB0eSgwLCAwLCAwKSwgVHJhbnNmb3JtTGluZVJlbmRlcmVyLm5ldyk7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFswLCAwLCAwLCAwLjhdO1xyXG4gICAgICAgIHRoaXMubGluZWNvbG9yID0gWzAuMywgMC4zLCAwLjMsIDFdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIyID0gbmV3IFRyYW5zZm9ybU1lc2hSZW5kZXJlcihnbCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV3KGdsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0aWNNZXNoQ29tYm8oZ2wpO1xyXG4gICAgfVxyXG4gICAgc2V0KG1lc2gpIHtcclxuICAgICAgICB0aGlzLnN0YXRlID0gbWVzaDtcclxuICAgICAgICB0aGlzLmJ1ZmZlcigpO1xyXG4gICAgfVxyXG4gICAgLy8gaG93IHRvIGNvbnZlcnQgZnJvbSBzdGF0ZSB0byBidWZmZXJlZFxyXG4gICAgYnVmZmVyKCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyZWQgPSB0aGlzLnN0YXRlLnRvUmVuZGVyYWJsZSgpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVyZWQuY2FsY3VsYXRlRmFjZU5vcm1hbHMoKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB0aGlzLmJ1ZmZlcmVkLmxpbmVjb2xvciA9IHRoaXMubGluZWNvbG9yO1xyXG4gICAgICAgIHRoaXMuY29tbWl0KCk7XHJcbiAgICB9XHJcbiAgICBjb21taXQoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZC5jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgdGhpcy5idWZmZXJlZC5saW5lY29sb3IgPSB0aGlzLmxpbmVjb2xvcjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldCh0aGlzLmJ1ZmZlcmVkLCBEcmF3U3BlZWQuU3RhdGljRHJhdyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcjIuc2V0KHRoaXMuYnVmZmVyZWQsIERyYXdTcGVlZC5TdGF0aWNEcmF3KTtcclxuICAgIH1cclxuICAgIHJlbmRlcihjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcjIucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIFRPRE9cclxuLy8gLSBpbXByb3ZlIHF1YWRpZmljYXRpb246IGxlc3MgdHJpYW5nbGVzIVxyXG4vLyAtIGltcHJvdmUgc3F1YXJpZmljYXRpb246IHNwZWVkICYgZXF1YWwgc2l6ZXNcclxuaW1wb3J0IHsgQXBwLCBDYW1lcmEsIFBhcmFtZXRlciwgVmVjdG9yMywgTWF0cml4NCwgRW51bVBhcmFtZXRlciwgQ29udGV4dCwgVmVjdG9yMiwgR2Vvbk1hdGgsIH0gZnJvbSBcIi4uLy4uLy4uL3NyYy9saWJcIjtcclxuaW1wb3J0IHsgY29uc3RydWN0TWVzaEZyb21TcGhlcmVHcmFwaCwgY3JlYXRlR3JhcGggfSBmcm9tIFwiLi9zcGhlcmljYWxcIjtcclxuaW1wb3J0IHsgYXZlcmFnZUVkZ2VMZW5ndGggfSBmcm9tIFwiLi9zcGhlcmljYWxcIjtcclxuaW1wb3J0IHsgU3RhdGljTWVzaENvbWJvIH0gZnJvbSBcIi4uLy4uLy4uL3NyYy9yZW5kZXJjb21ib3MvbWVzaC1jb21ib1wiO1xyXG5leHBvcnQgY2xhc3MgU3BoZXJpY2FsTGFuZGluZ0FwcCBleHRlbmRzIEFwcCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIHN1cGVyKGdsLCBcIk11bHRpcGxlIExheWVycyBvZiBzcGhlcmljYWwgZ2VvbWV0cnlcIik7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjE7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhsaW1pdCA9IDA7XHJcbiAgICAgICAgdGhpcy53b3JsZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmxlcnBDb2xvclN0YXRlID0gMDtcclxuICAgICAgICB0aGlzLm1vdXNlUG9zID0gbmV3IFZlY3RvcjIoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5sZXJwU3BlZWQgPSAwLjE7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFswLCAwLCAwLCAwLjhdO1xyXG4gICAgICAgIHRoaXMubGluZWNvbG9yID0gWzAuMywgMC4zLCAwLjMsIDFdO1xyXG4gICAgICAgIGxldCBjYW52YXMgPSBnbC5jYW52YXM7XHJcbiAgICAgICAgdGhpcy5jID0gbmV3IENvbnRleHQobmV3IENhbWVyYShjYW52YXMsIDEsIHRydWUpKTtcclxuICAgICAgICB0aGlzLmMuY2FtZXJhLnBvcyA9IG5ldyBWZWN0b3IzKC0wLjQxMzQ3MDk2NDg3ODgwNTQ3LCAxLjQ5NDQ4MDQ4NDg3MzA2MDYsIDAuODMwMDAwMDAwMDAwMDAwNik7XHJcbiAgICAgICAgdGhpcy5jLmNhbWVyYS5zZXQoLTEsIDIuMzc5ODk5LCAwLjc1MSk7XHJcbiAgICAgICAgLy8gdGhpcy5jLmNhbWVyYS5zZXQoLTQuMDgsIDEuMjQsIC0wLjcxKTtcclxuICAgIH1cclxuICAgIHVpKHVpKSB7XHJcbiAgICAgICAgbGV0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyB0aGlzLnJvdGF0ZS5zZXQoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucm90YXRlID0gbmV3IFBhcmFtZXRlcihcInJvdGF0ZVwiLCAxLCAwLCAxLCAxKTtcclxuICAgICAgICB0aGlzLnJhbmRvbUVkZ2VzID0gbmV3IFBhcmFtZXRlcihcImRlbGV0ZSBlZGdlc1wiLCAxLCAwLCAxLCAxKTtcclxuICAgICAgICB0aGlzLnNtb290aCA9IG5ldyBQYXJhbWV0ZXIoXCJzbW9vdGhcIiwgMCwgMCwgMSwgMSk7XHJcbiAgICAgICAgdGhpcy5zdWJDb3VudCA9IG5ldyBQYXJhbWV0ZXIoXCJzdWIgY291bnRcIiwgMiwgMCwgNCwgMSk7XHJcbiAgICAgICAgdGhpcy5xdWFkU3ViQ291bnQgPSBuZXcgUGFyYW1ldGVyKFwic3ViIGNvdW50IHF1YWRcIiwgMSwgMCwgMiwgMSk7XHJcbiAgICAgICAgdGhpcy5saWZ0VHlwZSA9IEVudW1QYXJhbWV0ZXIubmV3KFwibGlmdCB0eXBlXCIsIDEsIFtcIm5vbmVcIiwgXCJzcGhlcmVcIiwgXCJidWdneVwiXSk7XHJcbiAgICAgICAgdWkuaGlkZSgpO1xyXG4gICAgICAgIHVpLmFkZEJvb2xlYW5QYXJhbWV0ZXIodGhpcy5yb3RhdGUpO1xyXG4gICAgICAgIHVpLmFkZEJvb2xlYW5QYXJhbWV0ZXIodGhpcy5yYW5kb21FZGdlcywgcmVzZXQpO1xyXG4gICAgICAgIHVpLmFkZEJvb2xlYW5QYXJhbWV0ZXIodGhpcy5zbW9vdGgpO1xyXG4gICAgICAgIHVpLmFkZFBhcmFtZXRlcih0aGlzLnN1YkNvdW50LCByZXNldCk7XHJcbiAgICAgICAgdWkuYWRkUGFyYW1ldGVyKHRoaXMucXVhZFN1YkNvdW50LCByZXNldCk7XHJcbiAgICAgICAgdWkuYWRkUGFyYW1ldGVyKHRoaXMubGlmdFR5cGUsIHJlc2V0KTtcclxuICAgICAgICB1aS5hZGRCdXR0b24oXCJyZWNhbGN1bGF0ZVwiLCByZXNldCk7XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICAvLyBzZXQgc29tZSB2YWx1ZXNcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IDE7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhsaW1pdCA9IDA7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBncmFwaFxyXG4gICAgICAgIHRoaXMuZ3JhcGggPSBjcmVhdGVHcmFwaCgxLCB0aGlzLnN1YkNvdW50LmdldCgpLCB0aGlzLnF1YWRTdWJDb3VudC5nZXQoKSwgdGhpcy5yYW5kb21FZGdlcy5nZXQoKSk7XHJcbiAgICAgICAgLy8gNSB8IGNvbnZlcnRcclxuICAgICAgICB0aGlzLmF2ZXJhZ2UgPSBhdmVyYWdlRWRnZUxlbmd0aCh0aGlzLmdyYXBoKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcldvcmxkKCk7XHJcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuZ2wuY2FudmFzO1xyXG4gICAgICAgIGxldCBnb3RvID0gY2FudmFzLmdldEF0dHJpYnV0ZShcImRhdGEtZ290b1wiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhnb3RvKTtcclxuICAgIH1cclxuICAgIGJ1ZmZlcldvcmxkKCkge1xyXG4gICAgICAgIHRoaXMud29ybGRzID0gW107XHJcbiAgICAgICAgbGV0IGxldmVscyA9IFswLCAwLjEsIDAuMiwgMC4zXTtcclxuICAgICAgICBsZXQgZnJlcXMgPSBbMC43LCAwLjUsIDAuM107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGJvdCA9IGxldmVsc1tpXTtcclxuICAgICAgICAgICAgbGV0IHRvcCA9IGxldmVsc1tpICsgMV07XHJcbiAgICAgICAgICAgIGxldCBmcmVxID0gZnJlcXNbaV07XHJcbiAgICAgICAgICAgIGxldCBtYyA9IFN0YXRpY01lc2hDb21iby5uZXcodGhpcy5nbCk7XHJcbiAgICAgICAgICAgIG1jLnNldChjb25zdHJ1Y3RNZXNoRnJvbVNwaGVyZUdyYXBoKHRoaXMuZ3JhcGgsIHRoaXMucmFkaXVzLCBib3QsIHRvcCwgZnJlcSkpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkcy5wdXNoKG1jKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmMuY2FtZXJhLnVwZGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgLy8gdXBkYXRlIHJvdGF0aW9uXHJcbiAgICAgICAgbGV0IHNwZWVkYiA9IDAuMDAwMDc7XHJcbiAgICAgICAgbGV0IHNjYWxhciA9IDEgKyA1ICogTWF0aC5sb2cxMCgxICsgdGhpcy5tb3VzZVBvcy5kaXNUbyhzdGF0ZS5tb3VzZVBvcykpO1xyXG4gICAgICAgIHRoaXMubW91c2VQb3MgPSBzdGF0ZS5tb3VzZVBvcztcclxuICAgICAgICBzcGVlZGIgKj0gc2NhbGFyO1xyXG4gICAgICAgIHRoaXMubGVycFNwZWVkID0gR2Vvbk1hdGgubGVycCh0aGlzLmxlcnBTcGVlZCwgc3BlZWRiLCAwLjAzKTtcclxuICAgICAgICAvLyByb3RhdGUgbWVzaFxyXG4gICAgICAgIGlmICh0aGlzLnJvdGF0ZS5nZXQoKSA9PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHJvdGF0ZVxyXG4gICAgICAgICAgICBsZXQgYWxwaGEgPSB0aGlzLmxlcnBTcGVlZCAqIHN0YXRlLnRpY2s7XHJcbiAgICAgICAgICAgIGxldCByb3R4ID0gTWF0cml4NC5uZXdYUm90YXRpb24oYWxwaGEpO1xyXG4gICAgICAgICAgICBsZXQgcm90eSA9IE1hdHJpeDQubmV3WVJvdGF0aW9uKGFscGhhKTtcclxuICAgICAgICAgICAgbGV0IHJvdCA9IHJvdHgubXVsdGlwbHkocm90eSk7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGRzWzBdLmJ1ZmZlcmVkLnBvc2l0aW9uLm11bHRpcGx5KHJvdCk7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGRzWzFdLmJ1ZmZlcmVkLnBvc2l0aW9uLm11bHRpcGx5KE1hdHJpeDQubmV3WFJvdGF0aW9uKC1hbHBoYSkpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkc1syXS5idWZmZXJlZC5wb3NpdGlvbi5tdWx0aXBseShNYXRyaXg0Lm5ld1pSb3RhdGlvbigtYWxwaGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIGNvbG9yXHJcbiAgICAgICAgdGhpcy51cGRhdGVDb2xvcnMoc3RhdGUpO1xyXG4gICAgICAgIC8vIGNvbW1pdFxyXG4gICAgICAgIGZvciAobGV0IHdvcmxkIG9mIHRoaXMud29ybGRzKSB7XHJcbiAgICAgICAgICAgIHdvcmxkLmNvbW1pdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUNvbG9ycyhzdGF0ZSkge1xyXG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLmdsLmNhbnZhcztcclxuICAgICAgICBjb25zdCBzdGVwID0gMC4wMDM7XHJcbiAgICAgICAgbGV0IGZpbGxlZCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZpbGxlZFwiKTtcclxuICAgICAgICBpZiAoZmlsbGVkID09IFwiMVwiICYmIHRoaXMubGVycENvbG9yU3RhdGUgPCAxKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbGwgaXRcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaWxsXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxlcnBDb2xvclN0YXRlICs9IHN0ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZpbGxlZCA9PSBcIjBcIiAmJiB0aGlzLmxlcnBDb2xvclN0YXRlID4gMCkge1xyXG4gICAgICAgICAgICAvLyBlbXB0eSBpdFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImVtcHR5XCIpO1xyXG4gICAgICAgICAgICB0aGlzLmxlcnBDb2xvclN0YXRlIC09IHN0ZXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBmYWRlMSA9IEdlb25NYXRoLmZhZGUodGhpcy5sZXJwQ29sb3JTdGF0ZSk7XHJcbiAgICAgICAgbGV0IGZhZGUyID0gR2Vvbk1hdGguZmFkZShNYXRoLm1pbih0aGlzLmxlcnBDb2xvclN0YXRlICogMiwgMSkpO1xyXG4gICAgICAgIHRoaXMud29ybGRzLmZvckVhY2goKHcpID0+IHtcclxuICAgICAgICAgICAgdy5jb2xvciA9IGJsZW5kQ29sb3IodGhpcy5jb2xvciwgWzAsIDAsIDAsIDBdLCAxIC0gZmFkZTEpO1xyXG4gICAgICAgICAgICB3LmxpbmVjb2xvciA9IGJsZW5kQ29sb3IodGhpcy5saW5lY29sb3IsIFswLCAwLCAwLCAwXSwgMSAtIGZhZGUyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxlcnBTcGVlZCAqPSBmYWRlMTtcclxuICAgIH1cclxuICAgIGRyYXcoZ2wpIHtcclxuICAgICAgICBpZiAodGhpcy5sZXJwQ29sb3JTdGF0ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgd29ybGQgb2YgdGhpcy53b3JsZHMpIHtcclxuICAgICAgICAgICAgd29ybGQucmVuZGVyKHRoaXMuYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGJsZW5kQ29sb3IoYSwgYiwgZGVsdGEpIHtcclxuICAgIHJldHVybiBhLm1hcCgodiwgaSkgPT4ge1xyXG4gICAgICAgIHJldHVybiB2ICogKDEgLSBkZWx0YSkgKyBiW2ldICogZGVsdGE7XHJcbiAgICB9KTtcclxufVxyXG4iLCIvLyBOYW1lOiAgICBpbmRleC50c1xyXG4vLyBBdXRob3I6ICBKb3MgRmVlbnN0cmFcclxuLy8gUHVycG9zZTogRW50cnkgcG9pbnRcclxuaW1wb3J0IHsgQ29yZSwgUmVuZGVyZXIsIFN3YXBBcHAgfSBmcm9tIFwiLi4vc3JjL2xpYlwiO1xyXG5pbXBvcnQgeyBTcGhlcmljYWxMYW5kaW5nQXBwIH0gZnJvbSBcIi4vYXBwcy9zcGhlcmljYWwvc3BoZXJpY2FsLWxhbmRpbmdcIjtcclxudmFyIGNvcmU7XHJcbmZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgICAvLyBnZXQgcmVmZXJlbmNlcyBvZiBhbGwgaXRlbXMgb24gdGhlIGNhbnZhc1xyXG4gICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FudmFzXCIpO1xyXG4gICAgbGV0IHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYW1lcmFcIik7XHJcbiAgICBsZXQgdWkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImludGVyZmFjZVwiKTtcclxuICAgIGxldCBjYW1lcmFPbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FtZXJhLW9uXCIpO1xyXG4gICAgbGV0IGNhbWVyYVN0b3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbWVyYS1vZmZcIik7XHJcbiAgICBsZXQgYnV0dG9uUHJlZGljdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdFwiKTtcclxuICAgIC8vIGluaXQgY29yZVxyXG4gICAgbGV0IGdsID0gUmVuZGVyZXIuaW5pdFdlYmdsQ29udGV4dChjYW52YXMpO1xyXG4gICAgY29yZSA9IG5ldyBDb3JlKGNhbnZhcywgZ2wsIHVpKTtcclxuICAgIC8vIGluaXQgc3dhcCBhcHBcclxuICAgIGxldCBhcHBDb2xsZWN0aW9uID0gW1NwaGVyaWNhbExhbmRpbmdBcHBdO1xyXG4gICAgbGV0IHN3YXBBcHAgPSBuZXcgU3dhcEFwcChnbCwgY29yZSwgYXBwQ29sbGVjdGlvbik7XHJcbiAgICBjb3JlLmFkZEFwcChzd2FwQXBwKTtcclxuICAgIHN3YXBBcHAuc3dhcCgwKTtcclxuICAgIC8vIGluZmluaXRlIGxvb3BcclxuICAgIGZ1bmN0aW9uIGxvb3AoKSB7XHJcbiAgICAgICAgaWYgKGNvcmUuU1RPUCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIDogbm90aWZ5IHRoZSBVc2VyIHRoYXQgd2UgaGF2ZSBzdG9wcGVkIHJ1bm5pbmcuLi5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3JlLnVwZGF0ZSgpO1xyXG4gICAgICAgIGNvcmUuZHJhdygpO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxuICAgIH1cclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcclxufVxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgbWFpbigpO1xyXG59LCBmYWxzZSk7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///374\n')})();